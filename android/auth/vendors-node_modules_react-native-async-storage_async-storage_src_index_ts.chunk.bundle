(self["webpackChunksas_auth"] = self["webpackChunksas_auth"] || []).push([["vendors-node_modules_react-native-async-storage_async-storage_src_index_ts"], {
10711: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return _default;
    }
}));
var _reactnative = __webpack_require__(64598);
var _shouldFallbackToLegacyNativeModule = __webpack_require__(64630);
// TurboModuleRegistry falls back to NativeModules so we don't have to try go
// assign NativeModules' counterparts if TurboModuleRegistry would resolve
// with undefined.
var RCTAsyncStorage = _reactnative.TurboModuleRegistry ? _reactnative.TurboModuleRegistry.get("PlatformLocalStorage") || // Support for external modules, like react-native-windows
_reactnative.TurboModuleRegistry.get("RNC_AsyncSQLiteDBStorage") || _reactnative.TurboModuleRegistry.get("RNCAsyncStorage") : _reactnative.NativeModules["PlatformLocalStorage"] || // Support for external modules, like react-native-windows
_reactnative.NativeModules["RNC_AsyncSQLiteDBStorage"] || _reactnative.NativeModules["RNCAsyncStorage"];
if (!RCTAsyncStorage && (0, _shouldFallbackToLegacyNativeModule.shouldFallbackToLegacyNativeModule)()) {
    if (_reactnative.TurboModuleRegistry) {
        RCTAsyncStorage = _reactnative.TurboModuleRegistry.get("AsyncSQLiteDBStorage") || _reactnative.TurboModuleRegistry.get("AsyncLocalStorage");
    } else {
        RCTAsyncStorage = _reactnative.NativeModules["AsyncSQLiteDBStorage"] || _reactnative.NativeModules["AsyncLocalStorage"];
    }
}
var _default = RCTAsyncStorage;


}),
27470: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get default () {
        return _default;
    },
    get useAsyncStorage () {
        return _hooks.useAsyncStorage;
    }
});
var _interop_require_default = __webpack_require__(48810);
var _AsyncStorage = /*#__PURE__*/ _interop_require_default._(__webpack_require__(44356));
var _hooks = __webpack_require__(42517);
var _default = _AsyncStorage.default;


}),
42517: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "useAsyncStorage", ({
    enumerable: true,
    get: function() {
        return useAsyncStorage;
    }
}));
var _interop_require_default = __webpack_require__(48810);
var _to_consumable_array = __webpack_require__(8034);
var _AsyncStorage = /*#__PURE__*/ _interop_require_default._(__webpack_require__(44356));
function useAsyncStorage(key) {
    var _AsyncStorage1, _AsyncStorage2, _AsyncStorage3, _AsyncStorage4;
    return {
        getItem: function() {
            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                args[_key] = arguments[_key];
            }
            return (_AsyncStorage1 = _AsyncStorage.default).getItem.apply(_AsyncStorage1, [
                key
            ].concat(_to_consumable_array._(args)));
        },
        setItem: function() {
            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                args[_key] = arguments[_key];
            }
            return (_AsyncStorage2 = _AsyncStorage.default).setItem.apply(_AsyncStorage2, [
                key
            ].concat(_to_consumable_array._(args)));
        },
        mergeItem: function() {
            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                args[_key] = arguments[_key];
            }
            return (_AsyncStorage3 = _AsyncStorage.default).mergeItem.apply(_AsyncStorage3, [
                key
            ].concat(_to_consumable_array._(args)));
        },
        removeItem: function() {
            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                args[_key] = arguments[_key];
            }
            return (_AsyncStorage4 = _AsyncStorage.default).removeItem.apply(_AsyncStorage4, [
                key
            ].concat(_to_consumable_array._(args)));
        }
    };
}


}),
42825: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get checkValidArgs () {
        return checkValidArgs;
    },
    get checkValidInput () {
        return checkValidInput;
    },
    get convertError () {
        return convertError;
    },
    get convertErrors () {
        return convertErrors;
    }
});
var _sliced_to_array = __webpack_require__(21193);
var _type_of = __webpack_require__(29936);
function checkValidArgs(keyValuePairs, callback) {
    if (!Array.isArray(keyValuePairs) || keyValuePairs.length === 0 || !Array.isArray(keyValuePairs[0])) {
        throw new Error("[AsyncStorage] Expected array of key-value pairs as first argument to multiSet");
    }
    if (callback && typeof callback !== "function") {
        if (Array.isArray(callback)) {
            throw new Error("[AsyncStorage] Expected function as second argument to multiSet. Did you forget to wrap key-value pairs in an array for the first argument?");
        }
        throw new Error("[AsyncStorage] Expected function as second argument to multiSet");
    }
}
function checkValidInput() {
    for(var _len = arguments.length, input = new Array(_len), _key = 0; _key < _len; _key++){
        input[_key] = arguments[_key];
    }
    var _input = _sliced_to_array._(input, 2), key = _input[0], value = _input[1];
    if (typeof key !== "string") {
        // eslint-disable-next-line no-console
        console.warn("[AsyncStorage] Using " + (typeof key === "undefined" ? "undefined" : _type_of._(key)) + " type for key is not supported. This can lead to unexpected behavior/errors. Use string instead.\nKey passed: " + key + "\n");
    }
    if (input.length > 1 && typeof value !== "string") {
        if (value == null) {
            throw new Error("[AsyncStorage] Passing null/undefined as value is not supported. If you want to remove value, Use .removeItem method instead.\nPassed value: " + value + "\nPassed key: " + key + "\n");
        } else {
            // eslint-disable-next-line no-console
            console.warn('[AsyncStorage] The value for key "' + key + '" is not a string. This can lead to unexpected behavior/errors. Consider stringifying it.\nPassed value: ' + value + "\nPassed key: " + key + "\n");
        }
    }
}
function convertError(error) {
    if (!error) {
        return null;
    }
    var out = new Error(error.message);
    out["key"] = error.key;
    return out;
}
function convertErrors(errs) {
    var errors = ensureArray(errs);
    return errors ? errors.map(function(e) {
        return convertError(e);
    }) : null;
}
function ensureArray(e) {
    if (Array.isArray(e)) {
        return e.length === 0 ? null : e;
    } else if (e) {
        return [
            e
        ];
    } else {
        return null;
    }
}


}),
44356: (function (__unused_webpack_module, exports, __webpack_require__) {
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return _default;
    }
}));
var _interop_require_default = __webpack_require__(48810);
var _sliced_to_array = __webpack_require__(21193);
var _helpers = __webpack_require__(42825);
var _RCTAsyncStorage = /*#__PURE__*/ _interop_require_default._(__webpack_require__(10711));
if (!_RCTAsyncStorage.default) {
    throw new Error("[@RNC/AsyncStorage]: NativeModule: AsyncStorage is null.\n\nTo fix this issue try these steps:\n\n  \u2022 Uninstall, rebuild and restart the app.\n\n  \u2022 Run the packager with `--reset-cache` flag.\n\n  \u2022 If you are using CocoaPods on iOS, run `pod install` in the `ios` directory, then rebuild and re-run the app.\n\n  \u2022 Make sure your project's `package.json` depends on `@react-native-async-storage/async-storage`, even if you only depend on it indirectly through other dependencies. CLI only autolinks native modules found in your `package.json`.\n\n  \u2022 If this happens while testing with Jest, check out how to integrate AsyncStorage here: https://react-native-async-storage.github.io/async-storage/docs/advanced/jest\n\nIf none of these fix the issue, please open an issue on the GitHub repository: https://github.com/react-native-async-storage/async-storage/issues\n");
}
/**
 * `AsyncStorage` is a simple, unencrypted, asynchronous, persistent, key-value
 * storage system that is global to the app. It should be used instead of
 * LocalStorage.
 *
 * See https://react-native-async-storage.github.io/async-storage/docs/api
 */ var AsyncStorage = function() {
    var _getRequests = [];
    var _getKeys = [];
    var _immediate = null;
    return {
        /**
     * Fetches an item for a `key` and invokes a callback upon completion.
     *
     * See https://react-native-async-storage.github.io/async-storage/docs/api#getitem
     */ getItem: function(key, callback) {
            return new Promise(function(resolve, reject) {
                (0, _helpers.checkValidInput)(key);
                _RCTAsyncStorage.default.multiGet([
                    key
                ], function(errors, result) {
                    var _result_;
                    // Unpack result to get value from [[key,value]]
                    var value = (result == null ? void 0 : (_result_ = result[0]) == null ? void 0 : _result_[1]) ? result[0][1] : null;
                    var errs = (0, _helpers.convertErrors)(errors);
                    callback == null ? void 0 : callback(errs == null ? void 0 : errs[0], value);
                    if (errs) {
                        reject(errs[0]);
                    } else {
                        resolve(value);
                    }
                });
            });
        },
        /**
     * Sets the value for a `key` and invokes a callback upon completion.
     *
     * See https://react-native-async-storage.github.io/async-storage/docs/api#setitem
     */ setItem: function(key, value, callback) {
            return new Promise(function(resolve, reject) {
                (0, _helpers.checkValidInput)(key, value);
                _RCTAsyncStorage.default.multiSet([
                    [
                        key,
                        value
                    ]
                ], function(errors) {
                    var errs = (0, _helpers.convertErrors)(errors);
                    callback == null ? void 0 : callback(errs == null ? void 0 : errs[0]);
                    if (errs) {
                        reject(errs[0]);
                    } else {
                        resolve();
                    }
                });
            });
        },
        /**
     * Removes an item for a `key` and invokes a callback upon completion.
     *
     * See https://react-native-async-storage.github.io/async-storage/docs/api#removeitem
     */ removeItem: function(key, callback) {
            return new Promise(function(resolve, reject) {
                (0, _helpers.checkValidInput)(key);
                _RCTAsyncStorage.default.multiRemove([
                    key
                ], function(errors) {
                    var errs = (0, _helpers.convertErrors)(errors);
                    callback == null ? void 0 : callback(errs == null ? void 0 : errs[0]);
                    if (errs) {
                        reject(errs[0]);
                    } else {
                        resolve();
                    }
                });
            });
        },
        /**
     * Merges an existing `key` value with an input value, assuming both values
     * are stringified JSON.
     *
     * See https://react-native-async-storage.github.io/async-storage/docs/api#mergeitem
     */ mergeItem: function(key, value, callback) {
            return new Promise(function(resolve, reject) {
                (0, _helpers.checkValidInput)(key, value);
                _RCTAsyncStorage.default.multiMerge([
                    [
                        key,
                        value
                    ]
                ], function(errors) {
                    var errs = (0, _helpers.convertErrors)(errors);
                    callback == null ? void 0 : callback(errs == null ? void 0 : errs[0]);
                    if (errs) {
                        reject(errs[0]);
                    } else {
                        resolve();
                    }
                });
            });
        },
        /**
     * Erases *all* `AsyncStorage` for all clients, libraries, etc. You probably
     * don't want to call this; use `removeItem` or `multiRemove` to clear only
     * your app's keys.
     *
     * See https://react-native-async-storage.github.io/async-storage/docs/api#clear
     */ clear: function(callback) {
            return new Promise(function(resolve, reject) {
                _RCTAsyncStorage.default.clear(function(error) {
                    var err = (0, _helpers.convertError)(error);
                    callback == null ? void 0 : callback(err);
                    if (err) {
                        reject(err);
                    } else {
                        resolve();
                    }
                });
            });
        },
        /**
     * Gets *all* keys known to your app; for all callers, libraries, etc.
     *
     * See https://react-native-async-storage.github.io/async-storage/docs/api#getallkeys
     */ getAllKeys: function(callback) {
            return new Promise(function(resolve, reject) {
                _RCTAsyncStorage.default.getAllKeys(function(error, keys) {
                    var err = (0, _helpers.convertError)(error);
                    callback == null ? void 0 : callback(err, keys);
                    if (keys) {
                        resolve(keys);
                    } else {
                        reject(err);
                    }
                });
            });
        },
        /**
     * The following batched functions are useful for executing a lot of
     * operations at once, allowing for native optimizations and provide the
     * convenience of a single callback after all operations are complete.
     *
     * These functions return arrays of errors, potentially one for every key.
     * For key-specific errors, the Error object will have a key property to
     * indicate which key caused the error.
     */ /**
     * Flushes any pending requests using a single batch call to get the data.
     *
     * See https://react-native-async-storage.github.io/async-storage/docs/api#flushgetrequests
     * */ flushGetRequests: function() {
            var getRequests = _getRequests;
            var getKeys = _getKeys;
            _getRequests = [];
            _getKeys = [];
            _RCTAsyncStorage.default.multiGet(getKeys, function(errors, result) {
                // Even though the runtime complexity of this is theoretically worse vs if we used a map,
                // it's much, much faster in practice for the data sets we deal with (we avoid
                // allocating result pair arrays). This was heavily benchmarked.
                //
                // Is there a way to avoid using the map but fix the bug in this breaking test?
                // https://github.com/facebook/react-native/commit/8dd8ad76579d7feef34c014d387bf02065692264
                var map = {};
                result == null ? void 0 : result.forEach(function(param) {
                    var _param = _sliced_to_array._(param, 2), key = _param[0], value = _param[1];
                    map[key] = value;
                    return value;
                });
                var reqLength = getRequests.length;
                /**
           * As mentioned few lines above, this method could be called with the array of potential error,
           * in case of anything goes wrong. The problem is, if any of the batched calls fails
           * the rest of them would fail too, but the error would be consumed by just one. The rest
           * would simply return `undefined` as their result, rendering false negatives.
           *
           * In order to avoid this situation, in case of any call failing,
           * the rest of them will be rejected as well (with the same error).
           */ var errorList = (0, _helpers.convertErrors)(errors);
                var error = (errorList == null ? void 0 : errorList.length) ? errorList[0] : null;
                for(var i = 0; i < reqLength; i++){
                    var request = getRequests[i];
                    if (error) {
                        request.callback == null ? void 0 : request.callback.call(request, errorList);
                        request.reject == null ? void 0 : request.reject.call(request, error);
                        continue;
                    }
                    var requestResult = request.keys.map(function(key) {
                        return [
                            key,
                            map[key]
                        ];
                    });
                    request.callback == null ? void 0 : request.callback.call(request, null, requestResult);
                    request.resolve == null ? void 0 : request.resolve.call(request, requestResult);
                }
            });
        },
        /**
     * This allows you to batch the fetching of items given an array of `key`
     * inputs. Your callback will be invoked with an array of corresponding
     * key-value pairs found.
     *
     * See https://react-native-async-storage.github.io/async-storage/docs/api#multiget
     */ multiGet: function(keys, callback) {
            if (!_immediate) {
                _immediate = setImmediate(function() {
                    _immediate = null;
                    AsyncStorage.flushGetRequests();
                });
            }
            var getRequest = {
                keys: keys,
                callback: callback,
                // do we need this?
                keyIndex: _getKeys.length
            };
            var promiseResult = new Promise(function(resolve, reject) {
                getRequest.resolve = resolve;
                getRequest.reject = reject;
            });
            _getRequests.push(getRequest);
            // avoid fetching duplicates
            keys.forEach(function(key) {
                if (_getKeys.indexOf(key) === -1) {
                    _getKeys.push(key);
                }
            });
            return promiseResult;
        },
        /**
     * Use this as a batch operation for storing multiple key-value pairs. When
     * the operation completes you'll get a single callback with any errors.
     *
     * See https://react-native-async-storage.github.io/async-storage/docs/api#multiset
     */ multiSet: function(keyValuePairs, callback) {
            (0, _helpers.checkValidArgs)(keyValuePairs, callback);
            return new Promise(function(resolve, reject) {
                keyValuePairs.forEach(function(param) {
                    var _param = _sliced_to_array._(param, 2), key = _param[0], value = _param[1];
                    (0, _helpers.checkValidInput)(key, value);
                });
                _RCTAsyncStorage.default.multiSet(keyValuePairs, function(errors) {
                    var error = (0, _helpers.convertErrors)(errors);
                    callback == null ? void 0 : callback(error);
                    if (error) {
                        reject(error);
                    } else {
                        resolve();
                    }
                });
            });
        },
        /**
     * Call this to batch the deletion of all keys in the `keys` array.
     *
     * See https://react-native-async-storage.github.io/async-storage/docs/api#multiremove
     */ multiRemove: function(keys, callback) {
            return new Promise(function(resolve, reject) {
                keys.forEach(function(key) {
                    return (0, _helpers.checkValidInput)(key);
                });
                _RCTAsyncStorage.default.multiRemove(keys, function(errors) {
                    var error = (0, _helpers.convertErrors)(errors);
                    callback == null ? void 0 : callback(error);
                    if (error) {
                        reject(error);
                    } else {
                        resolve();
                    }
                });
            });
        },
        /**
     * Batch operation to merge in existing and new values for a given set of
     * keys. This assumes that the values are stringified JSON.
     *
     * See https://react-native-async-storage.github.io/async-storage/docs/api#multimerge
     */ multiMerge: function(keyValuePairs, callback) {
            return new Promise(function(resolve, reject) {
                _RCTAsyncStorage.default.multiMerge(keyValuePairs, function(errors) {
                    var error = (0, _helpers.convertErrors)(errors);
                    callback == null ? void 0 : callback(error);
                    if (error) {
                        reject(error);
                    } else {
                        resolve();
                    }
                });
            });
        }
    };
}();
var _default = AsyncStorage;


}),
64630: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "shouldFallbackToLegacyNativeModule", ({
    enumerable: true,
    get: function() {
        return shouldFallbackToLegacyNativeModule;
    }
}));
var _reactnative = __webpack_require__(64598);
function shouldFallbackToLegacyNativeModule() {
    var _NativeModules_NativeUnimoduleProxy_modulesConstants, _NativeModules_NativeUnimoduleProxy;
    var expoConstants = (_NativeModules_NativeUnimoduleProxy = _reactnative.NativeModules["NativeUnimoduleProxy"]) == null ? void 0 : (_NativeModules_NativeUnimoduleProxy_modulesConstants = _NativeModules_NativeUnimoduleProxy.modulesConstants) == null ? void 0 : _NativeModules_NativeUnimoduleProxy_modulesConstants.ExponentConstants;
    if (expoConstants) {
        /**
     * In SDK <= 39, appOwnership is defined in managed apps but executionEnvironment is not.
     * In bare React Native apps using expo-constants, appOwnership is never defined, so
     * isLegacySdkVersion will be false in that context.
     */ var isLegacySdkVersion = expoConstants.appOwnership && !expoConstants.executionEnvironment;
        /**
     * Expo managed apps don't include the @react-native-async-storage/async-storage
     * native modules yet, but the API interface is the same, so we can use the version
     * exported from React Native still.
     *
     * If in future releases (eg: @react-native-async-storage/async-storage >= 2.0.0) this
     * will likely not be valid anymore, and the package will need to be included in the Expo SDK
     * to continue to work.
     */ if (isLegacySdkVersion || [
            "storeClient",
            "standalone"
        ].includes(expoConstants.executionEnvironment)) {
            return true;
        }
    }
    return false;
}


}),

}]);//# sourceMappingURL=vendors-node_modules_react-native-async-storage_async-storage_src_index_ts.chunk.bundle.map?platform=android/* RCSSB */eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJoYXNoIjoiMjUyYWY5MDRmYWI0YjI1NmJlMjNhOTY4YTI5ODJjMGE0YjdhNTRiYzhlZjkxODdkNjYzODViMTQ5NjMwYjg5NiIsImlhdCI6MTc0ODg0NzM0M30.s9MQ00sGtne0XjvwpPkPUFpXgKzeqc92ctSWLPeXsvP3JmAuhHajuNnjxQcB9YdMGOkg4B07HRD1eQxtJj8onERsnWtOHoRu5mh8prxjN38LuorTAic5pM_Esh3XBF45kR-eRlC2PgWUAHNS3vs9nJA1aDX7Hq-jHgi5m_6YdVeK1SR0vYqlRshjl8Kw2RAcS0ex4ODWqimaAxlbzP9Mq8gYpmtcyiNXPcTyR1s9bSxhgysf6XHYxn5M3EMvhwdkx9fXeES5tDKMkCGNfsit08n7fPGg_u5NEjis_ZUJCrRnJrtf7FaaJiXjn-D3evKG6dbL-s8xmMPf3kcLS8tMSg                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              