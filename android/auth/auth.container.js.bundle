/******/ var self = self || this || new Function("return this")() || ({}); // repackGlobal'
/******/
(function() { // webpackBootstrap
var __webpack_modules__ = ({
12347: (function (__unused_webpack_module, exports) {
"use strict";

function _set_prototype_of(o, p) {
    exports._ = _set_prototype_of = Object.setPrototypeOf || function setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _set_prototype_of(o, p);
}
exports._ = _set_prototype_of;


}),
12423: (function (module, exports, __webpack_require__) {
"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _type_of = __webpack_require__(29936);
var R = (typeof Reflect === "undefined" ? "undefined" : _type_of._(Reflect)) === 'object' ? Reflect : null;
var ReflectApply = R && typeof R.apply === 'function' ? R.apply : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
};
var ReflectOwnKeys;
if (R && typeof R.ownKeys === 'function') {
    ReflectOwnKeys = R.ownKeys;
} else if (Object.getOwnPropertySymbols) {
    ReflectOwnKeys = function ReflectOwnKeys(target) {
        return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
    };
} else {
    ReflectOwnKeys = function ReflectOwnKeys(target) {
        return Object.getOwnPropertyNames(target);
    };
}
function ProcessEmitWarning(warning) {
    if (console && console.warn) console.warn(warning);
}
var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
    return value !== value;
};
function EventEmitter() {
    EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;
// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;
// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;
function checkListener(listener) {
    if (typeof listener !== 'function') {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + (typeof listener === "undefined" ? "undefined" : _type_of._(listener)));
    }
}
Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
    enumerable: true,
    get: function get() {
        return defaultMaxListeners;
    },
    set: function set(arg) {
        if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
            throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
        }
        defaultMaxListeners = arg;
    }
});
EventEmitter.init = function() {
    if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {
        this._events = Object.create(null);
        this._eventsCount = 0;
    }
    this._maxListeners = this._maxListeners || undefined;
};
// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
    if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
    }
    this._maxListeners = n;
    return this;
};
function _getMaxListeners(that) {
    if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;
    return that._maxListeners;
}
EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
    return _getMaxListeners(this);
};
EventEmitter.prototype.emit = function emit(type) {
    var args = [];
    for(var i = 1; i < arguments.length; i++)args.push(arguments[i]);
    var doError = type === 'error';
    var events = this._events;
    if (events !== undefined) doError = doError && events.error === undefined;
    else if (!doError) return false;
    // If there is no 'error' event listener then throw.
    if (doError) {
        var er;
        if (args.length > 0) er = args[0];
        if (er instanceof Error) {
            // Note: The comments on the `throw` lines are intentional, they show
            // up in Node's output if this results in an unhandled exception.
            throw er; // Unhandled 'error' event
        }
        // At least give some kind of context to the user
        var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
        err.context = er;
        throw err; // Unhandled 'error' event
    }
    var handler = events[type];
    if (handler === undefined) return false;
    if (typeof handler === 'function') {
        ReflectApply(handler, this, args);
    } else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for(var i = 0; i < len; ++i)ReflectApply(listeners[i], this, args);
    }
    return true;
};
function _addListener(target, type, listener, prepend) {
    var m;
    var events;
    var existing;
    checkListener(listener);
    events = target._events;
    if (events === undefined) {
        events = target._events = Object.create(null);
        target._eventsCount = 0;
    } else {
        // To avoid recursion in the case that type === "newListener"! Before
        // adding it to the listeners, first emit "newListener".
        if (events.newListener !== undefined) {
            target.emit('newListener', type, listener.listener ? listener.listener : listener);
            // Re-assign `events` because a newListener handler could have caused the
            // this._events to be assigned to a new object
            events = target._events;
        }
        existing = events[type];
    }
    if (existing === undefined) {
        // Optimize the case of one listener. Don't need the extra array object.
        existing = events[type] = listener;
        ++target._eventsCount;
    } else {
        if (typeof existing === 'function') {
            // Adding the second element, need to change to array.
            existing = events[type] = prepend ? [
                listener,
                existing
            ] : [
                existing,
                listener
            ];
        // If we've already got an array, just append.
        } else if (prepend) {
            existing.unshift(listener);
        } else {
            existing.push(listener);
        }
        // Check for listener leak
        m = _getMaxListeners(target);
        if (m > 0 && existing.length > m && !existing.warned) {
            existing.warned = true;
            // No error code for this since it is a Warning
            // eslint-disable-next-line no-restricted-syntax
            var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');
            w.name = 'MaxListenersExceededWarning';
            w.emitter = target;
            w.type = type;
            w.count = existing.length;
            ProcessEmitWarning(w);
        }
    }
    return target;
}
EventEmitter.prototype.addListener = function addListener(type, listener) {
    return _addListener(this, type, listener, false);
};
EventEmitter.prototype.on = EventEmitter.prototype.addListener;
EventEmitter.prototype.prependListener = function prependListener(type, listener) {
    return _addListener(this, type, listener, true);
};
function onceWrapper() {
    if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0) return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
    }
}
function _onceWrap(target, type, listener) {
    var state = {
        fired: false,
        wrapFn: undefined,
        target: target,
        type: type,
        listener: listener
    };
    var wrapped = onceWrapper.bind(state);
    wrapped.listener = listener;
    state.wrapFn = wrapped;
    return wrapped;
}
EventEmitter.prototype.once = function once(type, listener) {
    checkListener(listener);
    this.on(type, _onceWrap(this, type, listener));
    return this;
};
EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
    checkListener(listener);
    this.prependListener(type, _onceWrap(this, type, listener));
    return this;
};
// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener = function removeListener(type, listener) {
    var list, events, position, i, originalListener;
    checkListener(listener);
    events = this._events;
    if (events === undefined) return this;
    list = events[type];
    if (list === undefined) return this;
    if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0) this._events = Object.create(null);
        else {
            delete events[type];
            if (events.removeListener) this.emit('removeListener', type, list.listener || listener);
        }
    } else if (typeof list !== 'function') {
        position = -1;
        for(i = list.length - 1; i >= 0; i--){
            if (list[i] === listener || list[i].listener === listener) {
                originalListener = list[i].listener;
                position = i;
                break;
            }
        }
        if (position < 0) return this;
        if (position === 0) list.shift();
        else {
            spliceOne(list, position);
        }
        if (list.length === 1) events[type] = list[0];
        if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);
    }
    return this;
};
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
    var listeners, events, i;
    events = this._events;
    if (events === undefined) return this;
    // not listening for removeListener, no need to emit
    if (events.removeListener === undefined) {
        if (arguments.length === 0) {
            this._events = Object.create(null);
            this._eventsCount = 0;
        } else if (events[type] !== undefined) {
            if (--this._eventsCount === 0) this._events = Object.create(null);
            else delete events[type];
        }
        return this;
    }
    // emit removeListener for all listeners on all events
    if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for(i = 0; i < keys.length; ++i){
            key = keys[i];
            if (key === 'removeListener') continue;
            this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
    }
    listeners = events[type];
    if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
    } else if (listeners !== undefined) {
        // LIFO order
        for(i = listeners.length - 1; i >= 0; i--){
            this.removeListener(type, listeners[i]);
        }
    }
    return this;
};
function _listeners(target, type, unwrap) {
    var events = target._events;
    if (events === undefined) return [];
    var evlistener = events[type];
    if (evlistener === undefined) return [];
    if (typeof evlistener === 'function') return unwrap ? [
        evlistener.listener || evlistener
    ] : [
        evlistener
    ];
    return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}
EventEmitter.prototype.listeners = function listeners(type) {
    return _listeners(this, type, true);
};
EventEmitter.prototype.rawListeners = function rawListeners(type) {
    return _listeners(this, type, false);
};
EventEmitter.listenerCount = function(emitter, type) {
    if (typeof emitter.listenerCount === 'function') {
        return emitter.listenerCount(type);
    } else {
        return listenerCount.call(emitter, type);
    }
};
EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
    var events = this._events;
    if (events !== undefined) {
        var evlistener = events[type];
        if (typeof evlistener === 'function') {
            return 1;
        } else if (evlistener !== undefined) {
            return evlistener.length;
        }
    }
    return 0;
}
EventEmitter.prototype.eventNames = function eventNames() {
    return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};
function arrayClone(arr, n) {
    var copy = new Array(n);
    for(var i = 0; i < n; ++i)copy[i] = arr[i];
    return copy;
}
function spliceOne(list, index) {
    for(; index + 1 < list.length; index++)list[index] = list[index + 1];
    list.pop();
}
function unwrapListeners(arr) {
    var ret = new Array(arr.length);
    for(var i = 0; i < ret.length; ++i){
        ret[i] = arr[i].listener || arr[i];
    }
    return ret;
}
function once(emitter, name) {
    return new Promise(function(resolve, reject) {
        function errorListener(err) {
            emitter.removeListener(name, resolver);
            reject(err);
        }
        function resolver() {
            if (typeof emitter.removeListener === 'function') {
                emitter.removeListener('error', errorListener);
            }
            resolve([].slice.call(arguments));
        }
        ;
        eventTargetAgnosticAddListener(emitter, name, resolver, {
            once: true
        });
        if (name !== 'error') {
            addErrorHandlerIfEventEmitter(emitter, errorListener, {
                once: true
            });
        }
    });
}
function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
    if (typeof emitter.on === 'function') {
        eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
    }
}
function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
    if (typeof emitter.on === 'function') {
        if (flags.once) {
            emitter.once(name, listener);
        } else {
            emitter.on(name, listener);
        }
    } else if (typeof emitter.addEventListener === 'function') {
        // EventTarget does not have `error` event semantics like Node
        // EventEmitters, we do not listen for `error` events here.
        emitter.addEventListener(name, function wrapListener(arg) {
            // IE does not have builtin `{ once: true }` support so we
            // have to do it manually.
            if (flags.once) {
                emitter.removeEventListener(name, wrapListener);
            }
            listener(arg);
        });
    } else {
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + (typeof emitter === "undefined" ? "undefined" : _type_of._(emitter)));
    }
}


}),
1259: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

var _array_with_holes = __webpack_require__(52289);
var _iterable_to_array = __webpack_require__(73620);
var _non_iterable_rest = __webpack_require__(99741);
var _unsupported_iterable_to_array = __webpack_require__(74593);
function _to_array(arr) {
    return _array_with_holes._(arr) || _iterable_to_array._(arr) || _unsupported_iterable_to_array._(arr) || _non_iterable_rest._();
}
exports._ = _to_array;


}),
16972: (function (__unused_webpack_module, exports, __webpack_require__) {
/**
 * Get Webpack runtime context form current JavaScript scope.
 *
 * __You likely don't need to use it.__
 */ Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "getWebpackContext", ({
    enumerable: true,
    get: function() {
        return getWebpackContext;
    }
}));
function getWebpackContext() {
    return __webpack_require__;
} //# sourceMappingURL=getWebpackContext.js.map


}),
19510: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "Federated", ({
    enumerable: true,
    get: function() {
        return _federated.Federated;
    }
}));
var _export_star = __webpack_require__(30478);
_export_star._(__webpack_require__(69479), exports);
_export_star._(__webpack_require__(38837), exports);
_export_star._(__webpack_require__(94171), exports);
_export_star._(__webpack_require__(16972), exports);
var _federated = __webpack_require__(37011);
 //# sourceMappingURL=index.js.map


}),
21193: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

var _array_with_holes = __webpack_require__(52289);
var _iterable_to_array_limit = __webpack_require__(53986);
var _non_iterable_rest = __webpack_require__(99741);
var _unsupported_iterable_to_array = __webpack_require__(74593);
function _sliced_to_array(arr, i) {
    return _array_with_holes._(arr) || _iterable_to_array_limit._(arr, i) || _unsupported_iterable_to_array._(arr, i) || _non_iterable_rest._();
}
exports._ = _sliced_to_array;


}),
21633: (function (module, exports, __webpack_require__) {
/* module decorator */ module = __webpack_require__.nmd(module);
/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */ /* global global, define, Symbol, Reflect, Promise, SuppressedError, Iterator */ Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _type_of = __webpack_require__(29936);
var __extends;
var __assign;
var __rest;
var __decorate;
var __param;
var __esDecorate;
var __runInitializers;
var __propKey;
var __setFunctionName;
var __metadata;
var __awaiter;
var __generator;
var __exportStar;
var __values;
var __read;
var __spread;
var __spreadArrays;
var __spreadArray;
var __await;
var __asyncGenerator;
var __asyncDelegator;
var __asyncValues;
var __makeTemplateObject;
var __importStar;
var __importDefault;
var __classPrivateFieldGet;
var __classPrivateFieldSet;
var __classPrivateFieldIn;
var __createBinding;
var __addDisposableResource;
var __disposeResources;
var __rewriteRelativeImportExtension;
(function(factory) {
    var root = (typeof __webpack_require__.g === "undefined" ? "undefined" : _type_of._(__webpack_require__.g)) === "object" ? __webpack_require__.g : (typeof self === "undefined" ? "undefined" : _type_of._(self)) === "object" ? self : _type_of._(this) === "object" ? this : {};
    if (typeof define === "function" && define.amd) {
        define("tslib", [
            "exports"
        ], function(exports1) {
            factory(createExporter(root, createExporter(exports1)));
        });
    } else if (( false ? 0 : _type_of._(module)) === "object" && _type_of._(module.exports) === "object") {
        factory(createExporter(root, createExporter(module.exports)));
    } else {
        factory(createExporter(root));
    }
    function createExporter(exports1, previous) {
        if (exports1 !== root) {
            if (typeof Object.create === "function") {
                Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
            } else {
                exports1.__esModule = true;
            }
        }
        return function(id, v) {
            return exports1[id] = previous ? previous(id, v) : v;
        };
    }
})(function(exporter) {
    var extendStatics = Object.setPrototypeOf || ({
        __proto__: []
    }) instanceof Array && function(d, b) {
        d.__proto__ = b;
    } || function(d, b) {
        for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };
    __extends = function __extends(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    __assign = Object.assign || function(t) {
        for(var s, i = 1, n = arguments.length; i < n; i++){
            s = arguments[i];
            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    __rest = function __rest(s, e) {
        var t = {};
        for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
        }
        return t;
    };
    __decorate = function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if ((typeof Reflect === "undefined" ? "undefined" : _type_of._(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param = function __param(paramIndex, decorator) {
        return function(target, key) {
            decorator(target, key, paramIndex);
        };
    };
    __esDecorate = function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
        function accept(f) {
            if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
            return f;
        }
        var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
        var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
        var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
        var _, done = false;
        for(var i = decorators.length - 1; i >= 0; i--){
            var context = {};
            for(var p in contextIn)context[p] = p === "access" ? {} : contextIn[p];
            for(var p in contextIn.access)context.access[p] = contextIn.access[p];
            context.addInitializer = function(f) {
                if (done) throw new TypeError("Cannot add initializers after decoration has completed");
                extraInitializers.push(accept(f || null));
            };
            var result = (0, decorators[i])(kind === "accessor" ? {
                get: descriptor.get,
                set: descriptor.set
            } : descriptor[key], context);
            if (kind === "accessor") {
                if (result === void 0) continue;
                if (result === null || (typeof result === "undefined" ? "undefined" : _type_of._(result)) !== "object") throw new TypeError("Object expected");
                if (_ = accept(result.get)) descriptor.get = _;
                if (_ = accept(result.set)) descriptor.set = _;
                if (_ = accept(result.init)) initializers.unshift(_);
            } else if (_ = accept(result)) {
                if (kind === "field") initializers.unshift(_);
                else descriptor[key] = _;
            }
        }
        if (target) Object.defineProperty(target, contextIn.name, descriptor);
        done = true;
    };
    __runInitializers = function __runInitializers(thisArg, initializers, value) {
        var useValue = arguments.length > 2;
        for(var i = 0; i < initializers.length; i++){
            value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
        }
        return useValue ? value : void 0;
    };
    __propKey = function __propKey(x) {
        return (typeof x === "undefined" ? "undefined" : _type_of._(x)) === "symbol" ? x : "".concat(x);
    };
    __setFunctionName = function __setFunctionName(f, name, prefix) {
        if ((typeof name === "undefined" ? "undefined" : _type_of._(name)) === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
        return Object.defineProperty(f, "name", {
            configurable: true,
            value: prefix ? "".concat(prefix, " ", name) : name
        });
    };
    __metadata = function __metadata(metadataKey, metadataValue) {
        if ((typeof Reflect === "undefined" ? "undefined" : _type_of._(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    };
    __awaiter = function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) {
            return value instanceof P ? value : new P(function(resolve) {
                resolve(value);
            });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
            function fulfilled(value) {
                try {
                    step(generator.next(value));
                } catch (e) {
                    reject(e);
                }
            }
            function rejected(value) {
                try {
                    step(generator["throw"](value));
                } catch (e) {
                    reject(e);
                }
            }
            function step(result) {
                result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    __generator = function __generator(thisArg, body) {
        var _ = {
            label: 0,
            sent: function sent() {
                if (t[0] & 1) throw t[1];
                return t[1];
            },
            trys: [],
            ops: []
        }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
        return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
            return this;
        }), g;
        function verb(n) {
            return function(v) {
                return step([
                    n,
                    v
                ]);
            };
        }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while(g && (g = 0, op[0] && (_ = 0)), _)try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [
                    op[0] & 2,
                    t.value
                ];
                switch(op[0]){
                    case 0:
                    case 1:
                        t = op;
                        break;
                    case 4:
                        _.label++;
                        return {
                            value: op[1],
                            done: false
                        };
                    case 5:
                        _.label++;
                        y = op[1];
                        op = [
                            0
                        ];
                        continue;
                    case 7:
                        op = _.ops.pop();
                        _.trys.pop();
                        continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                            _ = 0;
                            continue;
                        }
                        if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                            _.label = op[1];
                            break;
                        }
                        if (op[0] === 6 && _.label < t[1]) {
                            _.label = t[1];
                            t = op;
                            break;
                        }
                        if (t && _.label < t[2]) {
                            _.label = t[2];
                            _.ops.push(op);
                            break;
                        }
                        if (t[2]) _.ops.pop();
                        _.trys.pop();
                        continue;
                }
                op = body.call(thisArg, _);
            } catch (e) {
                op = [
                    6,
                    e
                ];
                y = 0;
            } finally{
                f = t = 0;
            }
            if (op[0] & 5) throw op[1];
            return {
                value: op[0] ? op[1] : void 0,
                done: true
            };
        }
    };
    __exportStar = function __exportStar(m, o) {
        for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
    };
    __createBinding = Object.create ? function __createBinding(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
            desc = {
                enumerable: true,
                get: function get() {
                    return m[k];
                }
            };
        }
        Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    };
    __values = function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function next() {
                if (o && i >= o.length) o = void 0;
                return {
                    value: o && o[i++],
                    done: !o
                };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    __read = function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
        } catch (error) {
            e = {
                error: error
            };
        } finally{
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            } finally{
                if (e) throw e.error;
            }
        }
        return ar;
    };
    /** @deprecated */ __spread = function __spread() {
        for(var ar = [], i = 0; i < arguments.length; i++)ar = ar.concat(__read(arguments[i]));
        return ar;
    };
    /** @deprecated */ __spreadArrays = function __spreadArrays() {
        for(var s = 0, i = 0, il = arguments.length; i < il; i++)s += arguments[i].length;
        for(var r = Array(s), k = 0, i = 0; i < il; i++)for(var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)r[k] = a[j];
        return r;
    };
    __spreadArray = function __spreadArray(to, from, pack) {
        if (pack || arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
    };
    __await = function(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    };
    __asyncGenerator = function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
            return this;
        }, i;
        function awaitReturn(f) {
            return function(v) {
                return Promise.resolve(v).then(f, reject);
            };
        }
        function verb(n, f) {
            if (g[n]) {
                i[n] = function(v) {
                    return new Promise(function(a, b) {
                        q.push([
                            n,
                            v,
                            a,
                            b
                        ]) > 1 || resume(n, v);
                    });
                };
                if (f) i[n] = f(i[n]);
            }
        }
        function resume(n, v) {
            try {
                step(g[n](v));
            } catch (e) {
                settle(q[0][3], e);
            }
        }
        function step(r) {
            r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
        }
        function fulfill(value) {
            resume("next", value);
        }
        function reject(value) {
            resume("throw", value);
        }
        function settle(f, v) {
            if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
        }
    };
    __asyncDelegator = function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function(e) {
            throw e;
        }), verb("return"), i[Symbol.iterator] = function() {
            return this;
        }, i;
        function verb(n, f) {
            i[n] = o[n] ? function(v) {
                return (p = !p) ? {
                    value: __await(o[n](v)),
                    done: false
                } : f ? f(v) : v;
            } : f;
        }
    };
    __asyncValues = function __asyncValues(o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
        }, i);
        function verb(n) {
            i[n] = o[n] && function(v) {
                return new Promise(function(resolve, reject) {
                    v = o[n](v), settle(resolve, reject, v.done, v.value);
                });
            };
        }
        function settle(resolve, reject, d, v) {
            Promise.resolve(v).then(function(v) {
                resolve({
                    value: v,
                    done: d
                });
            }, reject);
        }
    };
    __makeTemplateObject = function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", {
                value: raw
            });
        } else {
            cooked.raw = raw;
        }
        return cooked;
    };
    var __setModuleDefault = Object.create ? function __setModuleDefault(o, v) {
        Object.defineProperty(o, "default", {
            enumerable: true,
            value: v
        });
    } : function(o, v) {
        o["default"] = v;
    };
    var ownKeys = function ownKeys1(o) {
        ownKeys = Object.getOwnPropertyNames || function(o) {
            var ar = [];
            for(var k in o)if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    __importStar = function __importStar(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
            for(var k = ownKeys(mod), i = 0; i < k.length; i++)if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
    };
    __importDefault = function __importDefault(mod) {
        return mod && mod.__esModule ? mod : {
            "default": mod
        };
    };
    __classPrivateFieldGet = function __classPrivateFieldGet(receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    __classPrivateFieldSet = function __classPrivateFieldSet(receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    __classPrivateFieldIn = function __classPrivateFieldIn(state, receiver) {
        if (receiver === null || (typeof receiver === "undefined" ? "undefined" : _type_of._(receiver)) !== "object" && typeof receiver !== "function") throw new TypeError("Cannot use 'in' operator on non-object");
        return typeof state === "function" ? receiver === state : state.has(receiver);
    };
    __addDisposableResource = function __addDisposableResource(env, value, async) {
        if (value !== null && value !== void 0) {
            if ((typeof value === "undefined" ? "undefined" : _type_of._(value)) !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
            var dispose, inner;
            if (async) {
                if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
                dispose = value[Symbol.asyncDispose];
            }
            if (dispose === void 0) {
                if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
                dispose = value[Symbol.dispose];
                if (async) inner = dispose;
            }
            if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
            if (inner) dispose = function dispose() {
                try {
                    inner.call(this);
                } catch (e) {
                    return Promise.reject(e);
                }
            };
            env.stack.push({
                value: value,
                dispose: dispose,
                async: async
            });
        } else if (async) {
            env.stack.push({
                async: true
            });
        }
        return value;
    };
    var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function _SuppressedError(error, suppressed, message) {
        var e = new Error(message);
        return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    };
    __disposeResources = function __disposeResources(env) {
        function fail(e) {
            env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
            env.hasError = true;
        }
        var r, s = 0;
        function next() {
            while(r = env.stack.pop()){
                try {
                    if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
                    if (r.dispose) {
                        var result = r.dispose.call(r.value);
                        if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {
                            fail(e);
                            return next();
                        });
                    } else s |= 1;
                } catch (e) {
                    fail(e);
                }
            }
            if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
            if (env.hasError) throw env.error;
        }
        return next();
    };
    __rewriteRelativeImportExtension = function __rewriteRelativeImportExtension(path, preserveJsx) {
        if (typeof path === "string" && /^\.\.?\//.test(path)) {
            return path.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function(m, tsx, d, ext, cm) {
                return tsx ? preserveJsx ? ".jsx" : ".js" : d && (!ext || !cm) ? m : d + ext + "." + cm.toLowerCase() + "js";
            });
        }
        return path;
    };
    exporter("__extends", __extends);
    exporter("__assign", __assign);
    exporter("__rest", __rest);
    exporter("__decorate", __decorate);
    exporter("__param", __param);
    exporter("__esDecorate", __esDecorate);
    exporter("__runInitializers", __runInitializers);
    exporter("__propKey", __propKey);
    exporter("__setFunctionName", __setFunctionName);
    exporter("__metadata", __metadata);
    exporter("__awaiter", __awaiter);
    exporter("__generator", __generator);
    exporter("__exportStar", __exportStar);
    exporter("__createBinding", __createBinding);
    exporter("__values", __values);
    exporter("__read", __read);
    exporter("__spread", __spread);
    exporter("__spreadArrays", __spreadArrays);
    exporter("__spreadArray", __spreadArray);
    exporter("__await", __await);
    exporter("__asyncGenerator", __asyncGenerator);
    exporter("__asyncDelegator", __asyncDelegator);
    exporter("__asyncValues", __asyncValues);
    exporter("__makeTemplateObject", __makeTemplateObject);
    exporter("__importStar", __importStar);
    exporter("__importDefault", __importDefault);
    exporter("__classPrivateFieldGet", __classPrivateFieldGet);
    exporter("__classPrivateFieldSet", __classPrivateFieldSet);
    exporter("__classPrivateFieldIn", __classPrivateFieldIn);
    exporter("__addDisposableResource", __addDisposableResource);
    exporter("__disposeResources", __disposeResources);
    exporter("__rewriteRelativeImportExtension", __rewriteRelativeImportExtension);
});
0 && 0;


}),
29936: (function (__unused_webpack_module, exports) {
"use strict";

function _type_of(obj) {
    "@swc/helpers - typeof";
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
exports._ = _type_of;


}),
30478: (function (__unused_webpack_module, exports) {
"use strict";

function _export_star(from, to) {
    Object.keys(from).forEach(function(k) {
        if (k !== "default" && !Object.prototype.hasOwnProperty.call(to, k)) {
            Object.defineProperty(to, k, {
                enumerable: true,
                get: function get() {
                    return from[k];
                }
            });
        }
    });
    return from;
}
exports._ = _export_star;


}),
37011: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "Federated", ({
    enumerable: true,
    get: function() {
        return Federated;
    }
}));
var _async_to_generator = __webpack_require__(37297);
var _ts_generator = __webpack_require__(63563);
var _ScriptManager = __webpack_require__(69479);
var Federated;
(function(_Federated) {
    /**
   * @deprecated
   *
   * Resolves URL to a container or a chunk when using Module Federation,
   * based on given `scriptId` and `caller`.
   */ /**
   * @deprecated
   *
   * Configuration options for {@link createURLResolver} for Module Federation.
   * Allows to configure how created {@link URLResolver} will behave.
   */ /**
   * @deprecated
   *
   * Creates URL resolver for Module Federation from provided config.
   *
   * @example
   * ```ts
   * import { ScriptManager, Script, Federated } from '@callstack/repack/client';
   *
   * const resolveURL = Federated.createURLResolver({
   *   containers: {
   *     app1: 'http://localhost:9001/[name][ext]',
   *     app2: 'http://localhost:9002/[name].container.js',
   *   },
   *   chunks: {
   *     app2: 'http://localhost:9002/chunks/[name][ext]',
   *   },
   * });
   *
   * ScriptManager.shared.addResolver(async (scriptId, caller) => {
   *   let url;
   *   if (caller === 'main') {
   *     url = __DEV__
   *       ? Script.getDevServerURL(scriptId)
   *       : Script.getRemoteURL(`http://localhost:9000/${scriptId}`);
   *   } else {
   *     url = resolveURL(scriptId, caller);
   *   }
   *
   *   if (!url) {
   *     return undefined;
   *   }
   *
   *   return {
   *     url,
   *     query: {
   *       platform: Platform.OS,
   *     },
   *   };
   * });
   * ```
   *
   * `createURLResolver` is a abstraction over {@link Script.getRemoteURL},
   * for example:
   * ```ts
   * import { ScriptManager, Federated } from '@callstack/repack/client';
   *
   * ScriptManager.shared.addResolver((scriptId, caller) => {
   *   const resolveURL = Federated.createURLResolver({
   *     containers: {
   *       app1: 'http://localhost:9000/[name][ext]',
   *     },
   *   });
   *
   *   return {
   *     url: resolveURL(scriptId, caller);
   *   };
   * });
   * ```
   * is equivalent to:
   * ```ts
   * import { ScriptManager, Script } from '@callstack/repack/client';
   *
   * ScriptManager.shared.addResolver(async (scriptId, caller) => {
   *   if (scriptId === 'app1') {
   *     return {
   *       url: 'http://localhost:9000/app1.container.bundle',
   *     };
   *   }
   *
   *   if (caller === 'app1') {
   *     return {
   *       url: Script.getRemoteURL(`http://localhost:9000/${scriptId}`),
   *     };
   *   }
   * });
   * ```
   *
   * @param config Configuration for the resolver.
   * @returns A resolver function which will try to resolve URL based on given `scriptId` and `caller`.
   */ function createURLResolver(config) {
        var _loop = function(key) {
            resolvers[key] = function(scriptId, caller) {
                if (scriptId === key) {
                    var url = config.containers[key].replace(/\[name\]/g, scriptId).replace(/\[ext\]/g, '.container.bundle');
                    return url;
                }
                if (caller === key) {
                    var _config_chunks;
                    var _config_chunks_key;
                    var url1 = ((_config_chunks_key = (_config_chunks = config.chunks) == null ? void 0 : _config_chunks[key]) != null ? _config_chunks_key : config.containers[key]).replace(/\[name\]/g, scriptId);
                    if (url1.includes('[ext]')) {
                        return function(webpackContext) {
                            return webpackContext.u(url1.replace(/\[ext\]/g, ''));
                        };
                    }
                    return url1;
                }
                return undefined;
            };
        };
        var resolvers = {};
        for(var key in config.containers)_loop(key);
        return function(scriptId, caller) {
            var _ref;
            var resolver = (_ref = caller ? resolvers[caller] : undefined) != null ? _ref : resolvers[scriptId];
            return resolver(scriptId, caller);
        };
    }
    _Federated.createURLResolver = createURLResolver;
    /**
   * @deprecated
   *
   * Dynamically imports module from a Module Federation container. Similar to `import('file')`, but
   * specific to Module Federation. Calling `importModule` will create an async boundary.
   *
   * Container will be evaluated only once. If you use `importModule` for the same container twice,
   * the container will be loaded and evaluated only on the first import.
   *
   * Under the hood, `importModule` will call `ScriptManager.shared.loadScript(containerName)`.
   * This means, a resolver must be added with `ScriptManager.shared.addResolver(...)` beforehand and provided proper
   * resolution logic to resolve URL based on the `containerName`.
   *
   * @param containerName Name of the container - should be the same name provided to
   * `webpack.container.ModuleFederationPlugin` in `library.name`.
   * @param module Full name with extension of the module to import from the container - only modules
   * exposed in `exposes` in `webpack.container.ModuleFederationPlugin` can be used.
   * @param scope Optional, scope for sharing modules between containers. Defaults to `'default'`.
   * @returns Exports of given `module` from given container.
   *
   * @example
   * ```ts
   * import * as React from 'react';
   * import { Federated } from '@callstack/repack/client';
   *
   * const Button = React.lazy(() => Federated.importModule('my-components', './Button.js'));
   *
   * const myUtil = await Federated.importModule('my-lib', './myUtil.js');
   * ```
   */ function importModule(containerName, module, scope) {
        if (scope === void 0) scope = 'default';
        return _async_to_generator._(function() {
            var __webpack_share_scopes___scope, container, factory, exports1;
            return _ts_generator._(this, function(_state) {
                switch(_state.label){
                    case 0:
                        if (!!((__webpack_share_scopes___scope = __webpack_require__.S[scope]) == null ? void 0 : __webpack_share_scopes___scope.__isInitialized)) return [
                            3,
                            2
                        ];
                        // Initializes the share scope.
                        // This fills it with known provided modules from this build and all remotes.
                        return [
                            4,
                            __webpack_require__.I(scope)
                        ];
                    case 1:
                        _state.sent();
                        __webpack_require__.S[scope].__isInitialized = true;
                        _state.label = 2;
                    case 2:
                        if (!!self[containerName]) return [
                            3,
                            4
                        ];
                        // Download and execute container
                        return [
                            4,
                            _ScriptManager.ScriptManager.shared.loadScript(containerName)
                        ];
                    case 3:
                        _state.sent();
                        _state.label = 4;
                    case 4:
                        container = self[containerName];
                        if (!!container.__isInitialized) return [
                            3,
                            6
                        ];
                        container.__isInitialized = true;
                        // Initialize the container, it may provide shared modules
                        return [
                            4,
                            container.init(__webpack_require__.S[scope])
                        ];
                    case 5:
                        _state.sent();
                        _state.label = 6;
                    case 6:
                        return [
                            4,
                            container.get(module)
                        ];
                    case 7:
                        factory = _state.sent();
                        exports1 = factory();
                        return [
                            2,
                            exports1
                        ];
                }
            });
        })();
    }
    _Federated.importModule = importModule;
})(Federated || (Federated = {})); //# sourceMappingURL=federated.js.map


}),
37297: (function (__unused_webpack_module, exports) {
"use strict";

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        var info = gen[key](arg);
        var value = info.value;
    } catch (error) {
        reject(error);
        return;
    }
    if (info.done) resolve(value);
    else Promise.resolve(value).then(_next, _throw);
}
function _async_to_generator(fn) {
    return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve, reject) {
            var gen = fn.apply(self, args);
            function _next(value) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(undefined);
        });
    };
}
exports._ = _async_to_generator;


}),
38504: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _type_of = __webpack_require__(29936);
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) return obj;
    if (obj === null || (typeof obj === "undefined" ? "undefined" : _type_of._(obj)) !== "object" && typeof obj !== "function") return {
        "default": obj
    };
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) return cache.get(obj);
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) Object.defineProperty(newObj, key, desc);
            else newObj[key] = obj[key];
        }
    }
    newObj["default"] = obj;
    if (cache) cache.set(obj, newObj);
    return newObj;
}
exports._ = _interop_require_wildcard;


}),
38837: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "Script", ({
    enumerable: true,
    get: function() {
        return Script;
    }
}));
var _interop_require_default = __webpack_require__(48810);
var _shallowequal = /*#__PURE__*/ _interop_require_default._(__webpack_require__(93312));
var _NativeScriptManager = __webpack_require__(55581);
var Script = /*#__PURE__*/ function() {
    "use strict";
    function Script(scriptId, caller, locator, cache) {
        if (cache === void 0) cache = true;
        this.scriptId = scriptId;
        this.caller = caller;
        this.locator = locator;
        this.cache = cache;
    }
    var _proto = Script.prototype;
    /**
   * Check if the script was already cached and cache should be updated with new data.
   *
   * @param cachedData Cached data for the same script.
   *
   * @internal
   */ _proto.shouldUpdateCache = function shouldUpdateCache(cachedData) {
        if (!this.cache || !cachedData) {
            return false;
        }
        return this.checkIfCacheDataOutdated(cachedData);
    };
    /**
   * Check if the script should be fetched again or reused,
   * based on previous cached data.
   *
   * @param cachedData Cached data for the same script.
   *
   * @internal
   */ _proto.shouldRefetch = function shouldRefetch(cachedData) {
        if (!this.cache) {
            return true;
        }
        return this.checkIfCacheDataOutdated(cachedData);
    };
    /**
   * Check if previous cached data is the same as the new one.
   *
   * @param cachedData Cached data for the same script.
   *
   * @internal
   */ _proto.checkIfCacheDataOutdated = function checkIfCacheDataOutdated(cachedData) {
        var diffs = [
            cachedData.method !== this.locator.method,
            cachedData.url !== this.locator.url,
            cachedData.query !== this.locator.query,
            !(0, _shallowequal.default)(cachedData.headers, this.locator.headers),
            cachedData.body !== this.locator.body
        ];
        return diffs.some(function(diff) {
            return diff;
        });
    };
    /**
   * Get object to store in cache.
   *
   * @internal
   */ _proto.getCacheData = function getCacheData() {
        return {
            method: this.locator.method,
            url: this.locator.url,
            query: this.locator.query,
            headers: this.locator.headers,
            body: this.locator.body
        };
    };
    _proto.toObject = function toObject() {
        return {
            scriptId: this.scriptId,
            caller: this.caller,
            locator: this.locator,
            cache: this.cache
        };
    };
    /**
   * Get URL of a script hosted on development server.
   *
   * @param scriptId Id of the script.
   */ Script.getDevServerURL = function getDevServerURL(scriptId) {
        return function(webpackContext) {
            return "" + webpackContext.p + webpackContext.u(scriptId);
        };
    };
    /**
   * Get URL of a script stored on filesystem on the target mobile device.
   *
   * @param scriptId Id of the script.
   */ Script.getFileSystemURL = function getFileSystemURL(scriptId) {
        return function(webpackContext) {
            return webpackContext.u("file:///" + scriptId);
        };
    };
    /**
   * Get URL of a script hosted on a remote server.
   *
   * By default `.chunk.bundle` extension will be added to the URL.
   * If your script has different extension, you should pass `{ excludeExtension: true }` as 2nd argument.
   *
   * @param url A URL to remote location where the script is stored.
   * @param options Additional options.
   */ Script.getRemoteURL = function getRemoteURL(url, options) {
        if (options === void 0) options = {};
        if (options.excludeExtension) {
            return url;
        }
        return function(webpackContext) {
            return webpackContext.u(url);
        };
    };
    /**
   * Get unique identifier for the script.
   *
   * Used to create unique identifier for the script, which serves as its key in the cache.
   *
   * @param scriptId Id of the script.
   * @param caller Optional caller name to prefix the script id.
   */ Script.getScriptUniqueId = function getScriptUniqueId(scriptId, caller) {
        var prefix = caller ? caller + '_' : '';
        return prefix + scriptId;
    };
    /**
   * Create new instance of `Script` from non-normalized script locator data.
   *
   * @param locator Non-normalized locator data.
   * @param fetch Initial flag for whether script should be fetched or not.
   *
   * @internal
   */ Script.from = function from(key, locator, fetch) {
        var headers = {};
        new Headers(locator.headers).forEach(function(value, key) {
            headers[key.toLowerCase()] = value;
        });
        var uniqueId = Script.getScriptUniqueId(key.scriptId, key.caller);
        var body;
        if (locator.body instanceof FormData) {
            var bodyObject = {};
            locator.body.forEach(function(value, key) {
                if (typeof value === 'string') {
                    bodyObject[key] = value;
                } else {
                    console.warn('Script does not support File as FormData key in body');
                }
            });
            body = JSON.stringify(bodyObject);
        } else if (locator.body instanceof URLSearchParams) {
            var bodyObject1 = {};
            locator.body.forEach(function(value, key) {
                bodyObject1[key] = value;
            });
            body = JSON.stringify(bodyObject1);
        } else {
            var _locator_body;
            body = (_locator_body = locator.body) != null ? _locator_body : undefined;
        }
        if (typeof locator.url === 'function') {
            throw new Error('Property url as a function is not support');
        }
        var _locator_method, _locator_absolute, _locator_timeout, _locator_verifyScriptSignature;
        return new Script(key.scriptId, key.caller, {
            uniqueId: uniqueId,
            method: (_locator_method = locator.method) != null ? _locator_method : _NativeScriptManager.NormalizedScriptLocatorHTTPMethod.GET,
            url: locator.url,
            absolute: (_locator_absolute = locator.absolute) != null ? _locator_absolute : false,
            timeout: (_locator_timeout = locator.timeout) != null ? _locator_timeout : Script.DEFAULT_TIMEOUT,
            retry: locator.retry,
            retryDelay: locator.retryDelay,
            query: new URLSearchParams(locator.query).toString() || undefined,
            body: body,
            headers: Object.keys(headers).length ? headers : undefined,
            fetch: locator.cache === false ? true : fetch,
            verifyScriptSignature: (_locator_verifyScriptSignature = locator.verifyScriptSignature) != null ? _locator_verifyScriptSignature : _NativeScriptManager.NormalizedScriptLocatorSignatureVerificationMode.OFF
        }, locator.cache);
    };
    return Script;
} //# sourceMappingURL=Script.js.map
();
Script.DEFAULT_TIMEOUT = 30000 // 30s
;


}),
48810: (function (__unused_webpack_module, exports) {
"use strict";

function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    };
}
exports._ = _interop_require_default;


}),
51302: (function (__unused_webpack_module, exports) {
"use strict";

function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _create_class(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
exports._ = _create_class;


}),
51676: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

var _array_like_to_array = __webpack_require__(72216);
function _array_without_holes(arr) {
    if (Array.isArray(arr)) return _array_like_to_array._(arr);
}
exports._ = _array_without_holes;


}),
52109: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

__webpack_require__.d(exports, {
	get: function() { return __webpack_require__.getContainer; },
	init: function() { return __webpack_require__.initContainer; }
});

}),
52289: (function (__unused_webpack_module, exports) {
"use strict";

function _array_with_holes(arr) {
    if (Array.isArray(arr)) return arr;
}
exports._ = _array_with_holes;


}),
52570: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _async_to_generator = __webpack_require__(37297);
var _define_property = __webpack_require__(5303);
var _inherits = __webpack_require__(85428);
var _interop_require_wildcard = __webpack_require__(38504);
var _sliced_to_array = __webpack_require__(21193);
var _to_consumable_array = __webpack_require__(8034);
var _type_of = __webpack_require__(29936);
var _ts_generator = __webpack_require__(63563);
var polyfills = __webpack_require__(75452);
var sdk = __webpack_require__(58506);
var share = __webpack_require__(72884);
// Function to match a remote with its name and expose
// id: pkgName(@federation/app1) + expose(button) = @federation/app1/button
// id: alias(app1) + expose(button) = app1/button
// id: alias(app1/utils) + expose(loadash/sort) = app1/utils/loadash/sort
function matchRemoteWithNameAndExpose(remotes, id) {
    for(var _i = 0; _i < remotes.length; _i++){
        var remote = remotes[_i];
        // match pkgName
        var isNameMatched = id.startsWith(remote.name);
        var expose = id.replace(remote.name, '');
        if (isNameMatched) {
            if (expose.startsWith('/')) {
                var pkgNameOrAlias = remote.name;
                expose = "." + expose;
                return {
                    pkgNameOrAlias: pkgNameOrAlias,
                    expose: expose,
                    remote: remote
                };
            } else if (expose === '') {
                return {
                    pkgNameOrAlias: remote.name,
                    expose: '.',
                    remote: remote
                };
            }
        }
        // match alias
        var isAliasMatched = remote.alias && id.startsWith(remote.alias);
        var exposeWithAlias = remote.alias && id.replace(remote.alias, '');
        if (remote.alias && isAliasMatched) {
            if (exposeWithAlias && exposeWithAlias.startsWith('/')) {
                var pkgNameOrAlias1 = remote.alias;
                exposeWithAlias = "." + exposeWithAlias;
                return {
                    pkgNameOrAlias: pkgNameOrAlias1,
                    expose: exposeWithAlias,
                    remote: remote
                };
            } else if (exposeWithAlias === '') {
                return {
                    pkgNameOrAlias: remote.alias,
                    expose: '.',
                    remote: remote
                };
            }
        }
    }
    return;
}
// Function to match a remote with its name or alias
function matchRemote(remotes, nameOrAlias) {
    for(var _i = 0; _i < remotes.length; _i++){
        var remote = remotes[_i];
        var isNameMatched = nameOrAlias === remote.name;
        if (isNameMatched) {
            return remote;
        }
        var isAliasMatched = remote.alias && nameOrAlias === remote.alias;
        if (isAliasMatched) {
            return remote;
        }
    }
    return;
}
function registerPlugins$1(plugins, hookInstances) {
    var globalPlugins = share.getGlobalHostPlugins();
    // Incorporate global plugins
    if (globalPlugins.length > 0) {
        globalPlugins.forEach(function(plugin) {
            if (plugins == null ? void 0 : plugins.find(function(item) {
                return item.name !== plugin.name;
            })) {
                plugins.push(plugin);
            }
        });
    }
    if (plugins && plugins.length > 0) {
        plugins.forEach(function(plugin) {
            hookInstances.forEach(function(hookInstance) {
                hookInstance.applyPlugin(plugin);
            });
        });
    }
    return plugins;
}
function loadEsmEntry() {
    return _async_to_generator._(function(param) {
        var entry, remoteEntryExports;
        return _ts_generator._(this, function(_state) {
            entry = param.entry, remoteEntryExports = param.remoteEntryExports;
            return [
                2,
                new Promise(function(resolve, reject) {
                    try {
                        if (!remoteEntryExports) {
                            Promise.resolve(/* webpackIgnore: true */ entry).then(function(p) {
                                return /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(83481)(p));
                            }).then(resolve)["catch"](reject);
                        } else {
                            resolve(remoteEntryExports);
                        }
                    } catch (e) {
                        reject(e);
                    }
                })
            ];
        });
    }).apply(this, arguments);
}
function loadSystemJsEntry() {
    return _async_to_generator._(function(param) {
        var entry, remoteEntryExports;
        return _ts_generator._(this, function(_state) {
            entry = param.entry, remoteEntryExports = param.remoteEntryExports;
            return [
                2,
                new Promise(function(resolve, reject) {
                    try {
                        if (!remoteEntryExports) {
                            //@ts-ignore
                            if (false) {} else {
                                new Function('callbacks', 'System.import("' + entry + '").then(callbacks[0]).catch(callbacks[1])')([
                                    resolve,
                                    reject
                                ]);
                            }
                        } else {
                            resolve(remoteEntryExports);
                        }
                    } catch (e) {
                        reject(e);
                    }
                })
            ];
        });
    }).apply(this, arguments);
}
function loadEntryScript() {
    return _async_to_generator._(function(param) {
        var name, globalName, entry, createScriptHook, _share_getRemoteEntryExports, remoteEntryExports;
        return _ts_generator._(this, function(_state) {
            name = param.name, globalName = param.globalName, entry = param.entry, createScriptHook = param.createScriptHook;
            _share_getRemoteEntryExports = share.getRemoteEntryExports(name, globalName), remoteEntryExports = _share_getRemoteEntryExports.entryExports;
            if (remoteEntryExports) {
                return [
                    2,
                    remoteEntryExports
                ];
            }
            return [
                2,
                sdk.loadScript(entry, {
                    attrs: {},
                    createScriptHook: function(url, attrs) {
                        var res = createScriptHook.emit({
                            url: url,
                            attrs: attrs
                        });
                        if (!res) return;
                        if (res instanceof HTMLScriptElement) {
                            return res;
                        }
                        if ('script' in res || 'timeout' in res) {
                            return res;
                        }
                        return;
                    }
                }).then(function() {
                    var _share_getRemoteEntryExports = share.getRemoteEntryExports(name, globalName), remoteEntryKey = _share_getRemoteEntryExports.remoteEntryKey, entryExports = _share_getRemoteEntryExports.entryExports;
                    share.assert(entryExports, "\n      Unable to use the " + name + "'s '" + entry + "' URL with " + remoteEntryKey + "'s globalName to get remoteEntry exports.\n      Possible reasons could be:\n\n      1. '" + entry + "' is not the correct URL, or the remoteEntry resource or name is incorrect.\n\n      2. " + remoteEntryKey + " cannot be used to get remoteEntry exports in the window object.\n    ");
                    return entryExports;
                })["catch"](function(e) {
                    throw e;
                })
            ];
        });
    }).apply(this, arguments);
}
function loadEntryDom() {
    return _async_to_generator._(function(param) {
        var remoteInfo, remoteEntryExports, createScriptHook, entry, globalName, name, type;
        return _ts_generator._(this, function(_state) {
            remoteInfo = param.remoteInfo, remoteEntryExports = param.remoteEntryExports, createScriptHook = param.createScriptHook;
            entry = remoteInfo.entry, globalName = remoteInfo.entryGlobalName, name = remoteInfo.name, type = remoteInfo.type;
            switch(type){
                case 'esm':
                case 'module':
                    return [
                        2,
                        loadEsmEntry({
                            entry: entry,
                            remoteEntryExports: remoteEntryExports
                        })
                    ];
                case 'system':
                    return [
                        2,
                        loadSystemJsEntry({
                            entry: entry,
                            remoteEntryExports: remoteEntryExports
                        })
                    ];
                default:
                    return [
                        2,
                        loadEntryScript({
                            entry: entry,
                            globalName: globalName,
                            name: name,
                            createScriptHook: createScriptHook
                        })
                    ];
            }
            return [
                2
            ];
        });
    }).apply(this, arguments);
}
function loadEntryNode() {
    return _async_to_generator._(function(param) {
        var remoteInfo, createScriptHook, entry, globalName, name, type, _share_getRemoteEntryExports, remoteEntryExports;
        return _ts_generator._(this, function(_state) {
            remoteInfo = param.remoteInfo, createScriptHook = param.createScriptHook;
            entry = remoteInfo.entry, globalName = remoteInfo.entryGlobalName, name = remoteInfo.name, type = remoteInfo.type;
            _share_getRemoteEntryExports = share.getRemoteEntryExports(name, globalName), remoteEntryExports = _share_getRemoteEntryExports.entryExports;
            if (remoteEntryExports) {
                return [
                    2,
                    remoteEntryExports
                ];
            }
            return [
                2,
                sdk.loadScriptNode(entry, {
                    attrs: {
                        name: name,
                        globalName: globalName,
                        type: type
                    },
                    createScriptHook: function(url, attrs) {
                        var res = createScriptHook.emit({
                            url: url,
                            attrs: attrs
                        });
                        if (!res) return;
                        if ('url' in res) {
                            return res;
                        }
                        return;
                    }
                }).then(function() {
                    var _share_getRemoteEntryExports = share.getRemoteEntryExports(name, globalName), remoteEntryKey = _share_getRemoteEntryExports.remoteEntryKey, entryExports = _share_getRemoteEntryExports.entryExports;
                    share.assert(entryExports, "\n      Unable to use the " + name + "'s '" + entry + "' URL with " + remoteEntryKey + "'s globalName to get remoteEntry exports.\n      Possible reasons could be:\n\n      1. '" + entry + "' is not the correct URL, or the remoteEntry resource or name is incorrect.\n\n      2. " + remoteEntryKey + " cannot be used to get remoteEntry exports in the window object.\n    ");
                    return entryExports;
                })["catch"](function(e) {
                    throw e;
                })
            ];
        });
    }).apply(this, arguments);
}
function getRemoteEntryUniqueKey(remoteInfo) {
    var entry = remoteInfo.entry, name = remoteInfo.name;
    return sdk.composeKeyWithSeparator(name, entry);
}
function getRemoteEntry() {
    return _async_to_generator._(function(param) {
        var origin, remoteEntryExports, remoteInfo, uniqueKey, loadEntryHook, createScriptHook;
        return _ts_generator._(this, function(_state) {
            origin = param.origin, remoteEntryExports = param.remoteEntryExports, remoteInfo = param.remoteInfo;
            uniqueKey = getRemoteEntryUniqueKey(remoteInfo);
            if (remoteEntryExports) {
                return [
                    2,
                    remoteEntryExports
                ];
            }
            if (!share.globalLoading[uniqueKey]) {
                loadEntryHook = origin.remoteHandler.hooks.lifecycle.loadEntry;
                createScriptHook = origin.loaderHook.lifecycle.createScript;
                share.globalLoading[uniqueKey] = loadEntryHook.emit({
                    createScriptHook: createScriptHook,
                    remoteInfo: remoteInfo,
                    remoteEntryExports: remoteEntryExports
                }).then(function(res) {
                    if (res) {
                        return res;
                    }
                    return sdk.isBrowserEnv() ? loadEntryDom({
                        remoteInfo: remoteInfo,
                        remoteEntryExports: remoteEntryExports,
                        createScriptHook: createScriptHook
                    }) : loadEntryNode({
                        remoteInfo: remoteInfo,
                        createScriptHook: createScriptHook
                    });
                });
            }
            return [
                2,
                share.globalLoading[uniqueKey]
            ];
        });
    }).apply(this, arguments);
}
function getRemoteInfo(remote) {
    return polyfills._extends({}, remote, {
        entry: 'entry' in remote ? remote.entry : '',
        type: remote.type || share.DEFAULT_REMOTE_TYPE,
        entryGlobalName: remote.entryGlobalName || remote.name,
        shareScope: remote.shareScope || share.DEFAULT_SCOPE
    });
}
var Module = /*#__PURE__*/ function() {
    function Module(param) {
        var remoteInfo = param.remoteInfo, host = param.host;
        this.inited = false;
        this.lib = undefined;
        this.remoteInfo = remoteInfo;
        this.host = host;
    }
    var _proto = Module.prototype;
    _proto.getEntry = function getEntry() {
        return _async_to_generator._(function() {
            var remoteEntryExports;
            return _ts_generator._(this, function(_state) {
                switch(_state.label){
                    case 0:
                        if (this.remoteEntryExports) {
                            return [
                                2,
                                this.remoteEntryExports
                            ];
                        }
                        return [
                            4,
                            getRemoteEntry({
                                origin: this.host,
                                remoteInfo: this.remoteInfo,
                                remoteEntryExports: this.remoteEntryExports
                            })
                        ];
                    case 1:
                        remoteEntryExports = _state.sent();
                        share.assert(remoteEntryExports, "remoteEntryExports is undefined \n " + sdk.safeToString(this.remoteInfo));
                        this.remoteEntryExports = remoteEntryExports;
                        return [
                            2,
                            this.remoteEntryExports
                        ];
                }
            });
        }).call(this);
    };
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    _proto.get = function get(id, expose, options, remoteSnapshot) {
        return _async_to_generator._(function() {
            var _ref, _ref_loadFactory, loadFactory, remoteEntryExports, localShareScopeMap, remoteShareScope, shareScope, initScope, remoteEntryInitOptions, initContainerOptions, moduleFactory, wrapModuleFactory, exposeContent;
            return _ts_generator._(this, function(_state) {
                switch(_state.label){
                    case 0:
                        _ref = options || {
                            loadFactory: true
                        }, _ref_loadFactory = _ref.loadFactory, loadFactory = _ref_loadFactory === void 0 ? true : _ref_loadFactory;
                        return [
                            4,
                            this.getEntry()
                        ];
                    case 1:
                        remoteEntryExports = _state.sent();
                        if (!!this.inited) return [
                            3,
                            5
                        ];
                        localShareScopeMap = this.host.shareScopeMap;
                        remoteShareScope = this.remoteInfo.shareScope || 'default';
                        if (!localShareScopeMap[remoteShareScope]) {
                            localShareScopeMap[remoteShareScope] = {};
                        }
                        shareScope = localShareScopeMap[remoteShareScope];
                        initScope = [];
                        remoteEntryInitOptions = {
                            version: this.remoteInfo.version || ''
                        };
                        // Help to find host instance
                        Object.defineProperty(remoteEntryInitOptions, 'shareScopeMap', {
                            value: localShareScopeMap,
                            // remoteEntryInitOptions will be traversed and assigned during container init, ,so this attribute is not allowed to be traversed
                            enumerable: false
                        });
                        return [
                            4,
                            this.host.hooks.lifecycle.beforeInitContainer.emit({
                                shareScope: shareScope,
                                // @ts-ignore shareScopeMap will be set by Object.defineProperty
                                remoteEntryInitOptions: remoteEntryInitOptions,
                                initScope: initScope,
                                remoteInfo: this.remoteInfo,
                                origin: this.host
                            })
                        ];
                    case 2:
                        initContainerOptions = _state.sent();
                        if (typeof (remoteEntryExports == null ? void 0 : remoteEntryExports.init) === 'undefined') {
                            console.error('The remote entry interface does not contain "init"', '\n', 'Ensure the name of this remote is not reserved or in use. Check if anything already exists on window[nameOfRemote]', '\n', 'Ensure that window[nameOfRemote] is returning a {get,init} object.');
                        }
                        return [
                            4,
                            remoteEntryExports.init(initContainerOptions.shareScope, initContainerOptions.initScope, initContainerOptions.remoteEntryInitOptions)
                        ];
                    case 3:
                        _state.sent();
                        return [
                            4,
                            this.host.hooks.lifecycle.initContainer.emit(polyfills._extends({}, initContainerOptions, {
                                id: id,
                                remoteSnapshot: remoteSnapshot,
                                remoteEntryExports: remoteEntryExports
                            }))
                        ];
                    case 4:
                        _state.sent();
                        _state.label = 5;
                    case 5:
                        this.lib = remoteEntryExports;
                        this.inited = true;
                        return [
                            4,
                            remoteEntryExports.get(expose)
                        ];
                    case 6:
                        moduleFactory = _state.sent();
                        share.assert(moduleFactory, share.getFMId(this.remoteInfo) + " remote don't export " + expose + ".");
                        wrapModuleFactory = this.wraperFactory(moduleFactory, id);
                        if (!loadFactory) {
                            return [
                                2,
                                wrapModuleFactory
                            ];
                        }
                        return [
                            4,
                            wrapModuleFactory()
                        ];
                    case 7:
                        exposeContent = _state.sent();
                        return [
                            2,
                            exposeContent
                        ];
                }
            });
        }).call(this);
    };
    _proto.wraperFactory = function wraperFactory(moduleFactory, id) {
        function defineModuleId(res, id) {
            if (res && (typeof res === "undefined" ? "undefined" : _type_of._(res)) === 'object' && Object.isExtensible(res) && !Object.getOwnPropertyDescriptor(res, Symbol["for"]('mf_module_id'))) {
                Object.defineProperty(res, Symbol["for"]('mf_module_id'), {
                    value: id,
                    enumerable: false
                });
            }
        }
        if (moduleFactory instanceof Promise) {
            return function() {
                return _async_to_generator._(function() {
                    var res;
                    return _ts_generator._(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                return [
                                    4,
                                    moduleFactory()
                                ];
                            case 1:
                                res = _state.sent();
                                // This parameter is used for bridge debugging
                                defineModuleId(res, id);
                                return [
                                    2,
                                    res
                                ];
                        }
                    });
                })();
            };
        } else {
            return function() {
                var res = moduleFactory();
                // This parameter is used for bridge debugging
                defineModuleId(res, id);
                return res;
            };
        }
    };
    return Module;
}();
var SyncHook = /*#__PURE__*/ function() {
    function SyncHook(type) {
        this.type = '';
        this.listeners = new Set();
        if (type) {
            this.type = type;
        }
    }
    var _proto = SyncHook.prototype;
    _proto.on = function on(fn) {
        if (typeof fn === 'function') {
            this.listeners.add(fn);
        }
    };
    _proto.once = function once(fn) {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        var self = this;
        this.on(function wrapper() {
            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                args[_key] = arguments[_key];
            }
            self.remove(wrapper);
            // eslint-disable-next-line prefer-spread
            return fn.apply(null, args);
        });
    };
    _proto.emit = function emit() {
        for(var _len = arguments.length, data = new Array(_len), _key = 0; _key < _len; _key++){
            data[_key] = arguments[_key];
        }
        var result;
        if (this.listeners.size > 0) {
            // eslint-disable-next-line prefer-spread
            this.listeners.forEach(function(fn) {
                result = fn.apply(void 0, _to_consumable_array._(data));
            });
        }
        return result;
    };
    _proto.remove = function remove(fn) {
        this.listeners["delete"](fn);
    };
    _proto.removeAll = function removeAll() {
        this.listeners.clear();
    };
    return SyncHook;
}();
var AsyncHook = /*#__PURE__*/ function(SyncHook) {
    _inherits._(AsyncHook, SyncHook);
    function AsyncHook() {
        return SyncHook.apply(this, arguments) || this;
    }
    var _proto = AsyncHook.prototype;
    _proto.emit = function emit() {
        for(var _len = arguments.length, data = new Array(_len), _key = 0; _key < _len; _key++){
            data[_key] = arguments[_key];
        }
        var result;
        var ls = Array.from(this.listeners);
        if (ls.length > 0) {
            var i = 0;
            var call = function(prev) {
                if (prev === false) {
                    return false; // Abort process
                } else if (i < ls.length) {
                    return Promise.resolve(ls[i++].apply(null, data)).then(call);
                } else {
                    return prev;
                }
            };
            result = call();
        }
        return Promise.resolve(result);
    };
    return AsyncHook;
}(SyncHook);
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
function checkReturnData(originalData, returnedData) {
    if (!share.isObject(returnedData)) {
        return false;
    }
    if (originalData !== returnedData) {
        // eslint-disable-next-line no-restricted-syntax
        for(var key in originalData){
            if (!(key in returnedData)) {
                return false;
            }
        }
    }
    return true;
}
var SyncWaterfallHook = /*#__PURE__*/ function(SyncHook) {
    _inherits._(SyncWaterfallHook, SyncHook);
    function SyncWaterfallHook(type) {
        var _this;
        _this = SyncHook.call(this) || this, _this.onerror = share.error;
        _this.type = type;
        return _this;
    }
    var _proto = SyncWaterfallHook.prototype;
    _proto.emit = function emit(data) {
        if (!share.isObject(data)) {
            share.error('The data for the "' + this.type + '" hook should be an object.');
        }
        for(var _i = 0, _this_listeners = this.listeners; _i < _this_listeners.length; _i++){
            var fn = _this_listeners[_i];
            try {
                var tempData = fn(data);
                if (checkReturnData(data, tempData)) {
                    data = tempData;
                } else {
                    this.onerror('A plugin returned an unacceptable value for the "' + this.type + '" type.');
                    break;
                }
            } catch (e) {
                share.warn(e);
                this.onerror(e);
            }
        }
        return data;
    };
    return SyncWaterfallHook;
}(SyncHook);
var AsyncWaterfallHook = /*#__PURE__*/ function(SyncHook) {
    _inherits._(AsyncWaterfallHook, SyncHook);
    function AsyncWaterfallHook(type) {
        var _this;
        _this = SyncHook.call(this) || this, _this.onerror = share.error;
        _this.type = type;
        return _this;
    }
    var _proto = AsyncWaterfallHook.prototype;
    _proto.emit = function emit(data) {
        var _this = this;
        if (!share.isObject(data)) {
            share.error('The response data for the "' + this.type + '" hook must be an object.');
        }
        var ls = Array.from(this.listeners);
        if (ls.length > 0) {
            var i = 0;
            var processError = function(e) {
                share.warn(e);
                _this.onerror(e);
                return data;
            };
            var call = function(prevData) {
                if (checkReturnData(data, prevData)) {
                    data = prevData;
                    if (i < ls.length) {
                        try {
                            return Promise.resolve(ls[i++](data)).then(call, processError);
                        } catch (e) {
                            return processError(e);
                        }
                    }
                } else {
                    _this.onerror('A plugin returned an incorrect value for the "' + _this.type + '" type.');
                }
                return data;
            };
            return Promise.resolve(call(data));
        }
        return Promise.resolve(data);
    };
    return AsyncWaterfallHook;
}(SyncHook);
var PluginSystem = /*#__PURE__*/ function() {
    function PluginSystem(lifecycle) {
        this.registerPlugins = {};
        this.lifecycle = lifecycle;
        this.lifecycleKeys = Object.keys(lifecycle);
    }
    var _proto = PluginSystem.prototype;
    _proto.applyPlugin = function applyPlugin(plugin) {
        var _this = this;
        share.assert(share.isPlainObject(plugin), 'Plugin configuration is invalid.');
        // The plugin's name is mandatory and must be unique
        var pluginName = plugin.name;
        share.assert(pluginName, 'A name must be provided by the plugin.');
        if (!this.registerPlugins[pluginName]) {
            this.registerPlugins[pluginName] = plugin;
            Object.keys(this.lifecycle).forEach(function(key) {
                var pluginLife = plugin[key];
                if (pluginLife) {
                    _this.lifecycle[key].on(pluginLife);
                }
            });
        }
    };
    _proto.removePlugin = function removePlugin(pluginName) {
        var _this = this;
        share.assert(pluginName, 'A name is required.');
        var plugin = this.registerPlugins[pluginName];
        share.assert(plugin, 'The plugin "' + pluginName + '" is not registered.');
        Object.keys(plugin).forEach(function(key) {
            if (key !== 'name') {
                _this.lifecycle[key].remove(plugin[key]);
            }
        });
    };
    // eslint-disable-next-line @typescript-eslint/no-shadow
    _proto.inherit = function inherit(param) {
        var _this = this;
        var lifecycle = param.lifecycle, _$registerPlugins = param.registerPlugins;
        Object.keys(lifecycle).forEach(function(hookName) {
            share.assert(!_this.lifecycle[hookName], 'The hook "' + hookName + '" has a conflict and cannot be inherited.');
            _this.lifecycle[hookName] = lifecycle[hookName];
        });
        Object.keys(_$registerPlugins).forEach(function(pluginName) {
            share.assert(!_this.registerPlugins[pluginName], 'The plugin "' + pluginName + '" has a conflict and cannot be inherited.');
            _this.applyPlugin(_$registerPlugins[pluginName]);
        });
    };
    return PluginSystem;
}();
function defaultPreloadArgs(preloadConfig) {
    return polyfills._extends({
        resourceCategory: 'sync',
        share: true,
        depsRemote: true,
        prefetchInterface: false
    }, preloadConfig);
}
function formatPreloadArgs(remotes, preloadArgs) {
    return preloadArgs.map(function(args) {
        var remoteInfo = matchRemote(remotes, args.nameOrAlias);
        share.assert(remoteInfo, "Unable to preload " + args.nameOrAlias + " as it is not included in " + (!remoteInfo && sdk.safeToString({
            remoteInfo: remoteInfo,
            remotes: remotes
        })));
        return {
            remote: remoteInfo,
            preloadConfig: defaultPreloadArgs(args)
        };
    });
}
function normalizePreloadExposes(exposes) {
    if (!exposes) {
        return [];
    }
    return exposes.map(function(expose) {
        if (expose === '.') {
            return expose;
        }
        if (expose.startsWith('./')) {
            return expose.replace('./', '');
        }
        return expose;
    });
}
function preloadAssets(remoteInfo, host, assets, useLinkPreload) {
    if (useLinkPreload === void 0) useLinkPreload = true;
    var cssAssets = assets.cssAssets, jsAssetsWithoutEntry = assets.jsAssetsWithoutEntry, entryAssets = assets.entryAssets;
    if (host.options.inBrowser) {
        entryAssets.forEach(function(asset) {
            var moduleInfo = asset.moduleInfo;
            var module = host.moduleCache.get(remoteInfo.name);
            if (module) {
                getRemoteEntry({
                    origin: host,
                    remoteInfo: moduleInfo,
                    remoteEntryExports: module.remoteEntryExports
                });
            } else {
                getRemoteEntry({
                    origin: host,
                    remoteInfo: moduleInfo,
                    remoteEntryExports: undefined
                });
            }
        });
        if (useLinkPreload) {
            var defaultAttrs = {
                rel: 'preload',
                as: 'style'
            };
            cssAssets.forEach(function(cssUrl) {
                var _sdk_createLink = sdk.createLink({
                    url: cssUrl,
                    cb: function() {
                    // noop
                    },
                    attrs: defaultAttrs,
                    createLinkHook: function(url, attrs) {
                        var res = host.loaderHook.lifecycle.createLink.emit({
                            url: url,
                            attrs: attrs
                        });
                        if (res instanceof HTMLLinkElement) {
                            return res;
                        }
                        return;
                    }
                }), cssEl = _sdk_createLink.link, needAttach = _sdk_createLink.needAttach;
                needAttach && document.head.appendChild(cssEl);
            });
        } else {
            var defaultAttrs1 = {
                rel: 'stylesheet',
                type: 'text/css'
            };
            cssAssets.forEach(function(cssUrl) {
                var _sdk_createLink = sdk.createLink({
                    url: cssUrl,
                    cb: function() {
                    // noop
                    },
                    attrs: defaultAttrs1,
                    createLinkHook: function(url, attrs) {
                        var res = host.loaderHook.lifecycle.createLink.emit({
                            url: url,
                            attrs: attrs
                        });
                        if (res instanceof HTMLLinkElement) {
                            return res;
                        }
                        return;
                    },
                    needDeleteLink: false
                }), cssEl = _sdk_createLink.link, needAttach = _sdk_createLink.needAttach;
                needAttach && document.head.appendChild(cssEl);
            });
        }
        if (useLinkPreload) {
            var defaultAttrs2 = {
                rel: 'preload',
                as: 'script'
            };
            jsAssetsWithoutEntry.forEach(function(jsUrl) {
                var _sdk_createLink = sdk.createLink({
                    url: jsUrl,
                    cb: function() {
                    // noop
                    },
                    attrs: defaultAttrs2,
                    createLinkHook: function(url, attrs) {
                        var res = host.loaderHook.lifecycle.createLink.emit({
                            url: url,
                            attrs: attrs
                        });
                        if (res instanceof HTMLLinkElement) {
                            return res;
                        }
                        return;
                    }
                }), linkEl = _sdk_createLink.link, needAttach = _sdk_createLink.needAttach;
                needAttach && document.head.appendChild(linkEl);
            });
        } else {
            var defaultAttrs3 = {
                fetchpriority: 'high',
                type: (remoteInfo == null ? void 0 : remoteInfo.type) === 'module' ? 'module' : 'text/javascript'
            };
            jsAssetsWithoutEntry.forEach(function(jsUrl) {
                var _sdk_createScript = sdk.createScript({
                    url: jsUrl,
                    cb: function() {
                    // noop
                    },
                    attrs: defaultAttrs3,
                    createScriptHook: function(url, attrs) {
                        var res = host.loaderHook.lifecycle.createScript.emit({
                            url: url,
                            attrs: attrs
                        });
                        if (res instanceof HTMLScriptElement) {
                            return res;
                        }
                        return;
                    },
                    needDeleteScript: true
                }), scriptEl = _sdk_createScript.script, needAttach = _sdk_createScript.needAttach;
                needAttach && document.head.appendChild(scriptEl);
            });
        }
    }
}
function assignRemoteInfo(remoteInfo, remoteSnapshot) {
    var remoteEntryInfo = share.getRemoteEntryInfoFromSnapshot(remoteSnapshot);
    if (!remoteEntryInfo.url) {
        share.error("The attribute remoteEntry of " + remoteInfo.name + " must not be undefined.");
    }
    var entryUrl = sdk.getResourceUrl(remoteSnapshot, remoteEntryInfo.url);
    if (!sdk.isBrowserEnv() && !entryUrl.startsWith('http')) {
        entryUrl = "https:" + entryUrl;
    }
    remoteInfo.type = remoteEntryInfo.type;
    remoteInfo.entryGlobalName = remoteEntryInfo.globalName;
    remoteInfo.entry = entryUrl;
    remoteInfo.version = remoteSnapshot.version;
    remoteInfo.buildVersion = remoteSnapshot.buildVersion;
}
function snapshotPlugin() {
    return {
        name: 'snapshot-plugin',
        afterResolve: function(args) {
            return _async_to_generator._(function() {
                var remote, pkgNameOrAlias, expose, origin, remoteInfo, _ref, remoteSnapshot, globalSnapshot, preloadOptions, assets;
                return _ts_generator._(this, function(_state) {
                    switch(_state.label){
                        case 0:
                            remote = args.remote, pkgNameOrAlias = args.pkgNameOrAlias, expose = args.expose, origin = args.origin, remoteInfo = args.remoteInfo;
                            if (!(!share.isRemoteInfoWithEntry(remote) || !share.isPureRemoteEntry(remote))) return [
                                3,
                                3
                            ];
                            return [
                                4,
                                origin.snapshotHandler.loadRemoteSnapshotInfo(remote)
                            ];
                        case 1:
                            _ref = _state.sent(), remoteSnapshot = _ref.remoteSnapshot, globalSnapshot = _ref.globalSnapshot;
                            assignRemoteInfo(remoteInfo, remoteSnapshot);
                            // preloading assets
                            preloadOptions = {
                                remote: remote,
                                preloadConfig: {
                                    nameOrAlias: pkgNameOrAlias,
                                    exposes: [
                                        expose
                                    ],
                                    resourceCategory: 'sync',
                                    share: false,
                                    depsRemote: false
                                }
                            };
                            return [
                                4,
                                origin.remoteHandler.hooks.lifecycle.generatePreloadAssets.emit({
                                    origin: origin,
                                    preloadOptions: preloadOptions,
                                    remoteInfo: remoteInfo,
                                    remote: remote,
                                    remoteSnapshot: remoteSnapshot,
                                    globalSnapshot: globalSnapshot
                                })
                            ];
                        case 2:
                            assets = _state.sent();
                            if (assets) {
                                preloadAssets(remoteInfo, origin, assets, false);
                            }
                            return [
                                2,
                                polyfills._extends({}, args, {
                                    remoteSnapshot: remoteSnapshot
                                })
                            ];
                        case 3:
                            return [
                                2,
                                args
                            ];
                    }
                });
            })();
        }
    };
}
// name
// name:version
function splitId(id) {
    var splitInfo = id.split(':');
    if (splitInfo.length === 1) {
        return {
            name: splitInfo[0],
            version: undefined
        };
    } else if (splitInfo.length === 2) {
        return {
            name: splitInfo[0],
            version: splitInfo[1]
        };
    } else {
        return {
            name: splitInfo[1],
            version: splitInfo[2]
        };
    }
}
// Traverse all nodes in moduleInfo and traverse the entire snapshot
function traverseModuleInfo(globalSnapshot, remoteInfo, traverse, isRoot, memo, remoteSnapshot) {
    if (memo === void 0) memo = {};
    var id = share.getFMId(remoteInfo);
    var _share_getInfoWithoutType = share.getInfoWithoutType(globalSnapshot, id), snapshotValue = _share_getInfoWithoutType.value;
    var effectiveRemoteSnapshot = remoteSnapshot || snapshotValue;
    if (effectiveRemoteSnapshot && !sdk.isManifestProvider(effectiveRemoteSnapshot)) {
        traverse(effectiveRemoteSnapshot, remoteInfo, isRoot);
        if (effectiveRemoteSnapshot.remotesInfo) {
            var remoteKeys = Object.keys(effectiveRemoteSnapshot.remotesInfo);
            for(var _i = 0; _i < remoteKeys.length; _i++){
                var key = remoteKeys[_i];
                if (memo[key]) {
                    continue;
                }
                memo[key] = true;
                var subRemoteInfo = splitId(key);
                var remoteValue = effectiveRemoteSnapshot.remotesInfo[key];
                traverseModuleInfo(globalSnapshot, {
                    name: subRemoteInfo.name,
                    version: remoteValue.matchedVersion
                }, traverse, false, memo, undefined);
            }
        }
    }
}
// eslint-disable-next-line max-lines-per-function
function generatePreloadAssets(origin, preloadOptions, remote, globalSnapshot, remoteSnapshot) {
    var cssAssets = [];
    var jsAssets = [];
    var entryAssets = [];
    var loadedSharedJsAssets = new Set();
    var loadedSharedCssAssets = new Set();
    var options = origin.options;
    var rootPreloadConfig = preloadOptions.preloadConfig;
    var depsRemote = rootPreloadConfig.depsRemote;
    var memo = {};
    traverseModuleInfo(globalSnapshot, remote, function(moduleInfoSnapshot, remoteInfo, isRoot) {
        var handleAssets = function handleAssets(assets) {
            var assetsRes = assets.map(function(asset) {
                return sdk.getResourceUrl(moduleInfoSnapshot, asset);
            });
            if (preloadConfig.filter) {
                return assetsRes.filter(preloadConfig.filter);
            }
            return assetsRes;
        };
        var preloadConfig;
        if (isRoot) {
            preloadConfig = rootPreloadConfig;
        } else {
            if (Array.isArray(depsRemote)) {
                // eslint-disable-next-line array-callback-return
                var findPreloadConfig = depsRemote.find(function(remoteConfig) {
                    if (remoteConfig.nameOrAlias === remoteInfo.name || remoteConfig.nameOrAlias === remoteInfo.alias) {
                        return true;
                    }
                    return false;
                });
                if (!findPreloadConfig) {
                    return;
                }
                preloadConfig = defaultPreloadArgs(findPreloadConfig);
            } else if (depsRemote === true) {
                preloadConfig = rootPreloadConfig;
            } else {
                return;
            }
        }
        var remoteEntryUrl = sdk.getResourceUrl(moduleInfoSnapshot, share.getRemoteEntryInfoFromSnapshot(moduleInfoSnapshot).url);
        if (remoteEntryUrl) {
            entryAssets.push({
                name: remoteInfo.name,
                moduleInfo: {
                    name: remoteInfo.name,
                    entry: remoteEntryUrl,
                    type: 'remoteEntryType' in moduleInfoSnapshot ? moduleInfoSnapshot.remoteEntryType : 'global',
                    entryGlobalName: 'globalName' in moduleInfoSnapshot ? moduleInfoSnapshot.globalName : remoteInfo.name,
                    shareScope: '',
                    version: 'version' in moduleInfoSnapshot ? moduleInfoSnapshot.version : undefined
                },
                url: remoteEntryUrl
            });
        }
        var moduleAssetsInfo = 'modules' in moduleInfoSnapshot ? moduleInfoSnapshot.modules : [];
        var normalizedPreloadExposes = normalizePreloadExposes(preloadConfig.exposes);
        if (normalizedPreloadExposes.length && 'modules' in moduleInfoSnapshot) {
            var _moduleInfoSnapshot_modules;
            moduleAssetsInfo = moduleInfoSnapshot == null ? void 0 : (_moduleInfoSnapshot_modules = moduleInfoSnapshot.modules) == null ? void 0 : _moduleInfoSnapshot_modules.reduce(function(assets, moduleAssetInfo) {
                if ((normalizedPreloadExposes == null ? void 0 : normalizedPreloadExposes.indexOf(moduleAssetInfo.moduleName)) !== -1) {
                    assets.push(moduleAssetInfo);
                }
                return assets;
            }, []);
        }
        if (moduleAssetsInfo) {
            var assetsLength = moduleAssetsInfo.length;
            for(var index = 0; index < assetsLength; index++){
                var assetsInfo = moduleAssetsInfo[index];
                var exposeFullPath = remoteInfo.name + "/" + assetsInfo.moduleName;
                origin.remoteHandler.hooks.lifecycle.handlePreloadModule.emit({
                    id: assetsInfo.moduleName === '.' ? remoteInfo.name : exposeFullPath,
                    name: remoteInfo.name,
                    remoteSnapshot: moduleInfoSnapshot,
                    preloadConfig: preloadConfig,
                    remote: remoteInfo,
                    origin: origin
                });
                var preloaded = share.getPreloaded(exposeFullPath);
                if (preloaded) {
                    continue;
                }
                if (preloadConfig.resourceCategory === 'all') {
                    var _cssAssets, _cssAssets1, _jsAssets, _jsAssets1;
                    (_cssAssets = cssAssets).push.apply(_cssAssets, _to_consumable_array._(handleAssets(assetsInfo.assets.css.async)));
                    (_cssAssets1 = cssAssets).push.apply(_cssAssets1, _to_consumable_array._(handleAssets(assetsInfo.assets.css.sync)));
                    (_jsAssets = jsAssets).push.apply(_jsAssets, _to_consumable_array._(handleAssets(assetsInfo.assets.js.async)));
                    (_jsAssets1 = jsAssets).push.apply(_jsAssets1, _to_consumable_array._(handleAssets(assetsInfo.assets.js.sync)));
                // eslint-disable-next-line no-constant-condition
                } else if (preloadConfig.resourceCategory = 'sync') {
                    var _cssAssets2, _jsAssets2;
                    (_cssAssets2 = cssAssets).push.apply(_cssAssets2, _to_consumable_array._(handleAssets(assetsInfo.assets.css.sync)));
                    (_jsAssets2 = jsAssets).push.apply(_jsAssets2, _to_consumable_array._(handleAssets(assetsInfo.assets.js.sync)));
                }
                share.setPreloaded(exposeFullPath);
            }
        }
    }, true, memo, remoteSnapshot);
    if (remoteSnapshot.shared) {
        var collectSharedAssets = function(shareInfo, snapshotShared) {
            var registeredShared = share.getRegisteredShare(origin.shareScopeMap, snapshotShared.sharedName, shareInfo, origin.sharedHandler.hooks.lifecycle.resolveShare);
            // If the global share does not exist, or the lib function does not exist, it means that the shared has not been loaded yet and can be preloaded.
            if (registeredShared && typeof registeredShared.lib === 'function') {
                snapshotShared.assets.js.sync.forEach(function(asset) {
                    loadedSharedJsAssets.add(asset);
                });
                snapshotShared.assets.css.sync.forEach(function(asset) {
                    loadedSharedCssAssets.add(asset);
                });
            }
        };
        remoteSnapshot.shared.forEach(function(shared) {
            var _options_shared;
            var shareInfos = (_options_shared = options.shared) == null ? void 0 : _options_shared[shared.sharedName];
            if (!shareInfos) {
                return;
            }
            // if no version, preload all shared
            var sharedOptions = shared.version ? shareInfos.find(function(s) {
                return s.version === shared.version;
            }) : shareInfos;
            if (!sharedOptions) {
                return;
            }
            var arrayShareInfo = share.arrayOptions(sharedOptions);
            arrayShareInfo.forEach(function(s) {
                collectSharedAssets(s, shared);
            });
        });
    }
    var needPreloadJsAssets = jsAssets.filter(function(asset) {
        return !loadedSharedJsAssets.has(asset);
    });
    var needPreloadCssAssets = cssAssets.filter(function(asset) {
        return !loadedSharedCssAssets.has(asset);
    });
    return {
        cssAssets: needPreloadCssAssets,
        jsAssetsWithoutEntry: needPreloadJsAssets,
        entryAssets: entryAssets
    };
}
var generatePreloadAssetsPlugin = function generatePreloadAssetsPlugin() {
    return {
        name: 'generate-preload-assets-plugin',
        generatePreloadAssets: function(args) {
            return _async_to_generator._(function() {
                var origin, preloadOptions, remoteInfo, remote, globalSnapshot, remoteSnapshot, assets;
                return _ts_generator._(this, function(_state) {
                    origin = args.origin, preloadOptions = args.preloadOptions, remoteInfo = args.remoteInfo, remote = args.remote, globalSnapshot = args.globalSnapshot, remoteSnapshot = args.remoteSnapshot;
                    if (share.isRemoteInfoWithEntry(remote) && share.isPureRemoteEntry(remote)) {
                        return [
                            2,
                            {
                                cssAssets: [],
                                jsAssetsWithoutEntry: [],
                                entryAssets: [
                                    {
                                        name: remote.name,
                                        url: remote.entry,
                                        moduleInfo: {
                                            name: remoteInfo.name,
                                            entry: remote.entry,
                                            type: remoteInfo.type || 'global',
                                            entryGlobalName: '',
                                            shareScope: ''
                                        }
                                    }
                                ]
                            }
                        ];
                    }
                    assignRemoteInfo(remoteInfo, remoteSnapshot);
                    assets = generatePreloadAssets(origin, preloadOptions, remoteInfo, globalSnapshot, remoteSnapshot);
                    return [
                        2,
                        assets
                    ];
                });
            })();
        }
    };
};
function getGlobalRemoteInfo(moduleInfo, origin) {
    var hostGlobalSnapshot = share.getGlobalSnapshotInfoByModuleInfo({
        name: origin.options.name,
        version: origin.options.version
    });
    // get remote detail info from global
    var globalRemoteInfo = hostGlobalSnapshot && 'remotesInfo' in hostGlobalSnapshot && hostGlobalSnapshot.remotesInfo && share.getInfoWithoutType(hostGlobalSnapshot.remotesInfo, moduleInfo.name).value;
    if (globalRemoteInfo && globalRemoteInfo.matchedVersion) {
        return {
            hostGlobalSnapshot: hostGlobalSnapshot,
            globalSnapshot: share.getGlobalSnapshot(),
            remoteSnapshot: share.getGlobalSnapshotInfoByModuleInfo({
                name: moduleInfo.name,
                version: globalRemoteInfo.matchedVersion
            })
        };
    }
    return {
        hostGlobalSnapshot: undefined,
        globalSnapshot: share.getGlobalSnapshot(),
        remoteSnapshot: share.getGlobalSnapshotInfoByModuleInfo({
            name: moduleInfo.name,
            version: 'version' in moduleInfo ? moduleInfo.version : undefined
        })
    };
}
var SnapshotHandler = /*#__PURE__*/ function() {
    function SnapshotHandler(HostInstance) {
        this.loadingHostSnapshot = null;
        this.manifestCache = new Map();
        this.hooks = new PluginSystem({
            beforeLoadRemoteSnapshot: new AsyncHook('beforeLoadRemoteSnapshot'),
            loadSnapshot: new AsyncWaterfallHook('loadGlobalSnapshot'),
            loadRemoteSnapshot: new AsyncWaterfallHook('loadRemoteSnapshot')
        });
        this.manifestLoading = share.Global.__FEDERATION__.__MANIFEST_LOADING__;
        this.HostInstance = HostInstance;
        this.loaderHook = HostInstance.loaderHook;
    }
    var _proto = SnapshotHandler.prototype;
    _proto.loadSnapshot = function loadSnapshot(moduleInfo) {
        return _async_to_generator._(function() {
            var options, _this_getGlobalRemoteInfo, hostGlobalSnapshot, remoteSnapshot, globalSnapshot, _ref, globalRemoteSnapshot, globalSnapshotRes;
            return _ts_generator._(this, function(_state) {
                switch(_state.label){
                    case 0:
                        options = this.HostInstance.options;
                        _this_getGlobalRemoteInfo = this.getGlobalRemoteInfo(moduleInfo), hostGlobalSnapshot = _this_getGlobalRemoteInfo.hostGlobalSnapshot, remoteSnapshot = _this_getGlobalRemoteInfo.remoteSnapshot, globalSnapshot = _this_getGlobalRemoteInfo.globalSnapshot;
                        return [
                            4,
                            this.hooks.lifecycle.loadSnapshot.emit({
                                options: options,
                                moduleInfo: moduleInfo,
                                hostGlobalSnapshot: hostGlobalSnapshot,
                                remoteSnapshot: remoteSnapshot,
                                globalSnapshot: globalSnapshot
                            })
                        ];
                    case 1:
                        _ref = _state.sent(), globalRemoteSnapshot = _ref.remoteSnapshot, globalSnapshotRes = _ref.globalSnapshot;
                        return [
                            2,
                            {
                                remoteSnapshot: globalRemoteSnapshot,
                                globalSnapshot: globalSnapshotRes
                            }
                        ];
                }
            });
        }).call(this);
    };
    // eslint-disable-next-line max-lines-per-function
    _proto.loadRemoteSnapshotInfo = function loadRemoteSnapshotInfo(moduleInfo) {
        return _async_to_generator._(function() {
            var options, hostSnapshot, _this_getGlobalRemoteInfo, hostGlobalSnapshot, remoteSnapshot, globalSnapshot, _ref, globalRemoteSnapshot, globalSnapshotRes, remoteEntry, moduleSnapshot, globalSnapshotRes1, _ref1, remoteSnapshotRes, moduleSnapshot1, globalSnapshotRes2, _ref2, remoteSnapshotRes1;
            return _ts_generator._(this, function(_state) {
                switch(_state.label){
                    case 0:
                        options = this.HostInstance.options;
                        return [
                            4,
                            this.hooks.lifecycle.beforeLoadRemoteSnapshot.emit({
                                options: options,
                                moduleInfo: moduleInfo
                            })
                        ];
                    case 1:
                        _state.sent();
                        hostSnapshot = share.getGlobalSnapshotInfoByModuleInfo({
                            name: this.HostInstance.options.name,
                            version: this.HostInstance.options.version
                        });
                        if (!hostSnapshot) {
                            hostSnapshot = {
                                version: this.HostInstance.options.version || '',
                                remoteEntry: '',
                                remotesInfo: {}
                            };
                            share.addGlobalSnapshot(_define_property._({}, this.HostInstance.options.name, hostSnapshot));
                        }
                        // In dynamic loadRemote scenarios, incomplete remotesInfo delivery may occur. In such cases, the remotesInfo in the host needs to be completed in the snapshot at runtime.
                        // This ensures the snapshot's integrity and helps the chrome plugin correctly identify all producer modules, ensuring that proxyable producer modules will not be missing.
                        if (hostSnapshot && 'remotesInfo' in hostSnapshot && !share.getInfoWithoutType(hostSnapshot.remotesInfo, moduleInfo.name).value) {
                            if ('version' in moduleInfo || 'entry' in moduleInfo) {
                                hostSnapshot.remotesInfo = polyfills._extends({}, hostSnapshot == null ? void 0 : hostSnapshot.remotesInfo, _define_property._({}, moduleInfo.name, {
                                    matchedVersion: 'version' in moduleInfo ? moduleInfo.version : moduleInfo.entry
                                }));
                            }
                        }
                        _this_getGlobalRemoteInfo = this.getGlobalRemoteInfo(moduleInfo), hostGlobalSnapshot = _this_getGlobalRemoteInfo.hostGlobalSnapshot, remoteSnapshot = _this_getGlobalRemoteInfo.remoteSnapshot, globalSnapshot = _this_getGlobalRemoteInfo.globalSnapshot;
                        return [
                            4,
                            this.hooks.lifecycle.loadSnapshot.emit({
                                options: options,
                                moduleInfo: moduleInfo,
                                hostGlobalSnapshot: hostGlobalSnapshot,
                                remoteSnapshot: remoteSnapshot,
                                globalSnapshot: globalSnapshot
                            })
                        ];
                    case 2:
                        _ref = _state.sent(), globalRemoteSnapshot = _ref.remoteSnapshot, globalSnapshotRes = _ref.globalSnapshot;
                        if (!globalRemoteSnapshot) return [
                            3,
                            7
                        ];
                        if (!sdk.isManifestProvider(globalRemoteSnapshot)) return [
                            3,
                            4
                        ];
                        remoteEntry = sdk.isBrowserEnv() ? globalRemoteSnapshot.remoteEntry : globalRemoteSnapshot.ssrRemoteEntry || globalRemoteSnapshot.remoteEntry || '';
                        return [
                            4,
                            this.getManifestJson(remoteEntry, moduleInfo, {})
                        ];
                    case 3:
                        moduleSnapshot = _state.sent();
                        // eslint-disable-next-line @typescript-eslint/no-shadow
                        globalSnapshotRes1 = share.setGlobalSnapshotInfoByModuleInfo(polyfills._extends({}, moduleInfo, {
                            // The global remote may be overridden
                            // Therefore, set the snapshot key to the global address of the actual request
                            entry: remoteEntry
                        }), moduleSnapshot);
                        return [
                            2,
                            {
                                remoteSnapshot: moduleSnapshot,
                                globalSnapshot: globalSnapshotRes1
                            }
                        ];
                    case 4:
                        return [
                            4,
                            this.hooks.lifecycle.loadRemoteSnapshot.emit({
                                options: this.HostInstance.options,
                                moduleInfo: moduleInfo,
                                remoteSnapshot: globalRemoteSnapshot,
                                from: 'global'
                            })
                        ];
                    case 5:
                        _ref1 = _state.sent(), remoteSnapshotRes = _ref1.remoteSnapshot;
                        return [
                            2,
                            {
                                remoteSnapshot: remoteSnapshotRes,
                                globalSnapshot: globalSnapshotRes
                            }
                        ];
                    case 6:
                        return [
                            3,
                            11
                        ];
                    case 7:
                        if (!share.isRemoteInfoWithEntry(moduleInfo)) return [
                            3,
                            10
                        ];
                        return [
                            4,
                            this.getManifestJson(moduleInfo.entry, moduleInfo, {})
                        ];
                    case 8:
                        moduleSnapshot1 = _state.sent();
                        // eslint-disable-next-line @typescript-eslint/no-shadow
                        globalSnapshotRes2 = share.setGlobalSnapshotInfoByModuleInfo(moduleInfo, moduleSnapshot1);
                        return [
                            4,
                            this.hooks.lifecycle.loadRemoteSnapshot.emit({
                                options: this.HostInstance.options,
                                moduleInfo: moduleInfo,
                                remoteSnapshot: moduleSnapshot1,
                                from: 'global'
                            })
                        ];
                    case 9:
                        _ref2 = _state.sent(), remoteSnapshotRes1 = _ref2.remoteSnapshot;
                        return [
                            2,
                            {
                                remoteSnapshot: remoteSnapshotRes1,
                                globalSnapshot: globalSnapshotRes2
                            }
                        ];
                    case 10:
                        share.error("\n          Cannot get remoteSnapshot with the name: '" + moduleInfo.name + "', version: '" + moduleInfo.version + "' from __FEDERATION__.moduleInfo. The following reasons may be causing the problem:\n\n          1. The Deploy platform did not deliver the correct data. You can use __FEDERATION__.moduleInfo to check the remoteInfo.\n\n          2. The remote '" + moduleInfo.name + "' version '" + moduleInfo.version + "' is not released.\n\n          The transformed module info: " + JSON.stringify(globalSnapshotRes) + "\n        ");
                        _state.label = 11;
                    case 11:
                        return [
                            2
                        ];
                }
            });
        }).call(this);
    };
    _proto.getGlobalRemoteInfo = function getGlobalRemoteInfo1(moduleInfo) {
        return getGlobalRemoteInfo(moduleInfo, this.HostInstance);
    };
    _proto.getManifestJson = function getManifestJson(manifestUrl, moduleInfo, extraOptions) {
        return _async_to_generator._(function() {
            var _this, getManifest, asyncLoadProcess;
            return _ts_generator._(this, function(_state) {
                _this = this;
                getManifest = function() {
                    return _async_to_generator._(function() {
                        var manifestJson, res, err;
                        return _ts_generator._(this, function(_state) {
                            switch(_state.label){
                                case 0:
                                    manifestJson = this.manifestCache.get(manifestUrl);
                                    if (manifestJson) {
                                        return [
                                            2,
                                            manifestJson
                                        ];
                                    }
                                    _state.label = 1;
                                case 1:
                                    _state.trys.push([
                                        1,
                                        6,
                                        ,
                                        7
                                    ]);
                                    return [
                                        4,
                                        this.loaderHook.lifecycle.fetch.emit(manifestUrl, {})
                                    ];
                                case 2:
                                    res = _state.sent();
                                    if (!(!res || !(res instanceof Response))) return [
                                        3,
                                        4
                                    ];
                                    return [
                                        4,
                                        fetch(manifestUrl, {})
                                    ];
                                case 3:
                                    res = _state.sent();
                                    _state.label = 4;
                                case 4:
                                    return [
                                        4,
                                        res.json()
                                    ];
                                case 5:
                                    manifestJson = _state.sent();
                                    share.assert(manifestJson.metaData && manifestJson.exposes && manifestJson.shared, "" + manifestUrl + " is not a federation manifest");
                                    this.manifestCache.set(manifestUrl, manifestJson);
                                    return [
                                        2,
                                        manifestJson
                                    ];
                                case 6:
                                    err = _state.sent();
                                    delete this.manifestLoading[manifestUrl];
                                    share.error("Failed to get manifestJson for " + moduleInfo.name + ". The manifest URL is " + manifestUrl + ". Please ensure that the manifestUrl is accessible.\n          \n Error message:\n          \n " + err);
                                    return [
                                        3,
                                        7
                                    ];
                                case 7:
                                    return [
                                        2
                                    ];
                            }
                        });
                    }).call(_this);
                };
                asyncLoadProcess = function() {
                    return _async_to_generator._(function() {
                        var manifestJson, remoteSnapshot, _ref, remoteSnapshotRes;
                        return _ts_generator._(this, function(_state) {
                            switch(_state.label){
                                case 0:
                                    return [
                                        4,
                                        getManifest()
                                    ];
                                case 1:
                                    manifestJson = _state.sent();
                                    remoteSnapshot = sdk.generateSnapshotFromManifest(manifestJson, {
                                        version: manifestUrl
                                    });
                                    return [
                                        4,
                                        this.hooks.lifecycle.loadRemoteSnapshot.emit({
                                            options: this.HostInstance.options,
                                            moduleInfo: moduleInfo,
                                            manifestJson: manifestJson,
                                            remoteSnapshot: remoteSnapshot,
                                            manifestUrl: manifestUrl,
                                            from: 'manifest'
                                        })
                                    ];
                                case 2:
                                    _ref = _state.sent(), remoteSnapshotRes = _ref.remoteSnapshot;
                                    return [
                                        2,
                                        remoteSnapshotRes
                                    ];
                            }
                        });
                    }).call(_this);
                };
                if (!this.manifestLoading[manifestUrl]) {
                    this.manifestLoading[manifestUrl] = asyncLoadProcess().then(function(res) {
                        return res;
                    });
                }
                return [
                    2,
                    this.manifestLoading[manifestUrl]
                ];
            });
        }).call(this);
    };
    return SnapshotHandler;
}();
var SharedHandler = /*#__PURE__*/ function() {
    function SharedHandler(host) {
        this.hooks = new PluginSystem({
            afterResolve: new AsyncWaterfallHook('afterResolve'),
            beforeLoadShare: new AsyncWaterfallHook('beforeLoadShare'),
            // not used yet
            loadShare: new AsyncHook(),
            resolveShare: new SyncWaterfallHook('resolveShare'),
            // maybe will change, temporarily for internal use only
            initContainerShareScopeMap: new SyncWaterfallHook('initContainerShareScopeMap')
        });
        this.host = host;
        this.shareScopeMap = {};
        this.initTokens = {};
        this._setGlobalShareScopeMap(host.options);
    }
    var _proto = SharedHandler.prototype;
    // register shared in shareScopeMap
    _proto.registerShared = function registerShared(globalOptions, userOptions) {
        var _this = this;
        var _share_formatShareConfigs = share.formatShareConfigs(globalOptions, userOptions), shareInfos = _share_formatShareConfigs.shareInfos, shared = _share_formatShareConfigs.shared;
        var sharedKeys = Object.keys(shareInfos);
        sharedKeys.forEach(function(sharedKey) {
            var sharedVals = shareInfos[sharedKey];
            sharedVals.forEach(function(sharedVal) {
                var registeredShared = share.getRegisteredShare(_this.shareScopeMap, sharedKey, sharedVal, _this.hooks.lifecycle.resolveShare);
                if (!registeredShared && sharedVal && sharedVal.lib) {
                    _this.setShared({
                        pkgName: sharedKey,
                        lib: sharedVal.lib,
                        get: sharedVal.get,
                        loaded: true,
                        shared: sharedVal,
                        from: userOptions.name
                    });
                }
            });
        });
        return {
            shareInfos: shareInfos,
            shared: shared
        };
    };
    _proto.loadShare = function loadShare(pkgName, extraOptions) {
        return _async_to_generator._(function() {
            var _this, host, shareInfo, loadShareRes, shareInfoRes, registeredShared, addUseIn, factory, asyncLoadProcess, loading, asyncLoadProcess1, loading1;
            return _ts_generator._(this, function(_state) {
                switch(_state.label){
                    case 0:
                        _this = this;
                        host = this.host;
                        // This function performs the following steps:
                        // 1. Checks if the currently loaded share already exists, if not, it throws an error
                        // 2. Searches globally for a matching share, if found, it uses it directly
                        // 3. If not found, it retrieves it from the current share and stores the obtained share globally.
                        shareInfo = share.getTargetSharedOptions({
                            pkgName: pkgName,
                            extraOptions: extraOptions,
                            shareInfos: host.options.shared
                        });
                        if (!(shareInfo == null ? void 0 : shareInfo.scope)) return [
                            3,
                            2
                        ];
                        return [
                            4,
                            Promise.all(shareInfo.scope.map(function(shareScope) {
                                return _async_to_generator._(function() {
                                    return _ts_generator._(this, function(_state) {
                                        switch(_state.label){
                                            case 0:
                                                return [
                                                    4,
                                                    Promise.all(this.initializeSharing(shareScope, {
                                                        strategy: shareInfo.strategy
                                                    }))
                                                ];
                                            case 1:
                                                _state.sent();
                                                return [
                                                    2
                                                ];
                                        }
                                    });
                                }).call(_this);
                            }))
                        ];
                    case 1:
                        _state.sent();
                        _state.label = 2;
                    case 2:
                        return [
                            4,
                            this.hooks.lifecycle.beforeLoadShare.emit({
                                pkgName: pkgName,
                                shareInfo: shareInfo,
                                shared: host.options.shared,
                                origin: host
                            })
                        ];
                    case 3:
                        loadShareRes = _state.sent();
                        shareInfoRes = loadShareRes.shareInfo;
                        // Assert that shareInfoRes exists, if not, throw an error
                        share.assert(shareInfoRes, "Cannot find " + pkgName + " Share in the " + host.options.name + ". Please ensure that the " + pkgName + " Share parameters have been injected");
                        // Retrieve from cache
                        registeredShared = share.getRegisteredShare(this.shareScopeMap, pkgName, shareInfoRes, this.hooks.lifecycle.resolveShare);
                        addUseIn = function(shared) {
                            if (!shared.useIn) {
                                shared.useIn = [];
                            }
                            share.addUniqueItem(shared.useIn, host.options.name);
                        };
                        if (!(registeredShared && registeredShared.lib)) return [
                            3,
                            4
                        ];
                        addUseIn(registeredShared);
                        return [
                            2,
                            registeredShared.lib
                        ];
                    case 4:
                        if (!(registeredShared && registeredShared.loading && !registeredShared.loaded)) return [
                            3,
                            6
                        ];
                        return [
                            4,
                            registeredShared.loading
                        ];
                    case 5:
                        factory = _state.sent();
                        registeredShared.loaded = true;
                        if (!registeredShared.lib) {
                            registeredShared.lib = factory;
                        }
                        addUseIn(registeredShared);
                        return [
                            2,
                            factory
                        ];
                    case 6:
                        if (registeredShared) {
                            asyncLoadProcess = function() {
                                return _async_to_generator._(function() {
                                    var factory, gShared;
                                    return _ts_generator._(this, function(_state) {
                                        switch(_state.label){
                                            case 0:
                                                return [
                                                    4,
                                                    registeredShared.get()
                                                ];
                                            case 1:
                                                factory = _state.sent();
                                                shareInfoRes.lib = factory;
                                                shareInfoRes.loaded = true;
                                                addUseIn(shareInfoRes);
                                                gShared = share.getRegisteredShare(this.shareScopeMap, pkgName, shareInfoRes, this.hooks.lifecycle.resolveShare);
                                                if (gShared) {
                                                    gShared.lib = factory;
                                                    gShared.loaded = true;
                                                }
                                                return [
                                                    2,
                                                    factory
                                                ];
                                        }
                                    });
                                }).call(_this);
                            };
                            loading = asyncLoadProcess();
                            this.setShared({
                                pkgName: pkgName,
                                loaded: false,
                                shared: registeredShared,
                                from: host.options.name,
                                lib: null,
                                loading: loading
                            });
                            return [
                                2,
                                loading
                            ];
                        } else {
                            if (extraOptions == null ? void 0 : extraOptions.customShareInfo) {
                                return [
                                    2,
                                    false
                                ];
                            }
                            asyncLoadProcess1 = function() {
                                return _async_to_generator._(function() {
                                    var factory, gShared;
                                    return _ts_generator._(this, function(_state) {
                                        switch(_state.label){
                                            case 0:
                                                return [
                                                    4,
                                                    shareInfoRes.get()
                                                ];
                                            case 1:
                                                factory = _state.sent();
                                                shareInfoRes.lib = factory;
                                                shareInfoRes.loaded = true;
                                                addUseIn(shareInfoRes);
                                                gShared = share.getRegisteredShare(this.shareScopeMap, pkgName, shareInfoRes, this.hooks.lifecycle.resolveShare);
                                                if (gShared) {
                                                    gShared.lib = factory;
                                                    gShared.loaded = true;
                                                }
                                                return [
                                                    2,
                                                    factory
                                                ];
                                        }
                                    });
                                }).call(_this);
                            };
                            loading1 = asyncLoadProcess1();
                            this.setShared({
                                pkgName: pkgName,
                                loaded: false,
                                shared: shareInfoRes,
                                from: host.options.name,
                                lib: null,
                                loading: loading1
                            });
                            return [
                                2,
                                loading1
                            ];
                        }
                        _state.label = 7;
                    case 7:
                        return [
                            2
                        ];
                }
            });
        }).call(this);
    };
    /**
   * This function initializes the sharing sequence (executed only once per share scope).
   * It accepts one argument, the name of the share scope.
   * If the share scope does not exist, it creates one.
   */ // eslint-disable-next-line @typescript-eslint/member-ordering
    _proto.initializeSharing = function initializeSharing(shareScopeName, extraOptions) {
        if (shareScopeName === void 0) shareScopeName = share.DEFAULT_SCOPE;
        var host = this.host;
        var from = extraOptions == null ? void 0 : extraOptions.from;
        var strategy = extraOptions == null ? void 0 : extraOptions.strategy;
        var initScope = extraOptions == null ? void 0 : extraOptions.initScope;
        var promises = [];
        if (from !== 'build') {
            var initTokens = this.initTokens;
            if (!initScope) initScope = [];
            var initToken = initTokens[shareScopeName];
            if (!initToken) initToken = initTokens[shareScopeName] = {
                from: this.host.name
            };
            if (initScope.indexOf(initToken) >= 0) return promises;
            initScope.push(initToken);
        }
        var shareScope = this.shareScopeMap;
        var hostName = host.options.name;
        // Creates a new share scope if necessary
        if (!shareScope[shareScopeName]) {
            shareScope[shareScopeName] = {};
        }
        // Executes all initialization snippets from all accessible modules
        var scope = shareScope[shareScopeName];
        var register = function(name, shared) {
            var _activeVersion_shareConfig;
            var version = shared.version, eager = shared.eager;
            scope[name] = scope[name] || {};
            var versions = scope[name];
            var activeVersion = versions[version];
            var activeVersionEager = Boolean(activeVersion && (activeVersion.eager || ((_activeVersion_shareConfig = activeVersion.shareConfig) == null ? void 0 : _activeVersion_shareConfig.eager)));
            if (!activeVersion || activeVersion.strategy !== 'loaded-first' && !activeVersion.loaded && (Boolean(!eager) !== !activeVersionEager ? eager : hostName > activeVersion.from)) {
                versions[version] = shared;
            }
        };
        var initFn = function(mod) {
            return mod && mod.init && mod.init(shareScope[shareScopeName], initScope);
        };
        var initRemoteModule = function(key) {
            return _async_to_generator._(function() {
                var module, remoteEntryExports, error;
                return _ts_generator._(this, function(_state) {
                    switch(_state.label){
                        case 0:
                            return [
                                4,
                                host.remoteHandler.getRemoteModuleAndOptions({
                                    id: key
                                })
                            ];
                        case 1:
                            module = _state.sent().module;
                            if (!module.getEntry) return [
                                3,
                                8
                            ];
                            _state.label = 2;
                        case 2:
                            _state.trys.push([
                                2,
                                4,
                                ,
                                6
                            ]);
                            return [
                                4,
                                module.getEntry()
                            ];
                        case 3:
                            remoteEntryExports = _state.sent();
                            return [
                                3,
                                6
                            ];
                        case 4:
                            error = _state.sent();
                            return [
                                4,
                                host.remoteHandler.hooks.lifecycle.errorLoadRemote.emit({
                                    id: key,
                                    error: error,
                                    from: 'runtime',
                                    lifecycle: 'beforeLoadShare',
                                    origin: host
                                })
                            ];
                        case 5:
                            remoteEntryExports = _state.sent();
                            return [
                                3,
                                6
                            ];
                        case 6:
                            if (!!module.inited) return [
                                3,
                                8
                            ];
                            return [
                                4,
                                initFn(remoteEntryExports)
                            ];
                        case 7:
                            _state.sent();
                            module.inited = true;
                            _state.label = 8;
                        case 8:
                            return [
                                2
                            ];
                    }
                });
            })();
        };
        Object.keys(host.options.shared).forEach(function(shareName) {
            var sharedArr = host.options.shared[shareName];
            sharedArr.forEach(function(shared) {
                if (shared.scope.includes(shareScopeName)) {
                    register(shareName, shared);
                }
            });
        });
        // TODO: strategy==='version-first' need to be removed in the future
        if (host.options.shareStrategy === 'version-first' || strategy === 'version-first') {
            host.options.remotes.forEach(function(remote) {
                if (remote.shareScope === shareScopeName) {
                    promises.push(initRemoteModule(remote.name));
                }
            });
        }
        return promises;
    };
    // The lib function will only be available if the shared set by eager or runtime init is set or the shared is successfully loaded.
    // 1. If the loaded shared already exists globally, then it will be reused
    // 2. If lib exists in local shared, it will be used directly
    // 3. If the local get returns something other than Promise, then it will be used directly
    _proto.loadShareSync = function loadShareSync(pkgName, extraOptions) {
        var _this = this;
        var host = this.host;
        var shareInfo = share.getTargetSharedOptions({
            pkgName: pkgName,
            extraOptions: extraOptions,
            shareInfos: host.options.shared
        });
        if (shareInfo == null ? void 0 : shareInfo.scope) {
            shareInfo.scope.forEach(function(shareScope) {
                _this.initializeSharing(shareScope, {
                    strategy: shareInfo.strategy
                });
            });
        }
        var registeredShared = share.getRegisteredShare(this.shareScopeMap, pkgName, shareInfo, this.hooks.lifecycle.resolveShare);
        var addUseIn = function(shared) {
            if (!shared.useIn) {
                shared.useIn = [];
            }
            share.addUniqueItem(shared.useIn, host.options.name);
        };
        if (registeredShared) {
            if (typeof registeredShared.lib === 'function') {
                addUseIn(registeredShared);
                if (!registeredShared.loaded) {
                    registeredShared.loaded = true;
                    if (registeredShared.from === host.options.name) {
                        shareInfo.loaded = true;
                    }
                }
                return registeredShared.lib;
            }
            if (typeof registeredShared.get === 'function') {
                var module = registeredShared.get();
                if (!(module instanceof Promise)) {
                    addUseIn(registeredShared);
                    this.setShared({
                        pkgName: pkgName,
                        loaded: true,
                        from: host.options.name,
                        lib: module,
                        shared: registeredShared
                    });
                    return module;
                }
            }
        }
        if (shareInfo.lib) {
            if (!shareInfo.loaded) {
                shareInfo.loaded = true;
            }
            return shareInfo.lib;
        }
        if (shareInfo.get) {
            var module1 = shareInfo.get();
            if (module1 instanceof Promise) {
                throw new Error("\n        The loadShareSync function was unable to load " + pkgName + ". The " + pkgName + " could not be found in " + host.options.name + ".\n        Possible reasons for failure: \n\n        1. The " + pkgName + " share was registered with the 'get' attribute, but loadShare was not used beforehand.\n\n        2. The " + pkgName + " share was not registered with the 'lib' attribute.\n\n      ");
            }
            shareInfo.lib = module1;
            this.setShared({
                pkgName: pkgName,
                loaded: true,
                from: host.options.name,
                lib: shareInfo.lib,
                shared: shareInfo
            });
            return shareInfo.lib;
        }
        throw new Error("\n        The loadShareSync function was unable to load " + pkgName + ". The " + pkgName + " could not be found in " + host.options.name + ".\n        Possible reasons for failure: \n\n        1. The " + pkgName + " share was registered with the 'get' attribute, but loadShare was not used beforehand.\n\n        2. The " + pkgName + " share was not registered with the 'lib' attribute.\n\n      ");
    };
    _proto.initShareScopeMap = function initShareScopeMap(scopeName, shareScope, extraOptions) {
        if (extraOptions === void 0) extraOptions = {};
        var host = this.host;
        this.shareScopeMap[scopeName] = shareScope;
        this.hooks.lifecycle.initContainerShareScopeMap.emit({
            shareScope: shareScope,
            options: host.options,
            origin: host,
            scopeName: scopeName,
            hostShareScopeMap: extraOptions.hostShareScopeMap
        });
    };
    _proto.setShared = function setShared(param) {
        var _this = this;
        var pkgName = param.pkgName, shared = param.shared, from = param.from, lib = param.lib, loading = param.loading, loaded = param.loaded, get = param.get;
        var version = shared.version, _shared_scope = shared.scope, scope = _shared_scope === void 0 ? 'default' : _shared_scope, shareInfo = polyfills._object_without_properties_loose(shared, [
            "version",
            "scope"
        ]);
        var scopes = Array.isArray(scope) ? scope : [
            scope
        ];
        scopes.forEach(function(sc) {
            if (!_this.shareScopeMap[sc]) {
                _this.shareScopeMap[sc] = {};
            }
            if (!_this.shareScopeMap[sc][pkgName]) {
                _this.shareScopeMap[sc][pkgName] = {};
            }
            if (!_this.shareScopeMap[sc][pkgName][version]) {
                _this.shareScopeMap[sc][pkgName][version] = polyfills._extends({
                    version: version,
                    scope: [
                        'default'
                    ]
                }, shareInfo, {
                    lib: lib,
                    loaded: loaded,
                    loading: loading
                });
                if (get) {
                    _this.shareScopeMap[sc][pkgName][version].get = get;
                }
                return;
            }
            var registeredShared = _this.shareScopeMap[sc][pkgName][version];
            if (loading && !registeredShared.loading) {
                registeredShared.loading = loading;
            }
        });
    };
    _proto._setGlobalShareScopeMap = function _setGlobalShareScopeMap(hostOptions) {
        var globalShareScopeMap = share.getGlobalShareScope();
        var identifier = hostOptions.id || hostOptions.name;
        if (identifier && !globalShareScopeMap[identifier]) {
            globalShareScopeMap[identifier] = this.shareScopeMap;
        }
    };
    return SharedHandler;
}();
var RemoteHandler = /*#__PURE__*/ function() {
    function RemoteHandler(host) {
        this.hooks = new PluginSystem({
            beforeRegisterRemote: new SyncWaterfallHook('beforeRegisterRemote'),
            registerRemote: new SyncWaterfallHook('registerRemote'),
            beforeRequest: new AsyncWaterfallHook('beforeRequest'),
            onLoad: new AsyncHook('onLoad'),
            handlePreloadModule: new SyncHook('handlePreloadModule'),
            errorLoadRemote: new AsyncHook('errorLoadRemote'),
            beforePreloadRemote: new AsyncHook('beforePreloadRemote'),
            generatePreloadAssets: new AsyncHook('generatePreloadAssets'),
            // not used yet
            afterPreloadRemote: new AsyncHook(),
            loadEntry: new AsyncHook()
        });
        this.host = host;
        this.idToRemoteMap = {};
    }
    var _proto = RemoteHandler.prototype;
    _proto.formatAndRegisterRemote = function formatAndRegisterRemote(globalOptions, userOptions) {
        var _this = this;
        var userRemotes = userOptions.remotes || [];
        return userRemotes.reduce(function(res, remote) {
            _this.registerRemote(remote, res, {
                force: false
            });
            return res;
        }, globalOptions.remotes);
    };
    _proto.setIdToRemoteMap = function setIdToRemoteMap(id, remoteMatchInfo) {
        var remote = remoteMatchInfo.remote, expose = remoteMatchInfo.expose;
        var name = remote.name, alias = remote.alias;
        this.idToRemoteMap[id] = {
            name: remote.name,
            expose: expose
        };
        if (alias && id.startsWith(name)) {
            var idWithAlias = id.replace(name, alias);
            this.idToRemoteMap[idWithAlias] = {
                name: remote.name,
                expose: expose
            };
            return;
        }
        if (alias && id.startsWith(alias)) {
            var idWithName = id.replace(alias, name);
            this.idToRemoteMap[idWithName] = {
                name: remote.name,
                expose: expose
            };
        }
    };
    // eslint-disable-next-line max-lines-per-function
    // eslint-disable-next-line @typescript-eslint/member-ordering
    _proto.loadRemote = function loadRemote(id, options) {
        return _async_to_generator._(function() {
            var host, _ref, _ref_loadFactory, loadFactory, _ref1, module, moduleOptions, remoteMatchInfo, pkgNameOrAlias, remote, expose, idRes, remoteSnapshot, moduleOrFactory, moduleWrapper, error, _ref2, _ref_from, from, failOver;
            return _ts_generator._(this, function(_state) {
                switch(_state.label){
                    case 0:
                        host = this.host;
                        _state.label = 1;
                    case 1:
                        _state.trys.push([
                            1,
                            5,
                            ,
                            7
                        ]);
                        _ref = options || {
                            loadFactory: true
                        }, _ref_loadFactory = _ref.loadFactory, loadFactory = _ref_loadFactory === void 0 ? true : _ref_loadFactory;
                        return [
                            4,
                            this.getRemoteModuleAndOptions({
                                id: id
                            })
                        ];
                    case 2:
                        _ref1 = _state.sent(), module = _ref1.module, moduleOptions = _ref1.moduleOptions, remoteMatchInfo = _ref1.remoteMatchInfo;
                        pkgNameOrAlias = remoteMatchInfo.pkgNameOrAlias, remote = remoteMatchInfo.remote, expose = remoteMatchInfo.expose, idRes = remoteMatchInfo.id, remoteSnapshot = remoteMatchInfo.remoteSnapshot;
                        return [
                            4,
                            module.get(idRes, expose, options, remoteSnapshot)
                        ];
                    case 3:
                        moduleOrFactory = _state.sent();
                        return [
                            4,
                            this.hooks.lifecycle.onLoad.emit({
                                id: idRes,
                                pkgNameOrAlias: pkgNameOrAlias,
                                expose: expose,
                                exposeModule: loadFactory ? moduleOrFactory : undefined,
                                exposeModuleFactory: loadFactory ? undefined : moduleOrFactory,
                                remote: remote,
                                options: moduleOptions,
                                moduleInstance: module,
                                origin: host
                            })
                        ];
                    case 4:
                        moduleWrapper = _state.sent();
                        this.setIdToRemoteMap(id, remoteMatchInfo);
                        if (typeof moduleWrapper === 'function') {
                            return [
                                2,
                                moduleWrapper
                            ];
                        }
                        return [
                            2,
                            moduleOrFactory
                        ];
                    case 5:
                        error = _state.sent();
                        _ref2 = options || {
                            from: 'runtime'
                        }, _ref_from = _ref2.from, from = _ref_from === void 0 ? 'runtime' : _ref_from;
                        return [
                            4,
                            this.hooks.lifecycle.errorLoadRemote.emit({
                                id: id,
                                error: error,
                                from: from,
                                lifecycle: 'onLoad',
                                origin: host
                            })
                        ];
                    case 6:
                        failOver = _state.sent();
                        if (!failOver) {
                            throw error;
                        }
                        return [
                            2,
                            failOver
                        ];
                    case 7:
                        return [
                            2
                        ];
                }
            });
        }).call(this);
    };
    // eslint-disable-next-line @typescript-eslint/member-ordering
    _proto.preloadRemote = function preloadRemote(preloadOptions) {
        return _async_to_generator._(function() {
            var _this, host, preloadOps;
            return _ts_generator._(this, function(_state) {
                switch(_state.label){
                    case 0:
                        _this = this;
                        host = this.host;
                        return [
                            4,
                            this.hooks.lifecycle.beforePreloadRemote.emit({
                                preloadOps: preloadOptions,
                                options: host.options,
                                origin: host
                            })
                        ];
                    case 1:
                        _state.sent();
                        preloadOps = formatPreloadArgs(host.options.remotes, preloadOptions);
                        return [
                            4,
                            Promise.all(preloadOps.map(function(ops) {
                                return _async_to_generator._(function() {
                                    var remote, remoteInfo, _ref, globalSnapshot, remoteSnapshot, assets;
                                    return _ts_generator._(this, function(_state) {
                                        switch(_state.label){
                                            case 0:
                                                remote = ops.remote;
                                                remoteInfo = getRemoteInfo(remote);
                                                return [
                                                    4,
                                                    host.snapshotHandler.loadRemoteSnapshotInfo(remote)
                                                ];
                                            case 1:
                                                _ref = _state.sent(), globalSnapshot = _ref.globalSnapshot, remoteSnapshot = _ref.remoteSnapshot;
                                                return [
                                                    4,
                                                    this.hooks.lifecycle.generatePreloadAssets.emit({
                                                        origin: host,
                                                        preloadOptions: ops,
                                                        remote: remote,
                                                        remoteInfo: remoteInfo,
                                                        globalSnapshot: globalSnapshot,
                                                        remoteSnapshot: remoteSnapshot
                                                    })
                                                ];
                                            case 2:
                                                assets = _state.sent();
                                                if (!assets) {
                                                    return [
                                                        2
                                                    ];
                                                }
                                                preloadAssets(remoteInfo, host, assets);
                                                return [
                                                    2
                                                ];
                                        }
                                    });
                                }).call(_this);
                            }))
                        ];
                    case 2:
                        _state.sent();
                        return [
                            2
                        ];
                }
            });
        }).call(this);
    };
    _proto.registerRemotes = function registerRemotes(remotes, options) {
        var _this = this;
        var host = this.host;
        remotes.forEach(function(remote) {
            _this.registerRemote(remote, host.options.remotes, {
                force: options == null ? void 0 : options.force
            });
        });
    };
    _proto.getRemoteModuleAndOptions = function getRemoteModuleAndOptions(options) {
        return _async_to_generator._(function() {
            var host, id, loadRemoteArgs, error, idRes, remoteSplitInfo, rawRemote, remoteInfo, matchInfo, remote, expose, module, moduleOptions;
            return _ts_generator._(this, function(_state) {
                switch(_state.label){
                    case 0:
                        host = this.host;
                        id = options.id;
                        _state.label = 1;
                    case 1:
                        _state.trys.push([
                            1,
                            3,
                            ,
                            5
                        ]);
                        return [
                            4,
                            this.hooks.lifecycle.beforeRequest.emit({
                                id: id,
                                options: host.options,
                                origin: host
                            })
                        ];
                    case 2:
                        loadRemoteArgs = _state.sent();
                        return [
                            3,
                            5
                        ];
                    case 3:
                        error = _state.sent();
                        return [
                            4,
                            this.hooks.lifecycle.errorLoadRemote.emit({
                                id: id,
                                options: host.options,
                                origin: host,
                                from: 'runtime',
                                error: error,
                                lifecycle: 'beforeRequest'
                            })
                        ];
                    case 4:
                        loadRemoteArgs = _state.sent();
                        if (!loadRemoteArgs) {
                            throw error;
                        }
                        return [
                            3,
                            5
                        ];
                    case 5:
                        idRes = loadRemoteArgs.id;
                        remoteSplitInfo = matchRemoteWithNameAndExpose(host.options.remotes, idRes);
                        share.assert(remoteSplitInfo, "\n        Unable to locate " + idRes + " in " + host.options.name + ". Potential reasons for failure include:\n\n        1. " + idRes + " was not included in the 'remotes' parameter of " + (host.options.name || 'the host') + ".\n\n        2. " + idRes + " could not be found in the 'remotes' of " + host.options.name + " with either 'name' or 'alias' attributes.\n        3. " + idRes + " is not online, injected, or loaded.\n        4. " + idRes + "  cannot be accessed on the expected.\n        5. The 'beforeRequest' hook was provided but did not return the correct 'remoteInfo' when attempting to load " + idRes + ".\n      ");
                        rawRemote = remoteSplitInfo.remote;
                        remoteInfo = getRemoteInfo(rawRemote);
                        return [
                            4,
                            host.sharedHandler.hooks.lifecycle.afterResolve.emit(polyfills._extends({
                                id: idRes
                            }, remoteSplitInfo, {
                                options: host.options,
                                origin: host,
                                remoteInfo: remoteInfo
                            }))
                        ];
                    case 6:
                        matchInfo = _state.sent();
                        remote = matchInfo.remote, expose = matchInfo.expose;
                        share.assert(remote && expose, "The 'beforeRequest' hook was executed, but it failed to return the correct 'remote' and 'expose' values while loading " + idRes + ".");
                        module = host.moduleCache.get(remote.name);
                        moduleOptions = {
                            host: host,
                            remoteInfo: remoteInfo
                        };
                        if (!module) {
                            module = new Module(moduleOptions);
                            host.moduleCache.set(remote.name, module);
                        }
                        return [
                            2,
                            {
                                module: module,
                                moduleOptions: moduleOptions,
                                remoteMatchInfo: matchInfo
                            }
                        ];
                }
            });
        }).call(this);
    };
    _proto.registerRemote = function registerRemote(remote, targetRemotes, options) {
        var host = this.host;
        var normalizeRemote = function() {
            if (remote.alias) {
                // Validate if alias equals the prefix of remote.name and remote.alias, if so, throw an error
                // As multi-level path references cannot guarantee unique names, alias being a prefix of remote.name is not supported
                var findEqual = targetRemotes.find(function(item) {
                    var _item_alias;
                    return remote.alias && (item.name.startsWith(remote.alias) || ((_item_alias = item.alias) == null ? void 0 : _item_alias.startsWith(remote.alias)));
                });
                share.assert(!findEqual, "The alias " + remote.alias + " of remote " + remote.name + " is not allowed to be the prefix of " + (findEqual && findEqual.name) + " name or alias");
            }
            // Set the remote entry to a complete path
            if ('entry' in remote) {
                if (sdk.isBrowserEnv() && !remote.entry.startsWith('http')) {
                    remote.entry = new URL(remote.entry, window.location.origin).href;
                }
            }
            if (!remote.shareScope) {
                remote.shareScope = share.DEFAULT_SCOPE;
            }
            if (!remote.type) {
                remote.type = share.DEFAULT_REMOTE_TYPE;
            }
        };
        this.hooks.lifecycle.beforeRegisterRemote.emit({
            remote: remote,
            origin: host
        });
        var registeredRemote = targetRemotes.find(function(item) {
            return item.name === remote.name;
        });
        if (!registeredRemote) {
            normalizeRemote();
            targetRemotes.push(remote);
            this.hooks.lifecycle.registerRemote.emit({
                remote: remote,
                origin: host
            });
        } else {
            var messages = [
                'The remote "' + remote.name + '" is already registered.',
                (options == null ? void 0 : options.force) ? 'Hope you have known that OVERRIDE it may have some unexpected errors' : 'If you want to merge the remote, you can set "force: true".'
            ];
            if (options == null ? void 0 : options.force) {
                // remove registered remote
                this.removeRemote(registeredRemote);
                normalizeRemote();
                targetRemotes.push(remote);
                this.hooks.lifecycle.registerRemote.emit({
                    remote: remote,
                    origin: host
                });
            }
            sdk.warn(messages.join(' '));
        }
    };
    _proto.removeRemote = function removeRemote(remote) {
        try {
            var host = this.host;
            var name = remote.name;
            var remoteIndex = host.options.remotes.findIndex(function(item) {
                return item.name === name;
            });
            if (remoteIndex !== -1) {
                host.options.remotes.splice(remoteIndex, 1);
            }
            var loadedModule = host.moduleCache.get(remote.name);
            if (loadedModule) {
                var remoteInfo = loadedModule.remoteInfo;
                var key = remoteInfo.entryGlobalName;
                if (globalThis[key]) {
                    var _Object_getOwnPropertyDescriptor;
                    if ((_Object_getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor(globalThis, key)) == null ? void 0 : _Object_getOwnPropertyDescriptor.configurable) {
                        delete globalThis[key];
                    } else {
                        // @ts-ignore
                        globalThis[key] = undefined;
                    }
                }
                var remoteEntryUniqueKey = getRemoteEntryUniqueKey(loadedModule.remoteInfo);
                if (share.globalLoading[remoteEntryUniqueKey]) {
                    delete share.globalLoading[remoteEntryUniqueKey];
                }
                host.snapshotHandler.manifestCache["delete"](remoteInfo.entry);
                // delete unloaded shared and instance
                var remoteInsId = remoteInfo.buildVersion ? sdk.composeKeyWithSeparator(remoteInfo.name, remoteInfo.buildVersion) : remoteInfo.name;
                var remoteInsIndex = globalThis.__FEDERATION__.__INSTANCES__.findIndex(function(ins) {
                    if (remoteInfo.buildVersion) {
                        return ins.options.id === remoteInsId;
                    } else {
                        return ins.name === remoteInsId;
                    }
                });
                if (remoteInsIndex !== -1) {
                    var remoteIns = globalThis.__FEDERATION__.__INSTANCES__[remoteInsIndex];
                    remoteInsId = remoteIns.options.id || remoteInsId;
                    var globalShareScopeMap = share.getGlobalShareScope();
                    var isAllSharedNotUsed = true;
                    var needDeleteKeys = [];
                    Object.keys(globalShareScopeMap).forEach(function(instId) {
                        var shareScopeMap = globalShareScopeMap[instId];
                        shareScopeMap && Object.keys(shareScopeMap).forEach(function(shareScope) {
                            var shareScopeVal = shareScopeMap[shareScope];
                            shareScopeVal && Object.keys(shareScopeVal).forEach(function(shareName) {
                                var sharedPkgs = shareScopeVal[shareName];
                                sharedPkgs && Object.keys(sharedPkgs).forEach(function(shareVersion) {
                                    var shared = sharedPkgs[shareVersion];
                                    if (shared && (typeof shared === "undefined" ? "undefined" : _type_of._(shared)) === 'object' && shared.from === remoteInfo.name) {
                                        if (shared.loaded || shared.loading) {
                                            shared.useIn = shared.useIn.filter(function(usedHostName) {
                                                return usedHostName !== remoteInfo.name;
                                            });
                                            if (shared.useIn.length) {
                                                isAllSharedNotUsed = false;
                                            } else {
                                                needDeleteKeys.push([
                                                    instId,
                                                    shareScope,
                                                    shareName,
                                                    shareVersion
                                                ]);
                                            }
                                        } else {
                                            needDeleteKeys.push([
                                                instId,
                                                shareScope,
                                                shareName,
                                                shareVersion
                                            ]);
                                        }
                                    }
                                });
                            });
                        });
                    });
                    if (isAllSharedNotUsed) {
                        remoteIns.shareScopeMap = {};
                        delete globalShareScopeMap[remoteInsId];
                    }
                    needDeleteKeys.forEach(function(param) {
                        var _param = _sliced_to_array._(param, 4), insId = _param[0], shareScope = _param[1], shareName = _param[2], shareVersion = _param[3];
                        var _globalShareScopeMap_insId_shareScope_shareName, _globalShareScopeMap_insId_shareScope, _globalShareScopeMap_insId;
                        (_globalShareScopeMap_insId = globalShareScopeMap[insId]) == null ? true : (_globalShareScopeMap_insId_shareScope = _globalShareScopeMap_insId[shareScope]) == null ? true : (_globalShareScopeMap_insId_shareScope_shareName = _globalShareScopeMap_insId_shareScope[shareName]) == null ? true : delete _globalShareScopeMap_insId_shareScope_shareName[shareVersion];
                    });
                    globalThis.__FEDERATION__.__INSTANCES__.splice(remoteInsIndex, 1);
                }
                var hostGlobalSnapshot = getGlobalRemoteInfo(remote, host).hostGlobalSnapshot;
                if (hostGlobalSnapshot) {
                    var remoteKey = hostGlobalSnapshot && 'remotesInfo' in hostGlobalSnapshot && hostGlobalSnapshot.remotesInfo && share.getInfoWithoutType(hostGlobalSnapshot.remotesInfo, remote.name).key;
                    if (remoteKey) {
                        delete hostGlobalSnapshot.remotesInfo[remoteKey];
                        if (Boolean(share.Global.__FEDERATION__.__MANIFEST_LOADING__[remoteKey])) {
                            delete share.Global.__FEDERATION__.__MANIFEST_LOADING__[remoteKey];
                        }
                    }
                }
                host.moduleCache["delete"](remote.name);
            }
        } catch (err) {
            console.log('removeRemote fail: ', err);
        }
    };
    return RemoteHandler;
}();
var FederationHost = /*#__PURE__*/ function() {
    function FederationHost(userOptions) {
        this.hooks = new PluginSystem({
            beforeInit: new SyncWaterfallHook('beforeInit'),
            init: new SyncHook(),
            // maybe will change, temporarily for internal use only
            beforeInitContainer: new AsyncWaterfallHook('beforeInitContainer'),
            // maybe will change, temporarily for internal use only
            initContainer: new AsyncWaterfallHook('initContainer')
        });
        this.version = "0.6.13";
        this.moduleCache = new Map();
        this.loaderHook = new PluginSystem({
            // FIXME: may not be suitable , not open to the public yet
            getModuleInfo: new SyncHook(),
            createScript: new SyncHook(),
            createLink: new SyncHook(),
            // only work for manifest , so not open to the public yet
            fetch: new AsyncHook()
        });
        // TODO: Validate the details of the options
        // Initialize options with default values
        var defaultOptions = {
            id: share.getBuilderId(),
            name: userOptions.name,
            plugins: [
                snapshotPlugin(),
                generatePreloadAssetsPlugin()
            ],
            remotes: [],
            shared: {},
            inBrowser: sdk.isBrowserEnv()
        };
        this.name = userOptions.name;
        this.options = defaultOptions;
        this.snapshotHandler = new SnapshotHandler(this);
        this.sharedHandler = new SharedHandler(this);
        this.remoteHandler = new RemoteHandler(this);
        this.shareScopeMap = this.sharedHandler.shareScopeMap;
        this.registerPlugins(_to_consumable_array._(defaultOptions.plugins).concat(_to_consumable_array._(userOptions.plugins || [])));
        this.options = this.formatOptions(defaultOptions, userOptions);
    }
    var _proto = FederationHost.prototype;
    _proto.initOptions = function initOptions(userOptions) {
        this.registerPlugins(userOptions.plugins);
        var options = this.formatOptions(this.options, userOptions);
        this.options = options;
        return options;
    };
    _proto.loadShare = function loadShare(pkgName, extraOptions) {
        return _async_to_generator._(function() {
            return _ts_generator._(this, function(_state) {
                return [
                    2,
                    this.sharedHandler.loadShare(pkgName, extraOptions)
                ];
            });
        }).call(this);
    };
    // The lib function will only be available if the shared set by eager or runtime init is set or the shared is successfully loaded.
    // 1. If the loaded shared already exists globally, then it will be reused
    // 2. If lib exists in local shared, it will be used directly
    // 3. If the local get returns something other than Promise, then it will be used directly
    _proto.loadShareSync = function loadShareSync(pkgName, extraOptions) {
        return this.sharedHandler.loadShareSync(pkgName, extraOptions);
    };
    _proto.initializeSharing = function initializeSharing(shareScopeName, extraOptions) {
        if (shareScopeName === void 0) shareScopeName = share.DEFAULT_SCOPE;
        return this.sharedHandler.initializeSharing(shareScopeName, extraOptions);
    };
    _proto.initRawContainer = function initRawContainer(name, url, container) {
        var remoteInfo = getRemoteInfo({
            name: name,
            entry: url
        });
        var module = new Module({
            host: this,
            remoteInfo: remoteInfo
        });
        module.remoteEntryExports = container;
        this.moduleCache.set(name, module);
        return module;
    };
    // eslint-disable-next-line max-lines-per-function
    // eslint-disable-next-line @typescript-eslint/member-ordering
    _proto.loadRemote = function loadRemote(id, options) {
        return _async_to_generator._(function() {
            return _ts_generator._(this, function(_state) {
                return [
                    2,
                    this.remoteHandler.loadRemote(id, options)
                ];
            });
        }).call(this);
    };
    // eslint-disable-next-line @typescript-eslint/member-ordering
    _proto.preloadRemote = function preloadRemote(preloadOptions) {
        return _async_to_generator._(function() {
            return _ts_generator._(this, function(_state) {
                return [
                    2,
                    this.remoteHandler.preloadRemote(preloadOptions)
                ];
            });
        }).call(this);
    };
    _proto.initShareScopeMap = function initShareScopeMap(scopeName, shareScope, extraOptions) {
        if (extraOptions === void 0) extraOptions = {};
        this.sharedHandler.initShareScopeMap(scopeName, shareScope, extraOptions);
    };
    _proto.formatOptions = function formatOptions(globalOptions, userOptions) {
        var shared = share.formatShareConfigs(globalOptions, userOptions).shared;
        var _this_hooks_lifecycle_beforeInit_emit = this.hooks.lifecycle.beforeInit.emit({
            origin: this,
            userOptions: userOptions,
            options: globalOptions,
            shareInfo: shared
        }), userOptionsRes = _this_hooks_lifecycle_beforeInit_emit.userOptions, globalOptionsRes = _this_hooks_lifecycle_beforeInit_emit.options;
        var remotes = this.remoteHandler.formatAndRegisterRemote(globalOptionsRes, userOptionsRes);
        var _this_sharedHandler_registerShared = this.sharedHandler.registerShared(globalOptionsRes, userOptionsRes), handledShared = _this_sharedHandler_registerShared.shared;
        var plugins = _to_consumable_array._(globalOptionsRes.plugins);
        if (userOptionsRes.plugins) {
            userOptionsRes.plugins.forEach(function(plugin) {
                if (!plugins.includes(plugin)) {
                    plugins.push(plugin);
                }
            });
        }
        var optionsRes = polyfills._extends({}, globalOptions, userOptions, {
            plugins: plugins,
            remotes: remotes,
            shared: handledShared
        });
        this.hooks.lifecycle.init.emit({
            origin: this,
            options: optionsRes
        });
        return optionsRes;
    };
    _proto.registerPlugins = function registerPlugins(plugins) {
        var pluginRes = registerPlugins$1(plugins, [
            this.hooks,
            this.remoteHandler.hooks,
            this.sharedHandler.hooks,
            this.snapshotHandler.hooks,
            this.loaderHook
        ]);
        // Merge plugin
        this.options.plugins = this.options.plugins.reduce(function(res, plugin) {
            if (!plugin) return res;
            if (res && !res.find(function(item) {
                return item.name === plugin.name;
            })) {
                res.push(plugin);
            }
            return res;
        }, pluginRes || []);
    };
    _proto.registerRemotes = function registerRemotes(remotes, options) {
        return this.remoteHandler.registerRemotes(remotes, options);
    };
    return FederationHost;
}();
var FederationInstance = null;
function init(options) {
    // Retrieve the same instance with the same name
    var instance = share.getGlobalFederationInstance(options.name, options.version);
    if (!instance) {
        // Retrieve debug constructor
        var FederationConstructor = share.getGlobalFederationConstructor() || FederationHost;
        FederationInstance = new FederationConstructor(options);
        share.setGlobalFederationInstance(FederationInstance);
        return FederationInstance;
    } else {
        // Merge options
        instance.initOptions(options);
        if (!FederationInstance) {
            FederationInstance = instance;
        }
        return instance;
    }
}
function loadRemote() {
    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
        args[_key] = arguments[_key];
    }
    share.assert(FederationInstance, 'Please call init first');
    var loadRemote1 = FederationInstance.loadRemote;
    // eslint-disable-next-line prefer-spread
    return loadRemote1.apply(FederationInstance, args);
}
function loadShare() {
    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
        args[_key] = arguments[_key];
    }
    share.assert(FederationInstance, 'Please call init first');
    // eslint-disable-next-line prefer-spread
    var loadShare1 = FederationInstance.loadShare;
    return loadShare1.apply(FederationInstance, args);
}
function loadShareSync() {
    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
        args[_key] = arguments[_key];
    }
    share.assert(FederationInstance, 'Please call init first');
    var loadShareSync1 = FederationInstance.loadShareSync;
    // eslint-disable-next-line prefer-spread
    return loadShareSync1.apply(FederationInstance, args);
}
function preloadRemote() {
    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
        args[_key] = arguments[_key];
    }
    share.assert(FederationInstance, 'Please call init first');
    // eslint-disable-next-line prefer-spread
    return FederationInstance.preloadRemote.apply(FederationInstance, args);
}
function registerRemotes() {
    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
        args[_key] = arguments[_key];
    }
    share.assert(FederationInstance, 'Please call init first');
    // eslint-disable-next-line prefer-spread
    return FederationInstance.registerRemotes.apply(FederationInstance, args);
}
function registerPlugins() {
    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
        args[_key] = arguments[_key];
    }
    share.assert(FederationInstance, 'Please call init first');
    // eslint-disable-next-line prefer-spread
    return FederationInstance.registerPlugins.apply(FederationInstance, args);
}
function getInstance() {
    return FederationInstance;
}
// Inject for debug
share.setGlobalFederationConstructor(FederationHost);
Object.defineProperty(exports, "loadScript", ({
    enumerable: true,
    get: function get() {
        return sdk.loadScript;
    }
}));
Object.defineProperty(exports, "loadScriptNode", ({
    enumerable: true,
    get: function get() {
        return sdk.loadScriptNode;
    }
}));
exports.registerGlobalPlugins = share.registerGlobalPlugins;
exports.FederationHost = FederationHost;
exports.Module = Module;
exports.getInstance = getInstance;
exports.getRemoteEntry = getRemoteEntry;
exports.getRemoteInfo = getRemoteInfo;
exports.init = init;
exports.loadRemote = loadRemote;
exports.loadShare = loadShare;
exports.loadShareSync = loadShareSync;
exports.preloadRemote = preloadRemote;
exports.registerPlugins = registerPlugins;
exports.registerRemotes = registerRemotes;


}),
5303: (function (__unused_webpack_module, exports) {
"use strict";

function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else obj[key] = value;
    return obj;
}
exports._ = _define_property;


}),
53986: (function (__unused_webpack_module, exports) {
"use strict";

function _iterable_to_array_limit(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){
            _arr.push(_s.value);
            if (i && _arr.length === i) break;
        }
    } catch (err) {
        _d = true;
        _e = err;
    } finally{
        try {
            if (!_n && _i["return"] != null) _i["return"]();
        } finally{
            if (_d) throw _e;
        }
    }
    return _arr;
}
exports._ = _iterable_to_array_limit;


}),
55581: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get NormalizedScriptLocatorHTTPMethod () {
        return NormalizedScriptLocatorHTTPMethod;
    },
    get NormalizedScriptLocatorSignatureVerificationMode () {
        return NormalizedScriptLocatorSignatureVerificationMode;
    },
    get default () {
        return _default;
    }
});
var _reactnative = __webpack_require__(64598);
var NormalizedScriptLocatorHTTPMethod = function(NormalizedScriptLocatorHTTPMethod) {
    NormalizedScriptLocatorHTTPMethod["GET"] = "GET";
    NormalizedScriptLocatorHTTPMethod["POST"] = "POST";
    return NormalizedScriptLocatorHTTPMethod;
}({});
var NormalizedScriptLocatorSignatureVerificationMode = function(NormalizedScriptLocatorSignatureVerificationMode) {
    NormalizedScriptLocatorSignatureVerificationMode["STRICT"] = "strict";
    NormalizedScriptLocatorSignatureVerificationMode["LAX"] = "lax";
    NormalizedScriptLocatorSignatureVerificationMode["OFF"] = "off";
    return NormalizedScriptLocatorSignatureVerificationMode;
}({});
var _default = _reactnative.TurboModuleRegistry.get('ScriptManager');


}),
58506: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _async_to_generator = __webpack_require__(37297);
var _define_property = __webpack_require__(5303);
var _sliced_to_array = __webpack_require__(21193);
var _to_array = __webpack_require__(1259);
var _to_consumable_array = __webpack_require__(8034);
var _type_of = __webpack_require__(29936);
var _ts_generator = __webpack_require__(63563);
var polyfills = __webpack_require__(64488);
var FederationModuleManifest = 'federation-manifest.json';
var MANIFEST_EXT = '.json';
var BROWSER_LOG_KEY = 'FEDERATION_DEBUG';
var BROWSER_LOG_VALUE = '1';
var NameTransformSymbol = {
    AT: '@',
    HYPHEN: '-',
    SLASH: '/'
};
var _obj;
var NameTransformMap = (_obj = {}, _define_property._(_obj, NameTransformSymbol.AT, 'scope_'), _define_property._(_obj, NameTransformSymbol.HYPHEN, '_'), _define_property._(_obj, NameTransformSymbol.SLASH, '__'), _obj);
var _obj1;
var EncodedNameTransformMap = (_obj1 = {}, _define_property._(_obj1, NameTransformMap[NameTransformSymbol.AT], NameTransformSymbol.AT), _define_property._(_obj1, NameTransformMap[NameTransformSymbol.HYPHEN], NameTransformSymbol.HYPHEN), _define_property._(_obj1, NameTransformMap[NameTransformSymbol.SLASH], NameTransformSymbol.SLASH), _obj1);
var SEPARATOR = ':';
var ManifestFileName = 'mf-manifest.json';
var StatsFileName = 'mf-stats.json';
var MFModuleType = {
    NPM: 'npm',
    APP: 'app'
};
var MODULE_DEVTOOL_IDENTIFIER = '__MF_DEVTOOLS_MODULE_INFO__';
var ENCODE_NAME_PREFIX = 'ENCODE_NAME_PREFIX';
var TEMP_DIR = '.federation';
var MFPrefetchCommon = {
    identifier: 'MFDataPrefetch',
    globalKey: '__PREFETCH__',
    library: 'mf-data-prefetch',
    exportsKey: '__PREFETCH_EXPORTS__',
    fileName: 'bootstrap.js'
};
var ContainerPlugin = /*#__PURE__*/ Object.freeze({
    __proto__: null
});
var ContainerReferencePlugin = /*#__PURE__*/ Object.freeze({
    __proto__: null
});
var ModuleFederationPlugin = /*#__PURE__*/ Object.freeze({
    __proto__: null
});
var SharePlugin = /*#__PURE__*/ Object.freeze({
    __proto__: null
});
function isBrowserEnv() {
    return typeof window !== 'undefined';
}
function isDebugMode() {
    if (typeof process !== 'undefined' && process.env && process.env['FEDERATION_DEBUG']) {
        return Boolean(process.env['FEDERATION_DEBUG']);
    }
    return typeof FEDERATION_DEBUG !== 'undefined' && Boolean(FEDERATION_DEBUG);
}
var getProcessEnv = function getProcessEnv1() {
    return typeof process !== 'undefined' && process.env ? process.env : {};
};
var DEBUG_LOG = '[ FEDERATION DEBUG ]';
function safeToString$1(info) {
    try {
        return JSON.stringify(info, null, 2);
    } catch (e) {
        return '';
    }
}
function safeGetLocalStorageItem() {
    try {
        if (typeof window !== 'undefined' && window.localStorage) {
            return localStorage.getItem(BROWSER_LOG_KEY) === BROWSER_LOG_VALUE;
        }
    } catch (error1) {
        return typeof document !== 'undefined';
    }
    return false;
}
var Logger = /*#__PURE__*/ function() {
    function Logger1(identifier) {
        this.enable = false;
        this.identifier = identifier || DEBUG_LOG;
        if (isBrowserEnv() && safeGetLocalStorageItem()) {
            this.enable = true;
        } else if (isDebugMode()) {
            this.enable = true;
        }
    }
    var _proto = Logger1.prototype;
    _proto.info = function info(msg, info) {
        if (this.enable) {
            var argsToString = safeToString$1(info) || '';
            if (isBrowserEnv()) {
                console.info("%c " + this.identifier + ": " + msg + " " + argsToString, 'color:#3300CC');
            } else {
                console.info('\x1b[34m%s', this.identifier + ": " + msg + " " + (argsToString ? "\n" + argsToString : ''));
            }
        }
    };
    _proto.logOriginalInfo = function logOriginalInfo() {
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        if (this.enable) {
            if (isBrowserEnv()) {
                var _console;
                console.info("%c " + this.identifier + ": OriginalInfo", 'color:#3300CC');
                (_console = console).log.apply(_console, _to_consumable_array._(args));
            } else {
                var _console1;
                console.info("%c " + this.identifier + ": OriginalInfo", 'color:#3300CC');
                (_console1 = console).log.apply(_console1, _to_consumable_array._(args));
            }
        }
    };
    return Logger1;
}();
var LOG_CATEGORY = '[ Federation Runtime ]';
// entry: name:version   version : 1.0.0 | ^1.2.3
// entry: name:entry  entry:  https://localhost:9000/federation-manifest.json
var parseEntry = function(str, devVerOrUrl, separator) {
    if (separator === void 0) separator = SEPARATOR;
    var strSplit = str.split(separator);
    var devVersionOrUrl = getProcessEnv()['NODE_ENV'] === 'development' && devVerOrUrl;
    var defaultVersion = '*';
    var isEntry = function(s) {
        return s.startsWith('http') || s.includes(MANIFEST_EXT);
    };
    // Check if the string starts with a type
    if (strSplit.length >= 2) {
        var _strSplit = _to_array._(strSplit), name = _strSplit[0], versionOrEntryArr = _strSplit.slice(1);
        if (str.startsWith(separator)) {
            versionOrEntryArr = [
                devVersionOrUrl || strSplit.slice(-1)[0]
            ];
            name = strSplit.slice(0, -1).join(separator);
        }
        var versionOrEntry = devVersionOrUrl || versionOrEntryArr.join(separator);
        if (isEntry(versionOrEntry)) {
            return {
                name: name,
                entry: versionOrEntry
            };
        } else {
            // Apply version rule
            // devVersionOrUrl => inputVersion => defaultVersion
            return {
                name: name,
                version: versionOrEntry || defaultVersion
            };
        }
    } else if (strSplit.length === 1) {
        var _strSplit1 = _sliced_to_array._(strSplit, 1), name1 = _strSplit1[0];
        if (devVersionOrUrl && isEntry(devVersionOrUrl)) {
            return {
                name: name1,
                entry: devVersionOrUrl
            };
        }
        return {
            name: name1,
            version: devVersionOrUrl || defaultVersion
        };
    } else {
        throw "Invalid entry value: " + str;
    }
};
var logger = new Logger();
var composeKeyWithSeparator = function composeKeyWithSeparator1() {
    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
        args[_key] = arguments[_key];
    }
    if (!args.length) {
        return '';
    }
    return args.reduce(function(sum, cur) {
        if (!cur) {
            return sum;
        }
        if (!sum) {
            return cur;
        }
        return "" + sum + SEPARATOR + cur;
    }, '');
};
var encodeName = function encodeName1(name, prefix, withExt) {
    if (prefix === void 0) prefix = '';
    if (withExt === void 0) withExt = false;
    try {
        var ext = withExt ? '.js' : '';
        return "" + prefix + name.replace(new RegExp("" + NameTransformSymbol.AT, 'g'), NameTransformMap[NameTransformSymbol.AT]).replace(new RegExp("" + NameTransformSymbol.HYPHEN, 'g'), NameTransformMap[NameTransformSymbol.HYPHEN]).replace(new RegExp("" + NameTransformSymbol.SLASH, 'g'), NameTransformMap[NameTransformSymbol.SLASH]) + ext;
    } catch (err) {
        throw err;
    }
};
var decodeName = function decodeName1(name, prefix, withExt) {
    try {
        var decodedName = name;
        if (prefix) {
            if (!decodedName.startsWith(prefix)) {
                return decodedName;
            }
            decodedName = decodedName.replace(new RegExp(prefix, 'g'), '');
        }
        decodedName = decodedName.replace(new RegExp("" + NameTransformMap[NameTransformSymbol.AT], 'g'), EncodedNameTransformMap[NameTransformMap[NameTransformSymbol.AT]]).replace(new RegExp("" + NameTransformMap[NameTransformSymbol.SLASH], 'g'), EncodedNameTransformMap[NameTransformMap[NameTransformSymbol.SLASH]]).replace(new RegExp("" + NameTransformMap[NameTransformSymbol.HYPHEN], 'g'), EncodedNameTransformMap[NameTransformMap[NameTransformSymbol.HYPHEN]]);
        if (withExt) {
            decodedName = decodedName.replace('.js', '');
        }
        return decodedName;
    } catch (err) {
        throw err;
    }
};
var generateExposeFilename = function(exposeName, withExt) {
    if (!exposeName) {
        return '';
    }
    var expose = exposeName;
    if (expose === '.') {
        expose = 'default_export';
    }
    if (expose.startsWith('./')) {
        expose = expose.replace('./', '');
    }
    return encodeName(expose, '__federation_expose_', withExt);
};
var generateShareFilename = function(pkgName, withExt) {
    if (!pkgName) {
        return '';
    }
    return encodeName(pkgName, '__federation_shared_', withExt);
};
var getResourceUrl = function(module, sourceUrl) {
    if ('getPublicPath' in module) {
        var publicPath;
        if (!module.getPublicPath.startsWith('function')) {
            publicPath = new Function(module.getPublicPath)();
        } else {
            publicPath = new Function('return ' + module.getPublicPath)()();
        }
        return "" + publicPath + sourceUrl;
    } else if ('publicPath' in module) {
        return "" + module.publicPath + sourceUrl;
    } else {
        console.warn('Cannot get resource URL. If in debug mode, please ignore.', module, sourceUrl);
        return '';
    }
};
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
var assert = function(condition, msg) {
    if (!condition) {
        error(msg);
    }
};
var error = function(msg) {
    throw new Error(LOG_CATEGORY + ": " + msg);
};
var warn = function(msg) {
    console.warn(LOG_CATEGORY + ": " + msg);
};
function safeToString(info) {
    try {
        return JSON.stringify(info, null, 2);
    } catch (e) {
        return '';
    }
}
// RegExp for version string
var VERSION_PATTERN_REGEXP = /^([\d^=v<>~]|[*xX]$)/;
function isRequiredVersion(str) {
    return VERSION_PATTERN_REGEXP.test(str);
}
var simpleJoinRemoteEntry = function(rPath, rName) {
    if (!rPath) {
        return rName;
    }
    var transformPath = function(str) {
        if (str === '.') {
            return '';
        }
        if (str.startsWith('./')) {
            return str.replace('./', '');
        }
        if (str.startsWith('/')) {
            var strWithoutSlash = str.slice(1);
            if (strWithoutSlash.endsWith('/')) {
                return strWithoutSlash.slice(0, -1);
            }
            return strWithoutSlash;
        }
        return str;
    };
    var transformedPath = transformPath(rPath);
    if (!transformedPath) {
        return rName;
    }
    if (transformedPath.endsWith('/')) {
        return "" + transformedPath + rName;
    }
    return transformedPath + "/" + rName;
};
function inferAutoPublicPath(url) {
    return url.replace(/#.*$/, '').replace(/\?.*$/, '').replace(/\/[^\/]+$/, '/');
}
// Priority: overrides > remotes
// eslint-disable-next-line max-lines-per-function
function generateSnapshotFromManifest(manifest, options) {
    if (options === void 0) options = {};
    var _manifest_metaData, _manifest_metaData1;
    var _options_remotes = options.remotes, remotes = _options_remotes === void 0 ? {} : _options_remotes, _options_overrides = options.overrides, overrides = _options_overrides === void 0 ? {} : _options_overrides, version = options.version;
    var remoteSnapshot;
    var getPublicPath = function() {
        if ('publicPath' in manifest.metaData) {
            if (manifest.metaData.publicPath === 'auto' && version) {
                // use same implementation as publicPath auto runtime module implements
                return inferAutoPublicPath(version);
            }
            return manifest.metaData.publicPath;
        } else {
            return manifest.metaData.getPublicPath;
        }
    };
    var overridesKeys = Object.keys(overrides);
    var remotesInfo = {};
    // If remotes are not provided, only the remotes in the manifest will be read
    if (!Object.keys(remotes).length) {
        var _manifest_remotes;
        remotesInfo = ((_manifest_remotes = manifest.remotes) == null ? void 0 : _manifest_remotes.reduce(function(res, next) {
            var matchedVersion;
            var name = next.federationContainerName;
            // overrides have higher priority
            if (overridesKeys.includes(name)) {
                matchedVersion = overrides[name];
            } else {
                if ('version' in next) {
                    matchedVersion = next.version;
                } else {
                    matchedVersion = next.entry;
                }
            }
            res[name] = {
                matchedVersion: matchedVersion
            };
            return res;
        }, {})) || {};
    }
    // If remotes (deploy scenario) are specified, they need to be traversed again
    Object.keys(remotes).forEach(function(key) {
        return remotesInfo[key] = {
            // overrides will override dependencies
            matchedVersion: overridesKeys.includes(key) ? overrides[key] : remotes[key]
        };
    });
    var _manifest_metaData2 = manifest.metaData, _manifest_metaData_remoteEntry = _manifest_metaData2.remoteEntry, remoteEntryPath = _manifest_metaData_remoteEntry.path, remoteEntryName = _manifest_metaData_remoteEntry.name, remoteEntryType = _manifest_metaData_remoteEntry.type, remoteTypes = _manifest_metaData2.types, buildVersion = _manifest_metaData2.buildInfo.buildVersion, globalName = _manifest_metaData2.globalName, ssrRemoteEntry = _manifest_metaData2.ssrRemoteEntry;
    var exposes = manifest.exposes;
    var basicRemoteSnapshot = {
        version: version ? version : '',
        buildVersion: buildVersion,
        globalName: globalName,
        remoteEntry: simpleJoinRemoteEntry(remoteEntryPath, remoteEntryName),
        remoteEntryType: remoteEntryType,
        remoteTypes: simpleJoinRemoteEntry(remoteTypes.path, remoteTypes.name),
        remoteTypesZip: remoteTypes.zip || '',
        remoteTypesAPI: remoteTypes.api || '',
        remotesInfo: remotesInfo,
        shared: manifest == null ? void 0 : manifest.shared.map(function(item) {
            return {
                assets: item.assets,
                sharedName: item.name,
                version: item.version
            };
        }),
        modules: exposes == null ? void 0 : exposes.map(function(expose) {
            return {
                moduleName: expose.name,
                modulePath: expose.path,
                assets: expose.assets
            };
        })
    };
    if ((_manifest_metaData = manifest.metaData) == null ? void 0 : _manifest_metaData.prefetchInterface) {
        var prefetchInterface = manifest.metaData.prefetchInterface;
        basicRemoteSnapshot = polyfills._extends({}, basicRemoteSnapshot, {
            prefetchInterface: prefetchInterface
        });
    }
    if ((_manifest_metaData1 = manifest.metaData) == null ? void 0 : _manifest_metaData1.prefetchEntry) {
        var _manifest_metaData_prefetchEntry = manifest.metaData.prefetchEntry, path = _manifest_metaData_prefetchEntry.path, name = _manifest_metaData_prefetchEntry.name, type = _manifest_metaData_prefetchEntry.type;
        basicRemoteSnapshot = polyfills._extends({}, basicRemoteSnapshot, {
            prefetchEntry: simpleJoinRemoteEntry(path, name),
            prefetchEntryType: type
        });
    }
    if ('publicPath' in manifest.metaData) {
        remoteSnapshot = polyfills._extends({}, basicRemoteSnapshot, {
            publicPath: getPublicPath()
        });
    } else {
        remoteSnapshot = polyfills._extends({}, basicRemoteSnapshot, {
            getPublicPath: getPublicPath()
        });
    }
    if (ssrRemoteEntry) {
        var fullSSRRemoteEntry = simpleJoinRemoteEntry(ssrRemoteEntry.path, ssrRemoteEntry.name);
        remoteSnapshot.ssrRemoteEntry = fullSSRRemoteEntry;
        remoteSnapshot.ssrRemoteEntryType = ssrRemoteEntry.type || 'commonjs-module';
    }
    return remoteSnapshot;
}
function isManifestProvider(moduleInfo) {
    if ('remoteEntry' in moduleInfo && moduleInfo.remoteEntry.includes(MANIFEST_EXT)) {
        return true;
    } else {
        return false;
    }
}
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function safeWrapper(callback, disableWarn) {
    return _async_to_generator._(function() {
        var res, e;
        return _ts_generator._(this, function(_state) {
            switch(_state.label){
                case 0:
                    _state.trys.push([
                        0,
                        2,
                        ,
                        3
                    ]);
                    return [
                        4,
                        callback()
                    ];
                case 1:
                    res = _state.sent();
                    return [
                        2,
                        res
                    ];
                case 2:
                    e = _state.sent();
                    !disableWarn && warn(e);
                    return [
                        2
                    ];
                case 3:
                    return [
                        2
                    ];
            }
        });
    })();
}
function isStaticResourcesEqual(url1, url2) {
    var REG_EXP = /^(https?:)?\/\//i;
    // Transform url1 and url2 into relative paths
    var relativeUrl1 = url1.replace(REG_EXP, '').replace(/\/$/, '');
    var relativeUrl2 = url2.replace(REG_EXP, '').replace(/\/$/, '');
    // Check if the relative paths are identical
    return relativeUrl1 === relativeUrl2;
}
function createScript(info) {
    // Retrieve the existing script element by its src attribute
    var script = null;
    var needAttach = true;
    var timeout = 20000;
    var timeoutId;
    var scripts = document.getElementsByTagName('script');
    for(var i = 0; i < scripts.length; i++){
        var s = scripts[i];
        var scriptSrc = s.getAttribute('src');
        if (scriptSrc && isStaticResourcesEqual(scriptSrc, info.url)) {
            script = s;
            needAttach = false;
            break;
        }
    }
    if (!script) {
        var attrs = info.attrs;
        script = document.createElement('script');
        script.type = (attrs == null ? void 0 : attrs['type']) === 'module' ? 'module' : 'text/javascript';
        var createScriptRes = undefined;
        if (info.createScriptHook) {
            createScriptRes = info.createScriptHook(info.url, info.attrs);
            if (createScriptRes instanceof HTMLScriptElement) {
                script = createScriptRes;
            } else if ((typeof createScriptRes === "undefined" ? "undefined" : _type_of._(createScriptRes)) === 'object') {
                if ('script' in createScriptRes && createScriptRes.script) {
                    script = createScriptRes.script;
                }
                if ('timeout' in createScriptRes && createScriptRes.timeout) {
                    timeout = createScriptRes.timeout;
                }
            }
        }
        if (!script.src) {
            script.src = info.url;
        }
        if (attrs && !createScriptRes) {
            Object.keys(attrs).forEach(function(name) {
                if (script) {
                    if (name === 'async' || name === 'defer') {
                        script[name] = attrs[name];
                    // Attributes that do not exist are considered overridden
                    } else if (!script.getAttribute(name)) {
                        script.setAttribute(name, attrs[name]);
                    }
                }
            });
        }
    }
    var onScriptComplete = function(prev, event) {
        return _async_to_generator._(function() {
            var _info_cb, _info_cb1, result, _info_cb2, res;
            return _ts_generator._(this, function(_state) {
                switch(_state.label){
                    case 0:
                        clearTimeout(timeoutId);
                        if (!script) return [
                            3,
                            3
                        ];
                        script.onerror = null;
                        script.onload = null;
                        safeWrapper(function() {
                            var _info_needDeleteScript = info.needDeleteScript, needDeleteScript = _info_needDeleteScript === void 0 ? true : _info_needDeleteScript;
                            if (needDeleteScript) {
                                (script == null ? void 0 : script.parentNode) && script.parentNode.removeChild(script);
                            }
                        });
                        if (!(prev && typeof prev === 'function')) return [
                            3,
                            3
                        ];
                        result = prev(event);
                        if (!(result instanceof Promise)) return [
                            3,
                            2
                        ];
                        return [
                            4,
                            result
                        ];
                    case 1:
                        res = _state.sent();
                        info == null ? void 0 : (_info_cb2 = info.cb) == null ? void 0 : _info_cb2.call(info);
                        return [
                            2,
                            res
                        ];
                    case 2:
                        info == null ? void 0 : (_info_cb1 = info.cb) == null ? void 0 : _info_cb1.call(info);
                        return [
                            2,
                            result
                        ];
                    case 3:
                        info == null ? void 0 : (_info_cb = info.cb) == null ? void 0 : _info_cb.call(info);
                        return [
                            2
                        ];
                }
            });
        })();
    };
    script.onerror = onScriptComplete.bind(null, script.onerror);
    script.onload = onScriptComplete.bind(null, script.onload);
    timeoutId = setTimeout(function() {
        onScriptComplete(null, new Error('Remote script "' + info.url + '" time-outed.'));
    }, timeout);
    return {
        script: script,
        needAttach: needAttach
    };
}
function createLink(info) {
    // <link rel="preload" href="script.js" as="script">
    // Retrieve the existing script element by its src attribute
    var link = null;
    var needAttach = true;
    var links = document.getElementsByTagName('link');
    for(var i = 0; i < links.length; i++){
        var l = links[i];
        var linkHref = l.getAttribute('href');
        var linkRef = l.getAttribute('ref');
        if (linkHref && isStaticResourcesEqual(linkHref, info.url) && linkRef === info.attrs['ref']) {
            link = l;
            needAttach = false;
            break;
        }
    }
    if (!link) {
        link = document.createElement('link');
        link.setAttribute('href', info.url);
        var createLinkRes = undefined;
        var attrs = info.attrs;
        if (info.createLinkHook) {
            createLinkRes = info.createLinkHook(info.url, attrs);
            if (createLinkRes instanceof HTMLLinkElement) {
                link = createLinkRes;
            }
        }
        if (attrs && !createLinkRes) {
            Object.keys(attrs).forEach(function(name) {
                if (link && !link.getAttribute(name)) {
                    link.setAttribute(name, attrs[name]);
                }
            });
        }
    }
    var onLinkComplete = function(prev, event) {
        // Prevent memory leaks in IE.
        if (link) {
            link.onerror = null;
            link.onload = null;
            safeWrapper(function() {
                var _info_needDeleteLink = info.needDeleteLink, needDeleteLink = _info_needDeleteLink === void 0 ? true : _info_needDeleteLink;
                if (needDeleteLink) {
                    (link == null ? void 0 : link.parentNode) && link.parentNode.removeChild(link);
                }
            });
            if (prev) {
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                var res = prev(event);
                info.cb();
                return res;
            }
        }
        info.cb();
    };
    link.onerror = onLinkComplete.bind(null, link.onerror);
    link.onload = onLinkComplete.bind(null, link.onload);
    return {
        link: link,
        needAttach: needAttach
    };
}
function loadScript(url, info) {
    var _info_attrs = info.attrs, attrs = _info_attrs === void 0 ? {} : _info_attrs, createScriptHook = info.createScriptHook;
    return new Promise(function(resolve, _reject) {
        var _createScript = createScript({
            url: url,
            cb: resolve,
            attrs: polyfills._extends({
                fetchpriority: 'high'
            }, attrs),
            createScriptHook: createScriptHook,
            needDeleteScript: true
        }), script = _createScript.script, needAttach = _createScript.needAttach;
        needAttach && document.head.appendChild(script);
    });
}
function importNodeModule(name) {
    if (!name) {
        throw new Error('import specifier is required');
    }
    var importModule = new Function('name', "return import(name)");
    return importModule(name).then(function(res) {
        return res;
    })["catch"](function(error1) {
        console.error("Error importing module " + name + ":", error1);
        throw error1;
    });
}
var loadNodeFetch = function() {
    return _async_to_generator._(function() {
        var fetchModule;
        return _ts_generator._(this, function(_state) {
            switch(_state.label){
                case 0:
                    return [
                        4,
                        importNodeModule('node-fetch')
                    ];
                case 1:
                    fetchModule = _state.sent();
                    return [
                        2,
                        fetchModule["default"] || fetchModule
                    ];
            }
        });
    })();
};
var lazyLoaderHookFetch = function(input, init) {
    return _async_to_generator._(function() {
        var loaderHooks, hook, res, fetchFunction, _tmp;
        return _ts_generator._(this, function(_state) {
            switch(_state.label){
                case 0:
                    // @ts-ignore
                    loaderHooks = __webpack_require__.federation.instance.loaderHook;
                    hook = function(url, init) {
                        return loaderHooks.lifecycle.fetch.emit(url, init);
                    };
                    return [
                        4,
                        hook(input, init || {})
                    ];
                case 1:
                    res = _state.sent();
                    if (!(!res || !(res instanceof Response))) return [
                        3,
                        5
                    ];
                    if (!(typeof fetch === 'undefined')) return [
                        3,
                        3
                    ];
                    return [
                        4,
                        loadNodeFetch()
                    ];
                case 2:
                    _tmp = _state.sent();
                    return [
                        3,
                        4
                    ];
                case 3:
                    _tmp = fetch;
                    _state.label = 4;
                case 4:
                    fetchFunction = _tmp;
                    return [
                        2,
                        fetchFunction(input, init || {})
                    ];
                case 5:
                    return [
                        2,
                        res
                    ];
            }
        });
    })();
};
function createScriptNode(url, cb, attrs, createScriptHook) {
    if (createScriptHook) {
        var hookResult = createScriptHook(url);
        if (hookResult && (typeof hookResult === "undefined" ? "undefined" : _type_of._(hookResult)) === 'object' && 'url' in hookResult) {
            url = hookResult.url;
        }
    }
    var urlObj;
    try {
        urlObj = new URL(url);
    } catch (e) {
        console.error('Error constructing URL:', e);
        cb(new Error("Invalid URL: " + e));
        return;
    }
    var getFetch = function() {
        return _async_to_generator._(function() {
            var loaderHooks;
            return _ts_generator._(this, function(_state) {
                //@ts-ignore
                if (true) {
                    try {
                        //@ts-ignore
                        loaderHooks = __webpack_require__.federation.instance.loaderHook;
                        if (loaderHooks.lifecycle.fetch) {
                            return [
                                2,
                                lazyLoaderHookFetch
                            ];
                        }
                    } catch (e) {
                        console.warn('federation.instance.loaderHook.lifecycle.fetch failed:', e);
                    }
                }
                return [
                    2,
                    typeof fetch === 'undefined' ? loadNodeFetch() : fetch
                ];
            });
        })();
    };
    var handleScriptFetch = function(f, urlObj) {
        return _async_to_generator._(function() {
            var _vm_constants, res, data, _ref, path, vm, scriptContext, urlDirname, filename, _vm_constants_USE_MAIN_CONTEXT_DEFAULT_LOADER, script, exportedInterface, container, e;
            return _ts_generator._(this, function(_state) {
                switch(_state.label){
                    case 0:
                        _state.trys.push([
                            0,
                            4,
                            ,
                            5
                        ]);
                        return [
                            4,
                            f(urlObj.href)
                        ];
                    case 1:
                        res = _state.sent();
                        return [
                            4,
                            res.text()
                        ];
                    case 2:
                        data = _state.sent();
                        return [
                            4,
                            Promise.all([
                                importNodeModule('path'),
                                importNodeModule('vm')
                            ])
                        ];
                    case 3:
                        _ref = _sliced_to_array._.apply(void 0, [
                            _state.sent(),
                            2
                        ]), path = _ref[0], vm = _ref[1];
                        scriptContext = {
                            exports: {},
                            module: {
                                exports: {}
                            }
                        };
                        urlDirname = urlObj.pathname.split('/').slice(0, -1).join('/');
                        filename = path.basename(urlObj.pathname);
                        script = new vm.Script("(function(exports, module, require, __dirname, __filename) {" + data + "\n})", {
                            filename: filename,
                            importModuleDynamically: (_vm_constants_USE_MAIN_CONTEXT_DEFAULT_LOADER = (_vm_constants = vm.constants) == null ? void 0 : _vm_constants.USE_MAIN_CONTEXT_DEFAULT_LOADER) != null ? _vm_constants_USE_MAIN_CONTEXT_DEFAULT_LOADER : importNodeModule
                        });
                        script.runInThisContext()(scriptContext.exports, scriptContext.module, eval('require'), urlDirname, filename);
                        exportedInterface = scriptContext.module.exports || scriptContext.exports;
                        if (attrs && exportedInterface && attrs['globalName']) {
                            container = exportedInterface[attrs['globalName']] || exportedInterface;
                            cb(undefined, container);
                            return [
                                2
                            ];
                        }
                        cb(undefined, exportedInterface);
                        return [
                            3,
                            5
                        ];
                    case 4:
                        e = _state.sent();
                        cb(e instanceof Error ? e : new Error("Script execution error: " + e));
                        return [
                            3,
                            5
                        ];
                    case 5:
                        return [
                            2
                        ];
                }
            });
        })();
    };
    getFetch().then(function(f) {
        return _async_to_generator._(function() {
            var _tmp, _tmp1;
            return _ts_generator._(this, function(_state) {
                switch(_state.label){
                    case 0:
                        if (!((attrs == null ? void 0 : attrs['type']) === 'esm' || (attrs == null ? void 0 : attrs['type']) === 'module')) return [
                            3,
                            2
                        ];
                        _tmp = [
                            urlObj.href
                        ];
                        _tmp1 = {
                            fetch: f
                        };
                        return [
                            4,
                            importNodeModule('vm')
                        ];
                    case 1:
                        return [
                            2,
                            loadModule.apply(void 0, _tmp.concat([
                                (_tmp1.vm = _state.sent(), _tmp1)
                            ])).then(function(module) {
                                return _async_to_generator._(function() {
                                    return _ts_generator._(this, function(_state) {
                                        switch(_state.label){
                                            case 0:
                                                return [
                                                    4,
                                                    module.evaluate()
                                                ];
                                            case 1:
                                                _state.sent();
                                                cb(undefined, module.namespace);
                                                return [
                                                    2
                                                ];
                                        }
                                    });
                                })();
                            })["catch"](function(e) {
                                cb(e instanceof Error ? e : new Error("Script execution error: " + e));
                            })
                        ];
                    case 2:
                        handleScriptFetch(f, urlObj);
                        return [
                            2
                        ];
                }
            });
        })();
    })["catch"](function(err) {
        cb(err);
    });
}
function loadScriptNode(url, info) {
    return new Promise(function(resolve, reject) {
        createScriptNode(url, function(error1, scriptContext) {
            if (error1) {
                reject(error1);
            } else {
                var _info_attrs, _info_attrs1;
                var remoteEntryKey = (info == null ? void 0 : (_info_attrs = info.attrs) == null ? void 0 : _info_attrs['globalName']) || "__FEDERATION_" + (info == null ? void 0 : (_info_attrs1 = info.attrs) == null ? void 0 : _info_attrs1['name']) + ":custom__";
                var entryExports = globalThis[remoteEntryKey] = scriptContext;
                resolve(entryExports);
            }
        }, info.attrs, info.createScriptHook);
    });
}
function loadModule(url, options) {
    return _async_to_generator._(function() {
        var fetch1, vm, response, code, module;
        return _ts_generator._(this, function(_state) {
            switch(_state.label){
                case 0:
                    fetch1 = options.fetch, vm = options.vm;
                    return [
                        4,
                        fetch1(url)
                    ];
                case 1:
                    response = _state.sent();
                    return [
                        4,
                        response.text()
                    ];
                case 2:
                    code = _state.sent();
                    module = new vm.SourceTextModule(code, {
                        // @ts-ignore
                        importModuleDynamically: function(specifier, script) {
                            return _async_to_generator._(function() {
                                var resolvedUrl;
                                return _ts_generator._(this, function(_state) {
                                    resolvedUrl = new URL(specifier, url).href;
                                    return [
                                        2,
                                        loadModule(resolvedUrl, options)
                                    ];
                                });
                            })();
                        }
                    });
                    return [
                        4,
                        module.link(function(specifier) {
                            return _async_to_generator._(function() {
                                var resolvedUrl, module;
                                return _ts_generator._(this, function(_state) {
                                    switch(_state.label){
                                        case 0:
                                            resolvedUrl = new URL(specifier, url).href;
                                            return [
                                                4,
                                                loadModule(resolvedUrl, options)
                                            ];
                                        case 1:
                                            module = _state.sent();
                                            return [
                                                2,
                                                module
                                            ];
                                    }
                                });
                            })();
                        })
                    ];
                case 3:
                    _state.sent();
                    return [
                        2,
                        module
                    ];
            }
        });
    })();
}
function normalizeOptions(enableDefault, defaultOptions, key) {
    return function(options) {
        if (options === false) {
            return false;
        }
        if (typeof options === 'undefined') {
            if (enableDefault) {
                return defaultOptions;
            } else {
                return false;
            }
        }
        if (options === true) {
            return defaultOptions;
        }
        if (options && (typeof options === "undefined" ? "undefined" : _type_of._(options)) === 'object') {
            return polyfills._extends({}, defaultOptions, options);
        }
        throw new Error("Unexpected type for `" + key + "`, expect boolean/undefined/object, got: " + (typeof options === "undefined" ? "undefined" : _type_of._(options)));
    };
}
exports.BROWSER_LOG_KEY = BROWSER_LOG_KEY;
exports.BROWSER_LOG_VALUE = BROWSER_LOG_VALUE;
exports.ENCODE_NAME_PREFIX = ENCODE_NAME_PREFIX;
exports.EncodedNameTransformMap = EncodedNameTransformMap;
exports.FederationModuleManifest = FederationModuleManifest;
exports.Logger = Logger;
exports.MANIFEST_EXT = MANIFEST_EXT;
exports.MFModuleType = MFModuleType;
exports.MFPrefetchCommon = MFPrefetchCommon;
exports.MODULE_DEVTOOL_IDENTIFIER = MODULE_DEVTOOL_IDENTIFIER;
exports.ManifestFileName = ManifestFileName;
exports.NameTransformMap = NameTransformMap;
exports.NameTransformSymbol = NameTransformSymbol;
exports.SEPARATOR = SEPARATOR;
exports.StatsFileName = StatsFileName;
exports.TEMP_DIR = TEMP_DIR;
exports.assert = assert;
exports.composeKeyWithSeparator = composeKeyWithSeparator;
exports.containerPlugin = ContainerPlugin;
exports.containerReferencePlugin = ContainerReferencePlugin;
exports.createLink = createLink;
exports.createScript = createScript;
exports.createScriptNode = createScriptNode;
exports.decodeName = decodeName;
exports.encodeName = encodeName;
exports.error = error;
exports.generateExposeFilename = generateExposeFilename;
exports.generateShareFilename = generateShareFilename;
exports.generateSnapshotFromManifest = generateSnapshotFromManifest;
exports.getProcessEnv = getProcessEnv;
exports.getResourceUrl = getResourceUrl;
exports.inferAutoPublicPath = inferAutoPublicPath;
exports.isBrowserEnv = isBrowserEnv;
exports.isDebugMode = isDebugMode;
exports.isManifestProvider = isManifestProvider;
exports.isRequiredVersion = isRequiredVersion;
exports.isStaticResourcesEqual = isStaticResourcesEqual;
exports.loadScript = loadScript;
exports.loadScriptNode = loadScriptNode;
exports.logger = logger;
exports.moduleFederationPlugin = ModuleFederationPlugin;
exports.normalizeOptions = normalizeOptions;
exports.parseEntry = parseEntry;
exports.safeToString = safeToString;
exports.safeWrapper = safeWrapper;
exports.sharePlugin = SharePlugin;
exports.simpleJoinRemoteEntry = simpleJoinRemoteEntry;
exports.warn = warn;


}),
61346: (function (__unused_webpack_module, exports) {
"use strict";

function _extends() {
    _extends = Object.assign || function assign(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source)if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
        }
        return target;
    };
    return _extends.apply(this, arguments);
}
exports._extends = _extends;


}),
62939: (function (module, __unused_webpack_exports, __webpack_require__) {
"use strict";

var runtime = __webpack_require__(52570);
var constant = __webpack_require__(74956);
var sdk = __webpack_require__(58506);
var polyfills = __webpack_require__(61346);
function _interopNamespaceDefault(e) {
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function(k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function get() {
                        return e[k];
                    }
                });
            }
        });
    }
    n["default"] = e;
    return Object.freeze(n);
}
var runtime__namespace = /*#__PURE__*/ _interopNamespaceDefault(runtime);
function attachShareScopeMap(webpackRequire) {
    if (!webpackRequire.S || webpackRequire.federation.hasAttachShareScopeMap || !webpackRequire.federation.instance || !webpackRequire.federation.instance.shareScopeMap) {
        return;
    }
    webpackRequire.S = webpackRequire.federation.instance.shareScopeMap;
    webpackRequire.federation.hasAttachShareScopeMap = true;
}
function remotes(options) {
    var chunkId = options.chunkId, promises = options.promises, chunkMapping = options.chunkMapping, idToExternalAndNameMapping = options.idToExternalAndNameMapping, webpackRequire = options.webpackRequire, idToRemoteMap = options.idToRemoteMap;
    attachShareScopeMap(webpackRequire);
    if (webpackRequire.o(chunkMapping, chunkId)) {
        chunkMapping[chunkId].forEach(function(id) {
            var getScope = webpackRequire.R;
            if (!getScope) {
                getScope = [];
            }
            var data = idToExternalAndNameMapping[id];
            var remoteInfos = idToRemoteMap[id];
            // @ts-ignore seems not work
            if (getScope.indexOf(data) >= 0) {
                return;
            }
            // @ts-ignore seems not work
            getScope.push(data);
            if (data.p) {
                return promises.push(data.p);
            }
            var onError = function(error) {
                if (!error) {
                    error = new Error('Container missing');
                }
                if (typeof error.message === 'string') {
                    error.message += '\nwhile loading "' + data[1] + '" from ' + data[2];
                }
                webpackRequire.m[id] = function() {
                    throw error;
                };
                data.p = 0;
            };
            var handleFunction = function(fn, arg1, arg2, d, next, first) {
                try {
                    var promise = fn(arg1, arg2);
                    if (promise && promise.then) {
                        var p = promise.then(function(result) {
                            return next(result, d);
                        }, onError);
                        if (first) {
                            promises.push(data.p = p);
                        } else {
                            return p;
                        }
                    } else {
                        return next(promise, d, first);
                    }
                } catch (error) {
                    onError(error);
                }
            };
            var onExternal = function(external, _, first) {
                return external ? handleFunction(webpackRequire.I, data[0], 0, external, onInitialized, first) : onError();
            };
            // eslint-disable-next-line no-var
            var onInitialized = function(_, external, first) {
                return handleFunction(external.get, data[1], getScope, 0, onFactory, first);
            };
            // eslint-disable-next-line no-var
            var onFactory = function(factory) {
                data.p = 1;
                webpackRequire.m[id] = function(module1) {
                    module1.exports = factory();
                };
            };
            var onRemoteLoaded = function() {
                try {
                    var remoteName = sdk.decodeName(remoteInfos[0].name, sdk.ENCODE_NAME_PREFIX);
                    var remoteModuleName = remoteName + data[1].slice(1);
                    return webpackRequire.federation.instance.loadRemote(remoteModuleName, {
                        loadFactory: false,
                        from: 'build'
                    });
                } catch (error) {
                    onError(error);
                }
            };
            var useRuntimeLoad = remoteInfos.length === 1 && constant.FEDERATION_SUPPORTED_TYPES.includes(remoteInfos[0].externalType) && remoteInfos[0].name;
            if (useRuntimeLoad) {
                handleFunction(onRemoteLoaded, data[2], 0, 0, onFactory, 1);
            } else {
                handleFunction(webpackRequire, data[2], 0, 0, onExternal, 1);
            }
        });
    }
}
function consumes(options) {
    var chunkId = options.chunkId, promises = options.promises, chunkMapping = options.chunkMapping, installedModules = options.installedModules, moduleToHandlerMapping = options.moduleToHandlerMapping, webpackRequire = options.webpackRequire;
    attachShareScopeMap(webpackRequire);
    if (webpackRequire.o(chunkMapping, chunkId)) {
        chunkMapping[chunkId].forEach(function(id) {
            if (webpackRequire.o(installedModules, id)) {
                return promises.push(installedModules[id]);
            }
            var onFactory = function(factory) {
                installedModules[id] = 0;
                webpackRequire.m[id] = function(module1) {
                    delete webpackRequire.c[id];
                    module1.exports = factory();
                };
            };
            var onError = function(error) {
                delete installedModules[id];
                webpackRequire.m[id] = function(module1) {
                    delete webpackRequire.c[id];
                    throw error;
                };
            };
            try {
                var federationInstance = webpackRequire.federation.instance;
                if (!federationInstance) {
                    throw new Error('Federation instance not found!');
                }
                var _moduleToHandlerMapping_id = moduleToHandlerMapping[id], shareKey = _moduleToHandlerMapping_id.shareKey, getter = _moduleToHandlerMapping_id.getter, shareInfo = _moduleToHandlerMapping_id.shareInfo;
                var promise = federationInstance.loadShare(shareKey, {
                    customShareInfo: shareInfo
                }).then(function(factory) {
                    if (factory === false) {
                        return getter();
                    }
                    return factory;
                });
                if (promise.then) {
                    promises.push(installedModules[id] = promise.then(onFactory)["catch"](onError));
                } else {
                    // @ts-ignore maintain previous logic
                    onFactory(promise);
                }
            } catch (e) {
                onError(e);
            }
        });
    }
}
function initializeSharing(param) {
    var shareScopeName = param.shareScopeName, webpackRequire = param.webpackRequire, initPromises = param.initPromises, initTokens = param.initTokens, initScope = param.initScope;
    if (!initScope) initScope = [];
    var mfInstance = webpackRequire.federation.instance;
    // handling circular init calls
    var initToken = initTokens[shareScopeName];
    if (!initToken) initToken = initTokens[shareScopeName] = {
        from: mfInstance.name
    };
    if (initScope.indexOf(initToken) >= 0) return;
    initScope.push(initToken);
    var promise = initPromises[shareScopeName];
    if (promise) return promise;
    var warn = function(msg) {
        return typeof console !== 'undefined' && console.warn && console.warn(msg);
    };
    var initExternal = function(id) {
        var handleError = function(err) {
            return warn('Initialization of sharing external failed: ' + err);
        };
        try {
            var _$module = webpackRequire(id);
            if (!_$module) return;
            var initFn = function(module1) {
                return module1 && module1.init && // @ts-ignore compat legacy mf shared behavior
                module1.init(webpackRequire.S[shareScopeName], initScope);
            };
            if (_$module.then) return promises.push(_$module.then(initFn, handleError));
            var initResult = initFn(_$module);
            // @ts-ignore
            if (initResult && typeof initResult !== 'boolean' && initResult.then) return promises.push(initResult['catch'](handleError));
        } catch (err) {
            handleError(err);
        }
    };
    var promises = mfInstance.initializeSharing(shareScopeName, {
        strategy: mfInstance.options.shareStrategy,
        initScope: initScope,
        from: 'build'
    });
    attachShareScopeMap(webpackRequire);
    var bundlerRuntimeRemotesOptions = webpackRequire.federation.bundlerRuntimeOptions.remotes;
    if (bundlerRuntimeRemotesOptions) {
        Object.keys(bundlerRuntimeRemotesOptions.idToRemoteMap).forEach(function(moduleId) {
            var info = bundlerRuntimeRemotesOptions.idToRemoteMap[moduleId];
            var externalModuleId = bundlerRuntimeRemotesOptions.idToExternalAndNameMapping[moduleId][2];
            if (info.length > 1) {
                initExternal(externalModuleId);
            } else if (info.length === 1) {
                var remoteInfo = info[0];
                if (!constant.FEDERATION_SUPPORTED_TYPES.includes(remoteInfo.externalType)) {
                    initExternal(externalModuleId);
                }
            }
        });
    }
    if (!promises.length) {
        return initPromises[shareScopeName] = true;
    }
    return initPromises[shareScopeName] = Promise.all(promises).then(function() {
        return initPromises[shareScopeName] = true;
    });
}
function handleInitialConsumes(options) {
    var moduleId = options.moduleId, moduleToHandlerMapping = options.moduleToHandlerMapping, webpackRequire = options.webpackRequire;
    var federationInstance = webpackRequire.federation.instance;
    if (!federationInstance) {
        throw new Error('Federation instance not found!');
    }
    var _moduleToHandlerMapping_moduleId = moduleToHandlerMapping[moduleId], shareKey = _moduleToHandlerMapping_moduleId.shareKey, shareInfo = _moduleToHandlerMapping_moduleId.shareInfo;
    try {
        return federationInstance.loadShareSync(shareKey, {
            customShareInfo: shareInfo
        });
    } catch (err) {
        console.error('loadShareSync failed! The function should not be called unless you set "eager:true". If you do not set it, and encounter this issue, you can check whether an async boundary is implemented.');
        console.error('The original error message is as follows: ');
        throw err;
    }
}
function installInitialConsumes(options) {
    var moduleToHandlerMapping = options.moduleToHandlerMapping, webpackRequire = options.webpackRequire, installedModules = options.installedModules, initialConsumes = options.initialConsumes;
    initialConsumes.forEach(function(id) {
        webpackRequire.m[id] = function(module1) {
            // Handle scenario when module is used synchronously
            installedModules[id] = 0;
            delete webpackRequire.c[id];
            var factory = handleInitialConsumes({
                moduleId: id,
                moduleToHandlerMapping: moduleToHandlerMapping,
                webpackRequire: webpackRequire
            });
            if (typeof factory !== 'function') {
                throw new Error("Shared module is not available for eager consumption: " + id);
            }
            module1.exports = factory();
        };
    });
}
function initContainerEntry(options) {
    var webpackRequire = options.webpackRequire, shareScope = options.shareScope, initScope = options.initScope, shareScopeKey = options.shareScopeKey, remoteEntryInitOptions = options.remoteEntryInitOptions;
    if (!webpackRequire.S) return;
    if (!webpackRequire.federation || !webpackRequire.federation.instance || !webpackRequire.federation.initOptions) return;
    var federationInstance = webpackRequire.federation.instance;
    var name = shareScopeKey || 'default';
    federationInstance.initOptions(polyfills._extends({
        name: webpackRequire.federation.initOptions.name,
        remotes: []
    }, remoteEntryInitOptions));
    federationInstance.initShareScopeMap(name, shareScope, {
        hostShareScopeMap: (remoteEntryInitOptions == null ? void 0 : remoteEntryInitOptions.shareScopeMap) || {}
    });
    if (webpackRequire.federation.attachShareScopeMap) {
        webpackRequire.federation.attachShareScopeMap(webpackRequire);
    }
    if (typeof webpackRequire.federation.prefetch === 'function') {
        webpackRequire.federation.prefetch();
    }
    // @ts-ignore
    return webpackRequire.I(name, initScope);
}
var federation = {
    runtime: runtime__namespace,
    instance: undefined,
    initOptions: undefined,
    bundlerRuntime: {
        remotes: remotes,
        consumes: consumes,
        I: initializeSharing,
        S: {},
        installInitialConsumes: installInitialConsumes,
        initContainerEntry: initContainerEntry
    },
    attachShareScopeMap: attachShareScopeMap,
    bundlerRuntimeOptions: {}
};
module.exports = federation;


}),
63563: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

exports._ = (__webpack_require__(21633)/* .__generator */.__generator);


}),
64488: (function (__unused_webpack_module, exports) {
"use strict";

function _extends() {
    _extends = Object.assign || function assign(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source)if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
        }
        return target;
    };
    return _extends.apply(this, arguments);
}
exports._extends = _extends;


}),
69479: (function (__unused_webpack_module, exports, __webpack_require__) {
// biome-ignore lint/style/useNodejsImportProtocol: use 'events' module instead of node builtin
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "ScriptManager", ({
    enumerable: true,
    get: function() {
        return ScriptManager;
    }
}));
var _async_to_generator = __webpack_require__(37297);
var _create_class = __webpack_require__(51302);
var _inherits = __webpack_require__(85428);
var _interop_require_default = __webpack_require__(48810);
var _sliced_to_array = __webpack_require__(21193);
var _to_consumable_array = __webpack_require__(8034);
var _ts_generator = __webpack_require__(63563);
var _events = /*#__PURE__*/ _interop_require_default._(__webpack_require__(12423));
var _NativeScriptManager = /*#__PURE__*/ _interop_require_default._(__webpack_require__(55581));
var _Script = __webpack_require__(38837);
var _getWebpackContext = __webpack_require__(16972);
var DEFAULT_RESOLVER_PRIORITY = 2;
var DEFAULT_RESOLVER_KEY = '__default__';
var CACHE_NAME = 'Repack.ScriptManager.Cache';
var CACHE_VERSION = 'v4';
var CACHE_ENV =  false ? 0 : 'release';
var CACHE_KEY = [
    CACHE_NAME,
    CACHE_VERSION,
    CACHE_ENV
].join('.');
var LOADING_ERROR_CODES = [
    // android
    'NetworkFailure',
    'RequestFailure',
    // ios
    'ScriptDownloadFailure'
];
var ScriptManager = /*#__PURE__*/ function(EventEmitter) {
    "use strict";
    _inherits._(ScriptManager, EventEmitter);
    function ScriptManager(nativeScriptManager) {
        if (nativeScriptManager === void 0) nativeScriptManager = _NativeScriptManager.default;
        var _this;
        _this = EventEmitter.call(this) || this, _this.cache = {}, _this.scriptsPromises = {}, _this.cacheInitialized = false, _this.resolvers = [];
        _this.nativeScriptManager = nativeScriptManager;
        if (!nativeScriptManager) {
            throw new Error('repack react-native module was not found.' + ( false ? 0 : ''));
        }
        if (__webpack_require__.repack.shared.scriptManager) {
            throw new Error('ScriptManager was already instantiated. Use ScriptManager.shared instead.');
        }
        __webpack_require__.repack.shared.scriptManager = _this;
        return _this;
    }
    var _proto = ScriptManager.prototype;
    /**
   * Sets a storage backend to cache resolved scripts locator data.
   *
   * The stored data is used to detect if scripts locator data of previously downloaded
   * script hasn't changed to avoid over-fetching the script.
   *
   * @param storage Implementation of storage functions.
   */ _proto.setStorage = function setStorage(storage) {
        this.storage = storage;
    };
    /**
   * Adds new script locator resolver.
   *
   * Resolver is an async function to resolve script locator data - in other words, it's a function to
   * tell the {@link ScriptManager} how to fetch the script.
   *
   * There's no limitation on what logic you can run inside this function - it can include:
   * - fetching/loading remote config
   * - fetching/loading feature flags
   * - fetching/loading A/B testing data
   * - calling native modules
   * - running arbitrary logic
   *
   * @param resolver Resolver function to add.
   * @param options Resolver options.
   */ _proto.addResolver = function addResolver(resolver, options) {
        if (options === void 0) options = {};
        var _options_priority;
        var priority = (_options_priority = options.priority) != null ? _options_priority : DEFAULT_RESOLVER_PRIORITY;
        var uniqueKey = options.key;
        this.resolvers = this.resolvers.filter(function(param) {
            var _param = _sliced_to_array._(param, 1), key = _param[0];
            return key !== uniqueKey;
        }).concat([
            [
                uniqueKey != null ? uniqueKey : DEFAULT_RESOLVER_KEY,
                priority,
                resolver
            ]
        ]).sort(function(param, param1) {
            var _param = _sliced_to_array._(param, 2), a = _param[1];
            var _param1 = _sliced_to_array._(param1, 2), b = _param1[1];
            return b - a;
        });
    };
    /**
   * Removes previously added resolver.
   *
   * @param resolver Resolver function or resolver's `uniqueKey` to remove.
   * @returns `true` if resolver was found and removed, `false` otherwise.
   */ _proto.removeResolver = function removeResolver(resolver) {
        var index;
        if (typeof resolver === 'string') {
            index = this.resolvers.findIndex(function(param) {
                var _param = _sliced_to_array._(param, 1), key = _param[0];
                return key === resolver;
            });
        } else {
            index = this.resolvers.findIndex(function(param) {
                var _param = _sliced_to_array._(param, 3), item = _param[2];
                return item === resolver;
            });
        }
        if (index > -1) {
            this.resolvers.splice(index, 1);
            return true;
        }
        return false;
    };
    /**
   * Removes all previously added resolvers.
   */ _proto.removeAllResolvers = function removeAllResolvers() {
        this.resolvers = [];
    };
    _proto.initCache = function initCache() {
        return _async_to_generator._(function() {
            var _this_storage, cacheEntry;
            return _ts_generator._(this, function(_state) {
                switch(_state.label){
                    case 0:
                        if (!!this.cacheInitialized) return [
                            3,
                            2
                        ];
                        return [
                            4,
                            (_this_storage = this.storage) == null ? void 0 : _this_storage.getItem(CACHE_KEY)
                        ];
                    case 1:
                        cacheEntry = _state.sent();
                        this.cache = cacheEntry ? JSON.parse(cacheEntry) : {};
                        this.cacheInitialized = true;
                        _state.label = 2;
                    case 2:
                        return [
                            2
                        ];
                }
            });
        }).call(this);
    };
    _proto.saveCache = function saveCache() {
        return _async_to_generator._(function() {
            var _this_storage;
            return _ts_generator._(this, function(_state) {
                switch(_state.label){
                    case 0:
                        return [
                            4,
                            (_this_storage = this.storage) == null ? void 0 : _this_storage.setItem(CACHE_KEY, JSON.stringify(this.cache))
                        ];
                    case 1:
                        _state.sent();
                        return [
                            2
                        ];
                }
            });
        }).call(this);
    };
    _proto.handleError = function handleError(error, message) {
        for(var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++){
            args[_key - 2] = arguments[_key];
        }
        var _console;
        (_console = console).error.apply(_console, [
            message
        ].concat(_to_consumable_array._(args), [
            {
                originalError: error
            }
        ]));
        this.emit('error', {
            message: message,
            args: args,
            originalError: error
        });
        throw error;
    };
    /**
   * Resolves a {@link Script} instance with normalized locator data.
   *
   * Resolution will use previously added (via `ScriptManager.shared.addResolver(...)`) resolvers
   * in series, util one returns a locator data or will throw if no resolver handled the request.
   *
   * Use `ScriptManager.shared.on('resolving', ({ scriptId, caller }) => { })` to listen for when
   * the script resolution begins.
   *
   * Use `ScriptManager.shared.on('resolved', (script) => { })` to listen for when
   * the script's locator data is resolved.
   *
   * @param scriptId Id of the script to resolve.
   * @param caller Name of the calling script - it can be for example: name of the bundle, chunk or container.
   */ _proto.resolveScript = function resolveScript() {
        return _async_to_generator._(function(scriptId, caller, webpackContext, referenceUrl) {
            var locator, _i, _this_resolvers, _this_resolvers__i, resolve, script, cacheKey, fetch, error;
            return _ts_generator._(this, function(_state) {
                switch(_state.label){
                    case 0:
                        if (webpackContext === void 0) webpackContext = (0, _getWebpackContext.getWebpackContext)();
                        return [
                            4,
                            this.initCache()
                        ];
                    case 1:
                        _state.sent();
                        _state.label = 2;
                    case 2:
                        _state.trys.push([
                            2,
                            9,
                            ,
                            10
                        ]);
                        if (!this.resolvers.length) {
                            throw new Error('No script resolvers were added. Did you forget to call `ScriptManager.shared.addResolver(...)`?');
                        }
                        this.emit('resolving', {
                            scriptId: scriptId,
                            caller: caller
                        });
                        _i = 0, _this_resolvers = this.resolvers;
                        _state.label = 3;
                    case 3:
                        if (!(_i < _this_resolvers.length)) return [
                            3,
                            6
                        ];
                        _this_resolvers__i = _sliced_to_array._(_this_resolvers[_i], 3), resolve = _this_resolvers__i[2];
                        return [
                            4,
                            resolve(scriptId, caller, referenceUrl)
                        ];
                    case 4:
                        locator = _state.sent();
                        if (locator) {
                            return [
                                3,
                                6
                            ];
                        }
                        _state.label = 5;
                    case 5:
                        _i++;
                        return [
                            3,
                            3
                        ];
                    case 6:
                        if (!locator) {
                            throw new Error("No resolver was able to resolve script " + scriptId);
                        }
                        if (typeof locator.url === 'function') {
                            locator.url = locator.url(webpackContext);
                        }
                        script = _Script.Script.from({
                            scriptId: scriptId,
                            caller: caller
                        }, locator, false);
                        cacheKey = script.locator.uniqueId;
                        if (!locator.shouldUpdateScript) return [
                            3,
                            8
                        ];
                        return [
                            4,
                            locator.shouldUpdateScript(scriptId, caller, script.shouldUpdateCache(this.cache[cacheKey]))
                        ];
                    case 7:
                        fetch = _state.sent();
                        // If it returns true, we need to fetch the script
                        if (fetch) {
                            script.locator.fetch = true;
                        }
                        this.emit('resolved', script.toObject());
                        // if it returns false, we don't need to fetch the script
                        return [
                            2,
                            script
                        ];
                    case 8:
                        // If no custom shouldUpdateScript function was provided, we use the default behaviour
                        if (!this.cache[cacheKey]) {
                            script.locator.fetch = true;
                        } else if (script.shouldRefetch(this.cache[cacheKey])) {
                            script.locator.fetch = true;
                        }
                        this.emit('resolved', script.toObject());
                        return [
                            2,
                            script
                        ];
                    case 9:
                        error = _state.sent();
                        this.handleError(error, '[ScriptManager] Failed while resolving script locator:', {
                            scriptId: scriptId,
                            caller: caller
                        });
                        return [
                            3,
                            10
                        ];
                    case 10:
                        return [
                            2
                        ];
                }
            });
        }).apply(this, arguments);
    };
    _proto.updateCache = function updateCache(script) {
        return _async_to_generator._(function() {
            var cacheKey;
            return _ts_generator._(this, function(_state) {
                switch(_state.label){
                    case 0:
                        if (!script.locator.fetch) return [
                            3,
                            2
                        ];
                        cacheKey = script.locator.uniqueId;
                        this.cache[cacheKey] = script.getCacheData();
                        return [
                            4,
                            this.saveCache()
                        ];
                    case 1:
                        _state.sent();
                        _state.label = 2;
                    case 2:
                        return [
                            2
                        ];
                }
            });
        }).call(this);
    };
    /**
   * Resolves given script's location, downloads and executes it.
   * The execution of the code is handled internally by threading in React Native.
   *
   * Use `ScriptManager.shared.on('loading', (script) => { })` to listen for when
   * the script is about to be loaded.
   *
   * Use `ScriptManager.shared.on('loaded', (script) => { })` to listen for when
   * the script is loaded.
   *
   * @param scriptId Id of the script to load.
   * @param caller Name of the calling script - it can be for example: name of the bundle, chunk or container.
   */ _proto.loadScript = function loadScript() {
        return _async_to_generator._(function(scriptId, caller, webpackContext, referenceUrl) {
            var _this, uniqueId, isPrefetch, loadProcess;
            return _ts_generator._(this, function(_state) {
                switch(_state.label){
                    case 0:
                        _this = this;
                        if (webpackContext === void 0) webpackContext = (0, _getWebpackContext.getWebpackContext)();
                        uniqueId = _Script.Script.getScriptUniqueId(scriptId, caller);
                        if (!this.scriptsPromises[uniqueId]) return [
                            3,
                            3
                        ];
                        isPrefetch = this.scriptsPromises[uniqueId].isPrefetch;
                        if (!isPrefetch) return [
                            3,
                            2
                        ];
                        return [
                            4,
                            this.scriptsPromises[uniqueId]
                        ];
                    case 1:
                        _state.sent();
                        return [
                            3,
                            3
                        ];
                    case 2:
                        return [
                            2,
                            this.scriptsPromises[uniqueId]
                        ];
                    case 3:
                        loadProcess = function() {
                            return _async_to_generator._(function() {
                                var script, error, code;
                                return _ts_generator._(this, function(_state) {
                                    switch(_state.label){
                                        case 0:
                                            return [
                                                4,
                                                this.resolveScript(scriptId, caller, webpackContext, referenceUrl)
                                            ];
                                        case 1:
                                            script = _state.sent();
                                            _state.label = 2;
                                        case 2:
                                            _state.trys.push([
                                                2,
                                                5,
                                                6,
                                                7
                                            ]);
                                            this.emit('loading', script.toObject());
                                            return [
                                                4,
                                                this.loadScriptWithRetry(scriptId, script.locator)
                                            ];
                                        case 3:
                                            _state.sent();
                                            this.emit('loaded', script.toObject());
                                            return [
                                                4,
                                                this.updateCache(script)
                                            ];
                                        case 4:
                                            _state.sent();
                                            return [
                                                3,
                                                7
                                            ];
                                        case 5:
                                            error = _state.sent();
                                            code = error.code;
                                            this.handleError(error, '[ScriptManager] Failed to load script:', code ? "[" + code + "]" : '', script.toObject());
                                            return [
                                                3,
                                                7
                                            ];
                                        case 6:
                                            // should delete script promise even script failed
                                            delete this.scriptsPromises[uniqueId];
                                            return [
                                                7
                                            ];
                                        case 7:
                                            return [
                                                2
                                            ];
                                    }
                                });
                            }).call(_this);
                        };
                        this.scriptsPromises[uniqueId] = loadProcess();
                        return [
                            2,
                            this.scriptsPromises[uniqueId]
                        ];
                }
            });
        }).apply(this, arguments);
    };
    /**
   * Loads a script with retry logic.
   *
   * This function attempts to load a script using the nativeScriptManager.
   * If the initial attempt fails, it retries the specified number of times
   * with an optional delay between retries.
   *
   * @param {string} scriptId - The ID of the script to load.
   * @param {NormalizedScriptLocator} locator - An NormalizedScriptLocator containing retry configuration.
   * @param {number} [locator.retry=0] - The number of retry attempts.
   * @param {number} [locator.retryDelay=0] - The delay in milliseconds between retries.
   * @throws {Error} Throws an error if all retry attempts fail.
   */ _proto.loadScriptWithRetry = function loadScriptWithRetry(scriptId, locator) {
        return _async_to_generator._(function() {
            var _locator_retry, retry, _locator_retryDelay, retryDelay, attempts, error, code;
            return _ts_generator._(this, function(_state) {
                switch(_state.label){
                    case 0:
                        _locator_retry = locator.retry, retry = _locator_retry === void 0 ? 0 : _locator_retry, _locator_retryDelay = locator.retryDelay, retryDelay = _locator_retryDelay === void 0 ? 0 : _locator_retryDelay;
                        attempts = retry + 1; // Include the initial attempt
                        _state.label = 1;
                    case 1:
                        if (!(attempts > 0)) return [
                            3,
                            10
                        ];
                        _state.label = 2;
                    case 2:
                        _state.trys.push([
                            2,
                            4,
                            ,
                            9
                        ]);
                        return [
                            4,
                            this.nativeScriptManager.loadScript(scriptId, locator)
                        ];
                    case 3:
                        _state.sent();
                        return [
                            2
                        ]; // Successfully loaded the script, exit the loop
                    case 4:
                        error = _state.sent();
                        attempts--;
                        code = error.code;
                        if (!(attempts > 0 && LOADING_ERROR_CODES.includes(code))) return [
                            3,
                            7
                        ];
                        if (!(retryDelay > 0)) return [
                            3,
                            6
                        ];
                        return [
                            4,
                            new Promise(function(resolve) {
                                return setTimeout(resolve, retryDelay);
                            })
                        ];
                    case 5:
                        _state.sent();
                        _state.label = 6;
                    case 6:
                        return [
                            3,
                            8
                        ];
                    case 7:
                        throw error; // No more retries, throw the error
                    case 8:
                        return [
                            3,
                            9
                        ];
                    case 9:
                        return [
                            3,
                            1
                        ];
                    case 10:
                        return [
                            2
                        ];
                }
            });
        }).call(this);
    };
    /**
   * Resolves given script's location and downloads it without executing.
   * This function can be awaited to detect if the script was downloaded and for error handling.
   *
   * Use `ScriptManager.shared.on('prefetching', (script) => { })` to listen for when
   * the script's prefetch beings.
   *
   * @param scriptId Id of the script to prefetch.
   * @param caller Name of the calling script - it can be for example: name of the bundle, chunk or container.
   */ _proto.prefetchScript = function prefetchScript() {
        return _async_to_generator._(function(scriptId, caller, webpackContext) {
            var _this, uniqueId, loadProcess;
            return _ts_generator._(this, function(_state) {
                _this = this;
                if (webpackContext === void 0) webpackContext = (0, _getWebpackContext.getWebpackContext)();
                uniqueId = _Script.Script.getScriptUniqueId(scriptId, caller);
                if (this.scriptsPromises[uniqueId]) {
                    return [
                        2,
                        this.scriptsPromises[uniqueId]
                    ];
                }
                loadProcess = function() {
                    return _async_to_generator._(function() {
                        var script, error, code;
                        return _ts_generator._(this, function(_state) {
                            switch(_state.label){
                                case 0:
                                    return [
                                        4,
                                        this.resolveScript(scriptId, caller, webpackContext)
                                    ];
                                case 1:
                                    script = _state.sent();
                                    _state.label = 2;
                                case 2:
                                    _state.trys.push([
                                        2,
                                        5,
                                        6,
                                        7
                                    ]);
                                    this.emit('prefetching', script.toObject());
                                    return [
                                        4,
                                        this.nativeScriptManager.prefetchScript(scriptId, script.locator)
                                    ];
                                case 3:
                                    _state.sent();
                                    return [
                                        4,
                                        this.updateCache(script)
                                    ];
                                case 4:
                                    _state.sent();
                                    return [
                                        3,
                                        7
                                    ];
                                case 5:
                                    error = _state.sent();
                                    code = error.code;
                                    this.handleError(error, '[ScriptManager] Failed to prefetch script:', code ? "[" + code + "]" : '', script.toObject());
                                    return [
                                        3,
                                        7
                                    ];
                                case 6:
                                    // should delete script promise even script failed
                                    delete this.scriptsPromises[uniqueId];
                                    return [
                                        7
                                    ];
                                case 7:
                                    return [
                                        2
                                    ];
                            }
                        });
                    }).call(_this);
                };
                this.scriptsPromises[uniqueId] = loadProcess();
                this.scriptsPromises[uniqueId].isPrefetch = true;
                return [
                    2,
                    this.scriptsPromises[uniqueId]
                ];
            });
        }).apply(this, arguments);
    };
    /**
   * Clears the cache (if configured in {@link ScriptManager.setStorage}) and removes downloaded
   * files for given scripts from the filesystem. This function can be awaited to detect if the
   * scripts were invalidated and for error handling.
   *
   * Use `ScriptManager.shared.on('invalidated', (scriptIds) => { })` to listen for when
   * the invalidation completes.
   *
   * @param scriptIds Array of script ids to clear from cache and remove from filesystem.
   * @returns Array of script ids that were invalidated.
   */ _proto.invalidateScripts = function invalidateScripts() {
        return _async_to_generator._(function(scriptIds) {
            var _this, ids, error, code;
            return _ts_generator._(this, function(_state) {
                switch(_state.label){
                    case 0:
                        _this = this;
                        if (scriptIds === void 0) scriptIds = [];
                        _state.label = 1;
                    case 1:
                        _state.trys.push([
                            1,
                            5,
                            ,
                            6
                        ]);
                        return [
                            4,
                            this.initCache()
                        ];
                    case 2:
                        _state.sent();
                        ids = scriptIds.length ? scriptIds : Object.keys(this.cache);
                        ids.forEach(function(scriptId) {
                            delete _this.cache[scriptId];
                            delete _this.scriptsPromises[scriptId];
                        });
                        return [
                            4,
                            this.saveCache()
                        ];
                    case 3:
                        _state.sent();
                        return [
                            4,
                            this.nativeScriptManager.invalidateScripts(scriptIds)
                        ];
                    case 4:
                        _state.sent();
                        this.emit('invalidated', ids);
                        return [
                            2,
                            ids
                        ];
                    case 5:
                        error = _state.sent();
                        code = error.code;
                        this.handleError(error, '[ScriptManager] Failed to invalidate scripts:', code ? "[" + code + "]" : '');
                        return [
                            3,
                            6
                        ];
                    case 6:
                        return [
                            2
                        ];
                }
            });
        }).apply(this, arguments);
    };
    /**
   * Evaluates a script synchronously.
   *
   * This function sends the script source and its URL to the native script manager for evaluation.
   * It is functionally identical to `globalEvalWithSourceUrl`.
   *
   * @param scriptSource The source code of the script to evaluate.
   * @param scriptSourceUrl The URL of the script source, used for debugging purposes.
   */ _proto.unstable_evaluateScript = function unstable_evaluateScript(scriptSource, scriptSourceUrl) {
        this.nativeScriptManager.unstable_evaluateScript(scriptSource, scriptSourceUrl);
    };
    ScriptManager.init = function init() {
        if (!__webpack_require__.repack.shared.scriptManager) {
            __webpack_require__.repack.shared.scriptManager = new ScriptManager();
        }
    };
    _create_class._(ScriptManager, null, [
        {
            key: "shared",
            get: function get() {
                return __webpack_require__.repack.shared.scriptManager;
            }
        }
    ]);
    return ScriptManager;
} //# sourceMappingURL=ScriptManager.js.map
(_events.default);


}),
72216: (function (__unused_webpack_module, exports) {
"use strict";

function _array_like_to_array(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
exports._ = _array_like_to_array;


}),
72884: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _sliced_to_array = __webpack_require__(21193);
var _type_of = __webpack_require__(29936);
var polyfills = __webpack_require__(75452);
var sdk = __webpack_require__(58506);
function getBuilderId() {
    //@ts-ignore
    return  true ? "auth:0.0.1" : 0;
}
var LOG_CATEGORY = '[ Federation Runtime ]';
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
function assert(condition, msg) {
    if (!condition) {
        error(msg);
    }
}
function error(msg) {
    if (msg instanceof Error) {
        msg.message = LOG_CATEGORY + ": " + msg.message;
        throw msg;
    }
    throw new Error(LOG_CATEGORY + ": " + msg);
}
function warn(msg) {
    if (msg instanceof Error) {
        msg.message = LOG_CATEGORY + ": " + msg.message;
        console.warn(msg);
    } else {
        console.warn(LOG_CATEGORY + ": " + msg);
    }
}
function addUniqueItem(arr, item) {
    if (arr.findIndex(function(name) {
        return name === item;
    }) === -1) {
        arr.push(item);
    }
    return arr;
}
function getFMId(remoteInfo) {
    if ('version' in remoteInfo && remoteInfo.version) {
        return remoteInfo.name + ":" + remoteInfo.version;
    } else if ('entry' in remoteInfo && remoteInfo.entry) {
        return remoteInfo.name + ":" + remoteInfo.entry;
    } else {
        return "" + remoteInfo.name;
    }
}
function isRemoteInfoWithEntry(remote) {
    return typeof remote.entry !== 'undefined';
}
function isPureRemoteEntry(remote) {
    return !remote.entry.includes('.json') && remote.entry.includes('.js');
}
function isObject(val) {
    return val && (typeof val === "undefined" ? "undefined" : _type_of._(val)) === 'object';
}
var objectToString = Object.prototype.toString;
// eslint-disable-next-line @typescript-eslint/ban-types
function isPlainObject(val) {
    return objectToString.call(val) === '[object Object]';
}
function arrayOptions(options) {
    return Array.isArray(options) ? options : [
        options
    ];
}
function getRemoteEntryInfoFromSnapshot(snapshot) {
    var defaultRemoteEntryInfo = {
        url: '',
        type: 'global',
        globalName: ''
    };
    if (sdk.isBrowserEnv()) {
        return 'remoteEntry' in snapshot ? {
            url: snapshot.remoteEntry,
            type: snapshot.remoteEntryType,
            globalName: snapshot.globalName
        } : defaultRemoteEntryInfo;
    }
    if ('ssrRemoteEntry' in snapshot) {
        return {
            url: snapshot.ssrRemoteEntry || defaultRemoteEntryInfo.url,
            type: snapshot.ssrRemoteEntryType || defaultRemoteEntryInfo.type,
            globalName: snapshot.globalName
        };
    }
    return defaultRemoteEntryInfo;
}
var nativeGlobal = function() {
    try {
        return new Function('return this')();
    } catch (e) {
        return globalThis;
    }
}();
var Global = nativeGlobal;
function definePropertyGlobalVal(target, key, val) {
    Object.defineProperty(target, key, {
        value: val,
        configurable: false,
        writable: true
    });
}
function includeOwnProperty(target, key) {
    return Object.hasOwnProperty.call(target, key);
}
// This section is to prevent encapsulation by certain microfrontend frameworks. Due to reuse policies, sandbox escapes.
// The sandbox in the microfrontend does not replicate the value of 'configurable'.
// If there is no loading content on the global object, this section defines the loading object.
if (!includeOwnProperty(globalThis, '__GLOBAL_LOADING_REMOTE_ENTRY__')) {
    definePropertyGlobalVal(globalThis, '__GLOBAL_LOADING_REMOTE_ENTRY__', {});
}
var globalLoading = globalThis.__GLOBAL_LOADING_REMOTE_ENTRY__;
function setGlobalDefaultVal(target) {
    var _target___FEDERATION__, _target___FEDERATION__1, _target___FEDERATION__2, _target___FEDERATION__3, _target___FEDERATION__4, _target___FEDERATION__5;
    if (includeOwnProperty(target, '__VMOK__') && !includeOwnProperty(target, '__FEDERATION__')) {
        definePropertyGlobalVal(target, '__FEDERATION__', target.__VMOK__);
    }
    if (!includeOwnProperty(target, '__FEDERATION__')) {
        definePropertyGlobalVal(target, '__FEDERATION__', {
            __GLOBAL_PLUGIN__: [],
            __INSTANCES__: [],
            moduleInfo: {},
            __SHARE__: {},
            __MANIFEST_LOADING__: {},
            __PRELOADED_MAP__: new Map()
        });
        definePropertyGlobalVal(target, '__VMOK__', target.__FEDERATION__);
    }
    var ___GLOBAL_PLUGIN__;
    (___GLOBAL_PLUGIN__ = (_target___FEDERATION__ = target.__FEDERATION__).__GLOBAL_PLUGIN__) != null ? ___GLOBAL_PLUGIN__ : _target___FEDERATION__.__GLOBAL_PLUGIN__ = [];
    var ___INSTANCES__;
    (___INSTANCES__ = (_target___FEDERATION__1 = target.__FEDERATION__).__INSTANCES__) != null ? ___INSTANCES__ : _target___FEDERATION__1.__INSTANCES__ = [];
    var _moduleInfo;
    (_moduleInfo = (_target___FEDERATION__2 = target.__FEDERATION__).moduleInfo) != null ? _moduleInfo : _target___FEDERATION__2.moduleInfo = {};
    var ___SHARE__;
    (___SHARE__ = (_target___FEDERATION__3 = target.__FEDERATION__).__SHARE__) != null ? ___SHARE__ : _target___FEDERATION__3.__SHARE__ = {};
    var ___MANIFEST_LOADING__;
    (___MANIFEST_LOADING__ = (_target___FEDERATION__4 = target.__FEDERATION__).__MANIFEST_LOADING__) != null ? ___MANIFEST_LOADING__ : _target___FEDERATION__4.__MANIFEST_LOADING__ = {};
    var ___PRELOADED_MAP__;
    (___PRELOADED_MAP__ = (_target___FEDERATION__5 = target.__FEDERATION__).__PRELOADED_MAP__) != null ? ___PRELOADED_MAP__ : _target___FEDERATION__5.__PRELOADED_MAP__ = new Map();
}
setGlobalDefaultVal(globalThis);
setGlobalDefaultVal(nativeGlobal);
function resetFederationGlobalInfo() {
    globalThis.__FEDERATION__.__GLOBAL_PLUGIN__ = [];
    globalThis.__FEDERATION__.__INSTANCES__ = [];
    globalThis.__FEDERATION__.moduleInfo = {};
    globalThis.__FEDERATION__.__SHARE__ = {};
    globalThis.__FEDERATION__.__MANIFEST_LOADING__ = {};
}
function getGlobalFederationInstance(name, version) {
    var buildId = getBuilderId();
    return globalThis.__FEDERATION__.__INSTANCES__.find(function(GMInstance) {
        if (buildId && GMInstance.options.id === getBuilderId()) {
            return true;
        }
        if (GMInstance.options.name === name && !GMInstance.options.version && !version) {
            return true;
        }
        if (GMInstance.options.name === name && version && GMInstance.options.version === version) {
            return true;
        }
        return false;
    });
}
function setGlobalFederationInstance(FederationInstance) {
    globalThis.__FEDERATION__.__INSTANCES__.push(FederationInstance);
}
function getGlobalFederationConstructor() {
    return globalThis.__FEDERATION__.__DEBUG_CONSTRUCTOR__;
}
function setGlobalFederationConstructor(FederationConstructor, isDebug) {
    if (isDebug === void 0) isDebug = sdk.isDebugMode();
    if (isDebug) {
        globalThis.__FEDERATION__.__DEBUG_CONSTRUCTOR__ = FederationConstructor;
        globalThis.__FEDERATION__.__DEBUG_CONSTRUCTOR_VERSION__ = "0.6.13";
    }
}
// eslint-disable-next-line @typescript-eslint/ban-types
function getInfoWithoutType(target, key) {
    if (typeof key === 'string') {
        var keyRes = target[key];
        if (keyRes) {
            return {
                value: target[key],
                key: key
            };
        } else {
            var targetKeys = Object.keys(target);
            for(var _i = 0; _i < targetKeys.length; _i++){
                var targetKey = targetKeys[_i];
                var _targetKey_split = _sliced_to_array._(targetKey.split(':'), 2), targetTypeOrName = _targetKey_split[0], _ = _targetKey_split[1];
                var nKey = targetTypeOrName + ":" + key;
                var typeWithKeyRes = target[nKey];
                if (typeWithKeyRes) {
                    return {
                        value: typeWithKeyRes,
                        key: nKey
                    };
                }
            }
            return {
                value: undefined,
                key: key
            };
        }
    } else {
        throw new Error('key must be string');
    }
}
var getGlobalSnapshot = function() {
    return nativeGlobal.__FEDERATION__.moduleInfo;
};
var getTargetSnapshotInfoByModuleInfo = function(moduleInfo, snapshot) {
    // Check if the remote is included in the hostSnapshot
    var moduleKey = getFMId(moduleInfo);
    var getModuleInfo = getInfoWithoutType(snapshot, moduleKey).value;
    // The remoteSnapshot might not include a version
    if (getModuleInfo && !getModuleInfo.version && 'version' in moduleInfo && moduleInfo['version']) {
        getModuleInfo.version = moduleInfo['version'];
    }
    if (getModuleInfo) {
        return getModuleInfo;
    }
    // If the remote is not included in the hostSnapshot, deploy a micro app snapshot
    if ('version' in moduleInfo && moduleInfo['version']) {
        var version = moduleInfo.version, resModuleInfo = polyfills._object_without_properties_loose(moduleInfo, [
            "version"
        ]);
        var moduleKeyWithoutVersion = getFMId(resModuleInfo);
        var getModuleInfoWithoutVersion = getInfoWithoutType(nativeGlobal.__FEDERATION__.moduleInfo, moduleKeyWithoutVersion).value;
        if ((getModuleInfoWithoutVersion == null ? void 0 : getModuleInfoWithoutVersion.version) === version) {
            return getModuleInfoWithoutVersion;
        }
    }
    return;
};
var getGlobalSnapshotInfoByModuleInfo = function(moduleInfo) {
    return getTargetSnapshotInfoByModuleInfo(moduleInfo, nativeGlobal.__FEDERATION__.moduleInfo);
};
var setGlobalSnapshotInfoByModuleInfo = function(remoteInfo, moduleDetailInfo) {
    var moduleKey = getFMId(remoteInfo);
    nativeGlobal.__FEDERATION__.moduleInfo[moduleKey] = moduleDetailInfo;
    return nativeGlobal.__FEDERATION__.moduleInfo;
};
var addGlobalSnapshot = function(moduleInfos) {
    nativeGlobal.__FEDERATION__.moduleInfo = polyfills._extends({}, nativeGlobal.__FEDERATION__.moduleInfo, moduleInfos);
    return function() {
        var keys = Object.keys(moduleInfos);
        for(var _i = 0; _i < keys.length; _i++){
            var key = keys[_i];
            delete nativeGlobal.__FEDERATION__.moduleInfo[key];
        }
    };
};
var getRemoteEntryExports = function(name, globalName) {
    var remoteEntryKey = globalName || "__FEDERATION_" + name + ":custom__";
    var entryExports = globalThis[remoteEntryKey];
    return {
        remoteEntryKey: remoteEntryKey,
        entryExports: entryExports
    };
};
// This function is used to register global plugins.
// It iterates over the provided plugins and checks if they are already registered.
// If a plugin is not registered, it is added to the global plugins.
// If a plugin is already registered, a warning message is logged.
var registerGlobalPlugins = function(plugins) {
    var __GLOBAL_PLUGIN__ = nativeGlobal.__FEDERATION__.__GLOBAL_PLUGIN__;
    plugins.forEach(function(plugin) {
        if (__GLOBAL_PLUGIN__.findIndex(function(p) {
            return p.name === plugin.name;
        }) === -1) {
            __GLOBAL_PLUGIN__.push(plugin);
        } else {
            warn("The plugin " + plugin.name + " has been registered.");
        }
    });
};
var getGlobalHostPlugins = function() {
    return nativeGlobal.__FEDERATION__.__GLOBAL_PLUGIN__;
};
var getPreloaded = function(id) {
    return globalThis.__FEDERATION__.__PRELOADED_MAP__.get(id);
};
var setPreloaded = function(id) {
    return globalThis.__FEDERATION__.__PRELOADED_MAP__.set(id, true);
};
var DEFAULT_SCOPE = 'default';
var DEFAULT_REMOTE_TYPE = 'global';
// fork from https://github.com/originjs/vite-plugin-federation/blob/v1.1.12/packages/lib/src/utils/semver/index.ts
// those constants are based on https://www.rubydoc.info/gems/semantic_range/3.0.0/SemanticRange#BUILDIDENTIFIER-constant
// Copyright (c)
// vite-plugin-federation is licensed under Mulan PSL v2.
// You can use this software according to the terms and conditions of the Mulan PSL v2.
// You may obtain a copy of Mulan PSL v2 at:
//      http://license.coscl.org.cn/MulanPSL2
// THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
// See the Mulan PSL v2 for more details.
var buildIdentifier = '[0-9A-Za-z-]+';
var build = "(?:\\+(" + buildIdentifier + "(?:\\." + buildIdentifier + ")*))";
var numericIdentifier = '0|[1-9]\\d*';
var numericIdentifierLoose = '[0-9]+';
var nonNumericIdentifier = '\\d*[a-zA-Z-][a-zA-Z0-9-]*';
var preReleaseIdentifierLoose = "(?:" + numericIdentifierLoose + "|" + nonNumericIdentifier + ")";
var preReleaseLoose = "(?:-?(" + preReleaseIdentifierLoose + "(?:\\." + preReleaseIdentifierLoose + ")*))";
var preReleaseIdentifier = "(?:" + numericIdentifier + "|" + nonNumericIdentifier + ")";
var preRelease = "(?:-(" + preReleaseIdentifier + "(?:\\." + preReleaseIdentifier + ")*))";
var xRangeIdentifier = "" + numericIdentifier + "|x|X|\\*";
var xRangePlain = "[v=\\s]*(" + xRangeIdentifier + ")(?:\\.(" + xRangeIdentifier + ")(?:\\.(" + xRangeIdentifier + ")(?:" + preRelease + ")?" + build + "?)?)?";
var hyphenRange = "^\\s*(" + xRangePlain + ")\\s+-\\s+(" + xRangePlain + ")\\s*$";
var mainVersionLoose = "(" + numericIdentifierLoose + ")\\.(" + numericIdentifierLoose + ")\\.(" + numericIdentifierLoose + ")";
var loosePlain = "[v=\\s]*" + mainVersionLoose + preReleaseLoose + "?" + build + "?";
var gtlt = '((?:<|>)?=?)';
var comparatorTrim = "(\\s*)" + gtlt + "\\s*(" + loosePlain + "|" + xRangePlain + ")";
var loneTilde = '(?:~>?)';
var tildeTrim = "(\\s*)" + loneTilde + "\\s+";
var loneCaret = '(?:\\^)';
var caretTrim = "(\\s*)" + loneCaret + "\\s+";
var star = '(<|>)?=?\\s*\\*';
var caret = "^" + loneCaret + xRangePlain + "$";
var mainVersion = "(" + numericIdentifier + ")\\.(" + numericIdentifier + ")\\.(" + numericIdentifier + ")";
var fullPlain = "v?" + mainVersion + preRelease + "?" + build + "?";
var tilde = "^" + loneTilde + xRangePlain + "$";
var xRange = "^" + gtlt + "\\s*" + xRangePlain + "$";
var comparator = "^" + gtlt + "\\s*(" + fullPlain + ")$|^$";
// copy from semver package
var gte0 = '^\\s*>=\\s*0.0.0\\s*$';
// fork from https://github.com/originjs/vite-plugin-federation/blob/v1.1.12/packages/lib/src/utils/semver/index.ts
// Copyright (c)
// vite-plugin-federation is licensed under Mulan PSL v2.
// You can use this software according to the terms and conditions of the Mulan PSL v2.
// You may obtain a copy of Mulan PSL v2 at:
//      http://license.coscl.org.cn/MulanPSL2
// THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
// See the Mulan PSL v2 for more details.
function parseRegex(source) {
    return new RegExp(source);
}
function isXVersion(version) {
    return !version || version.toLowerCase() === 'x' || version === '*';
}
function pipe() {
    for(var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++){
        fns[_key] = arguments[_key];
    }
    return function(x) {
        return fns.reduce(function(v, f) {
            return f(v);
        }, x);
    };
}
function extractComparator(comparatorString) {
    return comparatorString.match(parseRegex(comparator));
}
function combineVersion(major, minor, patch, preRelease) {
    var mainVersion = major + "." + minor + "." + patch;
    if (preRelease) {
        return mainVersion + "-" + preRelease;
    }
    return mainVersion;
}
// fork from https://github.com/originjs/vite-plugin-federation/blob/v1.1.12/packages/lib/src/utils/semver/index.ts
// Copyright (c)
// vite-plugin-federation is licensed under Mulan PSL v2.
// You can use this software according to the terms and conditions of the Mulan PSL v2.
// You may obtain a copy of Mulan PSL v2 at:
//      http://license.coscl.org.cn/MulanPSL2
// THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
// See the Mulan PSL v2 for more details.
function parseHyphen(range) {
    return range.replace(parseRegex(hyphenRange), function(_range, from, fromMajor, fromMinor, fromPatch, _fromPreRelease, _fromBuild, to, toMajor, toMinor, toPatch, toPreRelease) {
        if (isXVersion(fromMajor)) {
            from = '';
        } else if (isXVersion(fromMinor)) {
            from = ">=" + fromMajor + ".0.0";
        } else if (isXVersion(fromPatch)) {
            from = ">=" + fromMajor + "." + fromMinor + ".0";
        } else {
            from = ">=" + from;
        }
        if (isXVersion(toMajor)) {
            to = '';
        } else if (isXVersion(toMinor)) {
            to = "<" + (Number(toMajor) + 1) + ".0.0-0";
        } else if (isXVersion(toPatch)) {
            to = "<" + toMajor + "." + (Number(toMinor) + 1) + ".0-0";
        } else if (toPreRelease) {
            to = "<=" + toMajor + "." + toMinor + "." + toPatch + "-" + toPreRelease;
        } else {
            to = "<=" + to;
        }
        return (from + " " + to).trim();
    });
}
function parseComparatorTrim(range) {
    return range.replace(parseRegex(comparatorTrim), '$1$2$3');
}
function parseTildeTrim(range) {
    return range.replace(parseRegex(tildeTrim), '$1~');
}
function parseCaretTrim(range) {
    return range.replace(parseRegex(caretTrim), '$1^');
}
function parseCarets(range) {
    return range.trim().split(/\s+/).map(function(rangeVersion) {
        return rangeVersion.replace(parseRegex(caret), function(_, major, minor, patch, preRelease) {
            if (isXVersion(major)) {
                return '';
            } else if (isXVersion(minor)) {
                return ">=" + major + ".0.0 <" + (Number(major) + 1) + ".0.0-0";
            } else if (isXVersion(patch)) {
                if (major === '0') {
                    return ">=" + major + "." + minor + ".0 <" + major + "." + (Number(minor) + 1) + ".0-0";
                } else {
                    return ">=" + major + "." + minor + ".0 <" + (Number(major) + 1) + ".0.0-0";
                }
            } else if (preRelease) {
                if (major === '0') {
                    if (minor === '0') {
                        return ">=" + major + "." + minor + "." + patch + "-" + preRelease + " <" + major + "." + minor + "." + (Number(patch) + 1) + "-0";
                    } else {
                        return ">=" + major + "." + minor + "." + patch + "-" + preRelease + " <" + major + "." + (Number(minor) + 1) + ".0-0";
                    }
                } else {
                    return ">=" + major + "." + minor + "." + patch + "-" + preRelease + " <" + (Number(major) + 1) + ".0.0-0";
                }
            } else {
                if (major === '0') {
                    if (minor === '0') {
                        return ">=" + major + "." + minor + "." + patch + " <" + major + "." + minor + "." + (Number(patch) + 1) + "-0";
                    } else {
                        return ">=" + major + "." + minor + "." + patch + " <" + major + "." + (Number(minor) + 1) + ".0-0";
                    }
                }
                return ">=" + major + "." + minor + "." + patch + " <" + (Number(major) + 1) + ".0.0-0";
            }
        });
    }).join(' ');
}
function parseTildes(range) {
    return range.trim().split(/\s+/).map(function(rangeVersion) {
        return rangeVersion.replace(parseRegex(tilde), function(_, major, minor, patch, preRelease) {
            if (isXVersion(major)) {
                return '';
            } else if (isXVersion(minor)) {
                return ">=" + major + ".0.0 <" + (Number(major) + 1) + ".0.0-0";
            } else if (isXVersion(patch)) {
                return ">=" + major + "." + minor + ".0 <" + major + "." + (Number(minor) + 1) + ".0-0";
            } else if (preRelease) {
                return ">=" + major + "." + minor + "." + patch + "-" + preRelease + " <" + major + "." + (Number(minor) + 1) + ".0-0";
            }
            return ">=" + major + "." + minor + "." + patch + " <" + major + "." + (Number(minor) + 1) + ".0-0";
        });
    }).join(' ');
}
function parseXRanges(range) {
    return range.split(/\s+/).map(function(rangeVersion) {
        return rangeVersion.trim().replace(parseRegex(xRange), function(ret, gtlt, major, minor, patch, preRelease) {
            var isXMajor = isXVersion(major);
            var isXMinor = isXMajor || isXVersion(minor);
            var isXPatch = isXMinor || isXVersion(patch);
            if (gtlt === '=' && isXPatch) {
                gtlt = '';
            }
            preRelease = '';
            if (isXMajor) {
                if (gtlt === '>' || gtlt === '<') {
                    // nothing is allowed
                    return '<0.0.0-0';
                } else {
                    // nothing is forbidden
                    return '*';
                }
            } else if (gtlt && isXPatch) {
                // replace X with 0
                if (isXMinor) {
                    minor = 0;
                }
                patch = 0;
                if (gtlt === '>') {
                    // >1 => >=2.0.0
                    // >1.2 => >=1.3.0
                    gtlt = '>=';
                    if (isXMinor) {
                        major = Number(major) + 1;
                        minor = 0;
                        patch = 0;
                    } else {
                        minor = Number(minor) + 1;
                        patch = 0;
                    }
                } else if (gtlt === '<=') {
                    // <=0.7.x is actually <0.8.0, since any 0.7.x should pass
                    // Similarly, <=7.x is actually <8.0.0, etc.
                    gtlt = '<';
                    if (isXMinor) {
                        major = Number(major) + 1;
                    } else {
                        minor = Number(minor) + 1;
                    }
                }
                if (gtlt === '<') {
                    preRelease = '-0';
                }
                return gtlt + major + "." + minor + "." + patch + preRelease;
            } else if (isXMinor) {
                return ">=" + major + ".0.0" + preRelease + " <" + (Number(major) + 1) + ".0.0-0";
            } else if (isXPatch) {
                return ">=" + major + "." + minor + ".0" + preRelease + " <" + major + "." + (Number(minor) + 1) + ".0-0";
            }
            return ret;
        });
    }).join(' ');
}
function parseStar(range) {
    return range.trim().replace(parseRegex(star), '');
}
function parseGTE0(comparatorString) {
    return comparatorString.trim().replace(parseRegex(gte0), '');
}
// fork from https://github.com/originjs/vite-plugin-federation/blob/v1.1.12/packages/lib/src/utils/semver/index.ts
// Copyright (c)
// vite-plugin-federation is licensed under Mulan PSL v2.
// You can use this software according to the terms and conditions of the Mulan PSL v2.
// You may obtain a copy of Mulan PSL v2 at:
//      http://license.coscl.org.cn/MulanPSL2
// THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
// See the Mulan PSL v2 for more details.
function compareAtom(rangeAtom, versionAtom) {
    rangeAtom = Number(rangeAtom) || rangeAtom;
    versionAtom = Number(versionAtom) || versionAtom;
    if (rangeAtom > versionAtom) {
        return 1;
    }
    if (rangeAtom === versionAtom) {
        return 0;
    }
    return -1;
}
function comparePreRelease(rangeAtom, versionAtom) {
    var rangePreRelease = rangeAtom.preRelease;
    var versionPreRelease = versionAtom.preRelease;
    if (rangePreRelease === undefined && Boolean(versionPreRelease)) {
        return 1;
    }
    if (Boolean(rangePreRelease) && versionPreRelease === undefined) {
        return -1;
    }
    if (rangePreRelease === undefined && versionPreRelease === undefined) {
        return 0;
    }
    for(var i = 0, n = rangePreRelease.length; i <= n; i++){
        var rangeElement = rangePreRelease[i];
        var versionElement = versionPreRelease[i];
        if (rangeElement === versionElement) {
            continue;
        }
        if (rangeElement === undefined && versionElement === undefined) {
            return 0;
        }
        if (!rangeElement) {
            return 1;
        }
        if (!versionElement) {
            return -1;
        }
        return compareAtom(rangeElement, versionElement);
    }
    return 0;
}
function compareVersion(rangeAtom, versionAtom) {
    return compareAtom(rangeAtom.major, versionAtom.major) || compareAtom(rangeAtom.minor, versionAtom.minor) || compareAtom(rangeAtom.patch, versionAtom.patch) || comparePreRelease(rangeAtom, versionAtom);
}
function eq(rangeAtom, versionAtom) {
    return rangeAtom.version === versionAtom.version;
}
function compare(rangeAtom, versionAtom) {
    switch(rangeAtom.operator){
        case '':
        case '=':
            return eq(rangeAtom, versionAtom);
        case '>':
            return compareVersion(rangeAtom, versionAtom) < 0;
        case '>=':
            return eq(rangeAtom, versionAtom) || compareVersion(rangeAtom, versionAtom) < 0;
        case '<':
            return compareVersion(rangeAtom, versionAtom) > 0;
        case '<=':
            return eq(rangeAtom, versionAtom) || compareVersion(rangeAtom, versionAtom) > 0;
        case undefined:
            {
                // mean * or x -> all versions
                return true;
            }
        default:
            return false;
    }
}
// fork from https://github.com/originjs/vite-plugin-federation/blob/v1.1.12/packages/lib/src/utils/semver/index.ts
// Copyright (c)
// vite-plugin-federation is licensed under Mulan PSL v2.
// You can use this software according to the terms and conditions of the Mulan PSL v2.
// You may obtain a copy of Mulan PSL v2 at:
//      http://license.coscl.org.cn/MulanPSL2
// THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
// See the Mulan PSL v2 for more details.
function parseComparatorString(range) {
    return pipe(// ^ --> * (any, kinda silly)
    // ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0-0
    // ^2.0, ^2.0.x --> >=2.0.0 <3.0.0-0
    // ^1.2, ^1.2.x --> >=1.2.0 <2.0.0-0
    // ^1.2.3 --> >=1.2.3 <2.0.0-0
    // ^1.2.0 --> >=1.2.0 <2.0.0-0
    parseCarets, // ~, ~> --> * (any, kinda silly)
    // ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0-0
    // ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0-0
    // ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0-0
    // ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0-0
    // ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0-0
    parseTildes, parseXRanges, parseStar)(range);
}
function parseRange(range) {
    return pipe(// `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
    parseHyphen, // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
    parseComparatorTrim, // `~ 1.2.3` => `~1.2.3`
    parseTildeTrim, // `^ 1.2.3` => `^1.2.3`
    parseCaretTrim)(range.trim()).split(/\s+/).join(' ');
}
function satisfy(version, range) {
    if (!version) {
        return false;
    }
    var parsedRange = parseRange(range);
    var parsedComparator = parsedRange.split(' ').map(function(rangeVersion) {
        return parseComparatorString(rangeVersion);
    }).join(' ');
    var comparators = parsedComparator.split(/\s+/).map(function(comparator) {
        return parseGTE0(comparator);
    });
    var extractedVersion = extractComparator(version);
    if (!extractedVersion) {
        return false;
    }
    var _extractedVersion = _sliced_to_array._(extractedVersion, 7), versionOperator = _extractedVersion[1], versionMajor = _extractedVersion[3], versionMinor = _extractedVersion[4], versionPatch = _extractedVersion[5], versionPreRelease = _extractedVersion[6];
    var versionAtom = {
        operator: versionOperator,
        version: combineVersion(versionMajor, versionMinor, versionPatch, versionPreRelease),
        major: versionMajor,
        minor: versionMinor,
        patch: versionPatch,
        preRelease: versionPreRelease == null ? void 0 : versionPreRelease.split('.')
    };
    for(var _i = 0; _i < comparators.length; _i++){
        var comparator = comparators[_i];
        var extractedComparator = extractComparator(comparator);
        if (!extractedComparator) {
            return false;
        }
        var _extractedComparator = _sliced_to_array._(extractedComparator, 7), rangeOperator = _extractedComparator[1], rangeMajor = _extractedComparator[3], rangeMinor = _extractedComparator[4], rangePatch = _extractedComparator[5], rangePreRelease = _extractedComparator[6];
        var rangeAtom = {
            operator: rangeOperator,
            version: combineVersion(rangeMajor, rangeMinor, rangePatch, rangePreRelease),
            major: rangeMajor,
            minor: rangeMinor,
            patch: rangePatch,
            preRelease: rangePreRelease == null ? void 0 : rangePreRelease.split('.')
        };
        if (!compare(rangeAtom, versionAtom)) {
            return false; // early return
        }
    }
    return true;
}
function formatShare(shareArgs, from, name, shareStrategy) {
    var get;
    if ('get' in shareArgs) {
        // eslint-disable-next-line prefer-destructuring
        get = shareArgs.get;
    } else if ('lib' in shareArgs) {
        get = function() {
            return Promise.resolve(shareArgs.lib);
        };
    } else {
        get = function() {
            return Promise.resolve(function() {
                throw new Error("Can not get shared '" + name + "'!");
            });
        };
    }
    if (shareArgs.strategy) {
        warn('"shared.strategy is deprecated, please set in initOptions.shareStrategy instead!"');
    }
    var _shareArgs_version, _shareArgs_scope, _shareArgs_strategy;
    return polyfills._extends({
        deps: [],
        useIn: [],
        from: from,
        loading: null
    }, shareArgs, {
        shareConfig: polyfills._extends({
            requiredVersion: "^" + shareArgs.version,
            singleton: false,
            eager: false,
            strictVersion: false
        }, shareArgs.shareConfig),
        get: get,
        loaded: (shareArgs == null ? void 0 : shareArgs.loaded) || 'lib' in shareArgs ? true : undefined,
        version: (_shareArgs_version = shareArgs.version) != null ? _shareArgs_version : '0',
        scope: Array.isArray(shareArgs.scope) ? shareArgs.scope : [
            (_shareArgs_scope = shareArgs.scope) != null ? _shareArgs_scope : 'default'
        ],
        strategy: ((_shareArgs_strategy = shareArgs.strategy) != null ? _shareArgs_strategy : shareStrategy) || 'version-first'
    });
}
function formatShareConfigs(globalOptions, userOptions) {
    var shareArgs = userOptions.shared || {};
    var from = userOptions.name;
    var shareInfos = Object.keys(shareArgs).reduce(function(res, pkgName) {
        var arrayShareArgs = arrayOptions(shareArgs[pkgName]);
        res[pkgName] = res[pkgName] || [];
        arrayShareArgs.forEach(function(shareConfig) {
            res[pkgName].push(formatShare(shareConfig, from, pkgName, userOptions.shareStrategy));
        });
        return res;
    }, {});
    var shared = polyfills._extends({}, globalOptions.shared);
    Object.keys(shareInfos).forEach(function(shareKey) {
        if (!shared[shareKey]) {
            shared[shareKey] = shareInfos[shareKey];
        } else {
            shareInfos[shareKey].forEach(function(newUserSharedOptions) {
                var isSameVersion = shared[shareKey].find(function(sharedVal) {
                    return sharedVal.version === newUserSharedOptions.version;
                });
                if (!isSameVersion) {
                    shared[shareKey].push(newUserSharedOptions);
                }
            });
        }
    });
    return {
        shared: shared,
        shareInfos: shareInfos
    };
}
function versionLt(a, b) {
    var transformInvalidVersion = function(version) {
        var isNumberVersion = !Number.isNaN(Number(version));
        if (isNumberVersion) {
            var splitArr = version.split('.');
            var validVersion = version;
            for(var i = 0; i < 3 - splitArr.length; i++){
                validVersion += '.0';
            }
            return validVersion;
        }
        return version;
    };
    if (satisfy(transformInvalidVersion(a), "<=" + transformInvalidVersion(b))) {
        return true;
    } else {
        return false;
    }
}
var findVersion = function(shareVersionMap, cb) {
    var callback = cb || function(prev, cur) {
        return versionLt(prev, cur);
    };
    return Object.keys(shareVersionMap).reduce(function(prev, cur) {
        if (!prev) {
            return cur;
        }
        if (callback(prev, cur)) {
            return cur;
        }
        // default version is '0' https://github.com/webpack/webpack/blob/main/lib/sharing/ProvideSharedModule.js#L136
        if (prev === '0') {
            return cur;
        }
        return prev;
    }, 0);
};
var isLoaded = function(shared) {
    return Boolean(shared.loaded) || typeof shared.lib === 'function';
};
function findSingletonVersionOrderByVersion(shareScopeMap, scope, pkgName) {
    var versions = shareScopeMap[scope][pkgName];
    var callback = function callback(prev, cur) {
        return !isLoaded(versions[prev]) && versionLt(prev, cur);
    };
    return findVersion(shareScopeMap[scope][pkgName], callback);
}
function findSingletonVersionOrderByLoaded(shareScopeMap, scope, pkgName) {
    var versions = shareScopeMap[scope][pkgName];
    var callback = function callback(prev, cur) {
        if (isLoaded(versions[cur])) {
            if (isLoaded(versions[prev])) {
                return Boolean(versionLt(prev, cur));
            } else {
                return true;
            }
        }
        if (isLoaded(versions[prev])) {
            return false;
        }
        return versionLt(prev, cur);
    };
    return findVersion(shareScopeMap[scope][pkgName], callback);
}
function getFindShareFunction(strategy) {
    if (strategy === 'loaded-first') {
        return findSingletonVersionOrderByLoaded;
    }
    return findSingletonVersionOrderByVersion;
}
function getRegisteredShare(localShareScopeMap, pkgName, shareInfo, resolveShare) {
    var _loop = function(_i) {
        var sc = scopes[_i];
        if (shareConfig && localShareScopeMap[sc] && localShareScopeMap[sc][pkgName]) {
            var requiredVersion = shareConfig.requiredVersion;
            var findShareFunction = getFindShareFunction(strategy);
            var maxOrSingletonVersion = findShareFunction(localShareScopeMap, sc, pkgName);
            //@ts-ignore
            var defaultResolver = function() {
                if (shareConfig.singleton) {
                    if (typeof requiredVersion === 'string' && !satisfy(maxOrSingletonVersion, requiredVersion)) {
                        var msg = "Version " + maxOrSingletonVersion + " from " + (maxOrSingletonVersion && localShareScopeMap[sc][pkgName][maxOrSingletonVersion].from) + " of shared singleton module " + pkgName + " does not satisfy the requirement of " + shareInfo.from + " which needs " + requiredVersion + ")";
                        if (shareConfig.strictVersion) {
                            error(msg);
                        } else {
                            warn(msg);
                        }
                    }
                    return localShareScopeMap[sc][pkgName][maxOrSingletonVersion];
                } else {
                    if (requiredVersion === false || requiredVersion === '*') {
                        return localShareScopeMap[sc][pkgName][maxOrSingletonVersion];
                    }
                    if (satisfy(maxOrSingletonVersion, requiredVersion)) {
                        return localShareScopeMap[sc][pkgName][maxOrSingletonVersion];
                    }
                    for(var _i = 0, _Object_entries = Object.entries(localShareScopeMap[sc][pkgName]); _i < _Object_entries.length; _i++){
                        var _Object_entries__i = _sliced_to_array._(_Object_entries[_i], 2), versionKey = _Object_entries__i[0], versionValue = _Object_entries__i[1];
                        if (satisfy(versionKey, requiredVersion)) {
                            return versionValue;
                        }
                    }
                }
            };
            var params = {
                shareScopeMap: localShareScopeMap,
                scope: sc,
                pkgName: pkgName,
                version: maxOrSingletonVersion,
                GlobalFederation: Global.__FEDERATION__,
                resolver: defaultResolver
            };
            var resolveShared = resolveShare.emit(params) || params;
            return {
                v: resolveShared.resolver()
            };
        }
    };
    if (!localShareScopeMap) {
        return;
    }
    var shareConfig = shareInfo.shareConfig, _shareInfo_scope = shareInfo.scope, scope = _shareInfo_scope === void 0 ? DEFAULT_SCOPE : _shareInfo_scope, strategy = shareInfo.strategy;
    var scopes = Array.isArray(scope) ? scope : [
        scope
    ];
    for(var _i = 0; _i < scopes.length; _i++){
        var _ret = _loop(_i);
        if (_type_of._(_ret) === "object") return _ret.v;
    }
}
function getGlobalShareScope() {
    return Global.__FEDERATION__.__SHARE__;
}
function getTargetSharedOptions(options) {
    var pkgName = options.pkgName, extraOptions = options.extraOptions, shareInfos = options.shareInfos;
    var defaultResolver = function(sharedOptions) {
        if (!sharedOptions) {
            return undefined;
        }
        var shareVersionMap = {};
        sharedOptions.forEach(function(shared) {
            shareVersionMap[shared.version] = shared;
        });
        var callback = function callback(prev, cur) {
            return !isLoaded(shareVersionMap[prev]) && versionLt(prev, cur);
        };
        var maxVersion = findVersion(shareVersionMap, callback);
        return shareVersionMap[maxVersion];
    };
    var _extraOptions_resolver;
    var resolver = (_extraOptions_resolver = extraOptions == null ? void 0 : extraOptions.resolver) != null ? _extraOptions_resolver : defaultResolver;
    return Object.assign({}, resolver(shareInfos[pkgName]), extraOptions == null ? void 0 : extraOptions.customShareInfo);
}
exports.DEFAULT_REMOTE_TYPE = DEFAULT_REMOTE_TYPE;
exports.DEFAULT_SCOPE = DEFAULT_SCOPE;
exports.Global = Global;
exports.addGlobalSnapshot = addGlobalSnapshot;
exports.addUniqueItem = addUniqueItem;
exports.arrayOptions = arrayOptions;
exports.assert = assert;
exports.error = error;
exports.formatShareConfigs = formatShareConfigs;
exports.getBuilderId = getBuilderId;
exports.getFMId = getFMId;
exports.getGlobalFederationConstructor = getGlobalFederationConstructor;
exports.getGlobalFederationInstance = getGlobalFederationInstance;
exports.getGlobalHostPlugins = getGlobalHostPlugins;
exports.getGlobalShareScope = getGlobalShareScope;
exports.getGlobalSnapshot = getGlobalSnapshot;
exports.getGlobalSnapshotInfoByModuleInfo = getGlobalSnapshotInfoByModuleInfo;
exports.getInfoWithoutType = getInfoWithoutType;
exports.getPreloaded = getPreloaded;
exports.getRegisteredShare = getRegisteredShare;
exports.getRemoteEntryExports = getRemoteEntryExports;
exports.getRemoteEntryInfoFromSnapshot = getRemoteEntryInfoFromSnapshot;
exports.getTargetSharedOptions = getTargetSharedOptions;
exports.getTargetSnapshotInfoByModuleInfo = getTargetSnapshotInfoByModuleInfo;
exports.globalLoading = globalLoading;
exports.isObject = isObject;
exports.isPlainObject = isPlainObject;
exports.isPureRemoteEntry = isPureRemoteEntry;
exports.isRemoteInfoWithEntry = isRemoteInfoWithEntry;
exports.nativeGlobal = nativeGlobal;
exports.registerGlobalPlugins = registerGlobalPlugins;
exports.resetFederationGlobalInfo = resetFederationGlobalInfo;
exports.setGlobalFederationConstructor = setGlobalFederationConstructor;
exports.setGlobalFederationInstance = setGlobalFederationInstance;
exports.setGlobalSnapshotInfoByModuleInfo = setGlobalSnapshotInfoByModuleInfo;
exports.setPreloaded = setPreloaded;
exports.warn = warn;


}),
73620: (function (__unused_webpack_module, exports) {
"use strict";

function _iterable_to_array(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) {
        return Array.from(iter);
    }
}
exports._ = _iterable_to_array;


}),
74593: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

var _array_like_to_array = __webpack_require__(72216);
function _unsupported_iterable_to_array(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _array_like_to_array._(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array._(o, minLen);
}
exports._ = _unsupported_iterable_to_array;


}),
74956: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

var sdk = __webpack_require__(58506);
var FEDERATION_SUPPORTED_TYPES = [
    'script'
];
Object.defineProperty(exports, "ENCODE_NAME_PREFIX", ({
    enumerable: true,
    get: function get() {
        return sdk.ENCODE_NAME_PREFIX;
    }
}));
exports.FEDERATION_SUPPORTED_TYPES = FEDERATION_SUPPORTED_TYPES;


}),
75452: (function (__unused_webpack_module, exports) {
"use strict";

function _extends() {
    _extends = Object.assign || function assign(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source)if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
        }
        return target;
    };
    return _extends.apply(this, arguments);
}
function _object_without_properties_loose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for(i = 0; i < sourceKeys.length; i++){
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        target[key] = source[key];
    }
    return target;
}
exports._extends = _extends;
exports._object_without_properties_loose = _object_without_properties_loose;


}),
8034: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

var _array_without_holes = __webpack_require__(51676);
var _iterable_to_array = __webpack_require__(73620);
var _non_iterable_spread = __webpack_require__(97727);
var _unsupported_iterable_to_array = __webpack_require__(74593);
function _to_consumable_array(arr) {
    return _array_without_holes._(arr) || _iterable_to_array._(arr) || _unsupported_iterable_to_array._(arr) || _non_iterable_spread._();
}
exports._ = _to_consumable_array;


}),
83481: (function (module) {
function webpackEmptyContext(req) {
  var e = new Error("Cannot find module '" + req + "'");
  e.code = 'MODULE_NOT_FOUND';
  throw e;
}
webpackEmptyContext.keys = function() { return []; };
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = 83481;
module.exports = webpackEmptyContext;


}),
85428: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

var _set_prototype_of = __webpack_require__(12347);
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _set_prototype_of._(subClass, superClass);
}
exports._ = _inherits;


}),
93312: (function (module, exports, __webpack_require__) {
//
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _type_of = __webpack_require__(29936);
module.exports = function shallowEqual(objA, objB, compare, compareContext) {
    var ret = compare ? compare.call(compareContext, objA, objB) : void 0;
    if (ret !== void 0) {
        return !!ret;
    }
    if (objA === objB) {
        return true;
    }
    if ((typeof objA === "undefined" ? "undefined" : _type_of._(objA)) !== "object" || !objA || (typeof objB === "undefined" ? "undefined" : _type_of._(objB)) !== "object" || !objB) {
        return false;
    }
    var keysA = Object.keys(objA);
    var keysB = Object.keys(objB);
    if (keysA.length !== keysB.length) {
        return false;
    }
    var bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);
    // Test for A's keys different from B.
    for(var idx = 0; idx < keysA.length; idx++){
        var key = keysA[idx];
        if (!bHasOwnProperty(key)) {
            return false;
        }
        var valueA = objA[key];
        var valueB = objB[key];
        ret = compare ? compare.call(compareContext, valueA, valueB, key) : void 0;
        if (ret === false || ret === void 0 && valueA !== valueB) {
            return false;
        }
    }
    return true;
};


}),
94171: (function (__unused_webpack_module, exports) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
 //# sourceMappingURL=types.js.map


}),
95094: (function (__unused_webpack_module, __unused_webpack___webpack_exports__, __webpack_require__) {
"use strict";
/* ESM import */var _swc_helpers_sliced_to_array__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(21193);
/* ESM import */var _swc_helpers_to_consumable_array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(8034);
/* ESM import */var _swc_helpers_type_of__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(29936);
/* ESM import */var _Users_hmdev02_Desktop_ReactNative_auth_node_modules_module_federation_webpack_bundler_runtime_dist_index_cjs_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(62939);
/* ESM import */var _Users_hmdev02_Desktop_ReactNative_auth_node_modules_module_federation_webpack_bundler_runtime_dist_index_cjs_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_Users_hmdev02_Desktop_ReactNative_auth_node_modules_module_federation_webpack_bundler_runtime_dist_index_cjs_js__WEBPACK_IMPORTED_MODULE_0__);
/* ESM import */var _Users_hmdev02_Desktop_ReactNative_auth_node_modules_callstack_repack_dist_modules_FederationRuntimePlugin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(97186);





var __module_federation_runtime_plugins__ = [
    (0,_Users_hmdev02_Desktop_ReactNative_auth_node_modules_callstack_repack_dist_modules_FederationRuntimePlugin_js__WEBPACK_IMPORTED_MODULE_1__["default"])()
];
var __module_federation_remote_infos__ = {};
var __module_federation_container_name__ = "auth";
var __module_federation_share_strategy__ = "loaded-first";
if ((__webpack_require__.initializeSharingData || __webpack_require__.initializeExposesData) && __webpack_require__.federation) {
    var __webpack_require___remotesLoadingData, __webpack_require___remotesLoadingData1, __webpack_require___initializeSharingData, __webpack_require___consumesLoadingData, __webpack_require___consumesLoadingData1, __webpack_require___initializeExposesData, __webpack_require___consumesLoadingData2;
    var override = function(obj, key, value) {
        if (!obj) return;
        if (obj[key]) obj[key] = value;
    };
    var merge = function(obj, key, fn) {
        var value = fn();
        if (Array.isArray(value)) {
            var _obj_key;
            var _obj, _key;
            var _;
            (_ = (_obj = obj)[_key = key]) !== null && _ !== void 0 ? _ : _obj[_key] = [];
            (_obj_key = obj[key]).push.apply(_obj_key, (0,_swc_helpers_to_consumable_array__WEBPACK_IMPORTED_MODULE_2__._)(value));
        } else if ((typeof value === "undefined" ? "undefined" : (0,_swc_helpers_type_of__WEBPACK_IMPORTED_MODULE_3__._)(value)) === "object" && value !== null) {
            var _obj1, _key1;
            var _1;
            (_1 = (_obj1 = obj)[_key1 = key]) !== null && _1 !== void 0 ? _1 : _obj1[_key1] = {};
            Object.assign(obj[key], value);
        }
    };
    var early = function(obj, key, initial) {
        var _obj, _key;
        var _;
        (_ = (_obj = obj)[_key = key]) !== null && _ !== void 0 ? _ : _obj[_key] = initial();
    };
    var __webpack_require___remotesLoadingData_chunkMapping;
    var remotesLoadingChunkMapping = (__webpack_require___remotesLoadingData_chunkMapping = (__webpack_require___remotesLoadingData = __webpack_require__.remotesLoadingData) === null || __webpack_require___remotesLoadingData === void 0 ? void 0 : __webpack_require___remotesLoadingData.chunkMapping) !== null && __webpack_require___remotesLoadingData_chunkMapping !== void 0 ? __webpack_require___remotesLoadingData_chunkMapping : {};
    var __webpack_require___remotesLoadingData_moduleIdToRemoteDataMapping;
    var remotesLoadingModuleIdToRemoteDataMapping = (__webpack_require___remotesLoadingData_moduleIdToRemoteDataMapping = (__webpack_require___remotesLoadingData1 = __webpack_require__.remotesLoadingData) === null || __webpack_require___remotesLoadingData1 === void 0 ? void 0 : __webpack_require___remotesLoadingData1.moduleIdToRemoteDataMapping) !== null && __webpack_require___remotesLoadingData_moduleIdToRemoteDataMapping !== void 0 ? __webpack_require___remotesLoadingData_moduleIdToRemoteDataMapping : {};
    var __webpack_require___initializeSharingData_scopeToSharingDataMapping;
    var initializeSharingScopeToInitDataMapping = (__webpack_require___initializeSharingData_scopeToSharingDataMapping = (__webpack_require___initializeSharingData = __webpack_require__.initializeSharingData) === null || __webpack_require___initializeSharingData === void 0 ? void 0 : __webpack_require___initializeSharingData.scopeToSharingDataMapping) !== null && __webpack_require___initializeSharingData_scopeToSharingDataMapping !== void 0 ? __webpack_require___initializeSharingData_scopeToSharingDataMapping : {};
    var __webpack_require___consumesLoadingData_chunkMapping;
    var consumesLoadingChunkMapping = (__webpack_require___consumesLoadingData_chunkMapping = (__webpack_require___consumesLoadingData = __webpack_require__.consumesLoadingData) === null || __webpack_require___consumesLoadingData === void 0 ? void 0 : __webpack_require___consumesLoadingData.chunkMapping) !== null && __webpack_require___consumesLoadingData_chunkMapping !== void 0 ? __webpack_require___consumesLoadingData_chunkMapping : {};
    var __webpack_require___consumesLoadingData_moduleIdToConsumeDataMapping;
    var consumesLoadingModuleToConsumeDataMapping = (__webpack_require___consumesLoadingData_moduleIdToConsumeDataMapping = (__webpack_require___consumesLoadingData1 = __webpack_require__.consumesLoadingData) === null || __webpack_require___consumesLoadingData1 === void 0 ? void 0 : __webpack_require___consumesLoadingData1.moduleIdToConsumeDataMapping) !== null && __webpack_require___consumesLoadingData_moduleIdToConsumeDataMapping !== void 0 ? __webpack_require___consumesLoadingData_moduleIdToConsumeDataMapping : {};
    var consumesLoadinginstalledModules = {};
    var initializeSharingInitPromises = [];
    var initializeSharingInitTokens = {};
    var containerShareScope = (__webpack_require___initializeExposesData = __webpack_require__.initializeExposesData) === null || __webpack_require___initializeExposesData === void 0 ? void 0 : __webpack_require___initializeExposesData.shareScope;
    for(var key in (_Users_hmdev02_Desktop_ReactNative_auth_node_modules_module_federation_webpack_bundler_runtime_dist_index_cjs_js__WEBPACK_IMPORTED_MODULE_0___default())){
        __webpack_require__.federation[key] = (_Users_hmdev02_Desktop_ReactNative_auth_node_modules_module_federation_webpack_bundler_runtime_dist_index_cjs_js__WEBPACK_IMPORTED_MODULE_0___default())[key];
    }
    early(__webpack_require__.federation, "consumesLoadingModuleToHandlerMapping", function() {
        var consumesLoadingModuleToHandlerMapping = {};
        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
        try {
            for(var _iterator = Object.entries(consumesLoadingModuleToConsumeDataMapping)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                var _step_value = (0,_swc_helpers_sliced_to_array__WEBPACK_IMPORTED_MODULE_4__._)(_step.value, 2), moduleId = _step_value[0], data = _step_value[1];
                consumesLoadingModuleToHandlerMapping[moduleId] = {
                    getter: data.fallback,
                    shareInfo: {
                        shareConfig: {
                            fixedDependencies: false,
                            requiredVersion: data.requiredVersion,
                            strictVersion: data.strictVersion,
                            singleton: data.singleton,
                            eager: data.eager
                        },
                        scope: [
                            data.shareScope
                        ]
                    },
                    shareKey: data.shareKey
                };
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                    _iterator["return"]();
                }
            } finally{
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
        return consumesLoadingModuleToHandlerMapping;
    });
    early(__webpack_require__.federation, "initOptions", function() {
        return {};
    });
    early(__webpack_require__.federation.initOptions, "name", function() {
        return __module_federation_container_name__;
    });
    early(__webpack_require__.federation.initOptions, "shareStrategy", function() {
        return __module_federation_share_strategy__;
    });
    early(__webpack_require__.federation.initOptions, "shared", function() {
        var shared = {};
        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
        try {
            for(var _iterator = Object.entries(initializeSharingScopeToInitDataMapping)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                var _step_value = (0,_swc_helpers_sliced_to_array__WEBPACK_IMPORTED_MODULE_4__._)(_step.value, 2), scope = _step_value[0], stages = _step_value[1];
                var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
                try {
                    for(var _iterator1 = stages[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){
                        var stage = _step1.value;
                        if ((typeof stage === "undefined" ? "undefined" : (0,_swc_helpers_type_of__WEBPACK_IMPORTED_MODULE_3__._)(stage)) === "object" && stage !== null) {
                            var name = stage.name, version = stage.version, factory = stage.factory, eager = stage.eager, singleton = stage.singleton, requiredVersion = stage.requiredVersion, strictVersion = stage.strictVersion;
                            var shareConfig = {};
                            var isValidValue = function isValidValue(val) {
                                return typeof val !== "undefined";
                            };
                            if (isValidValue(singleton)) {
                                shareConfig.singleton = singleton;
                            }
                            if (isValidValue(requiredVersion)) {
                                shareConfig.requiredVersion = requiredVersion;
                            }
                            if (isValidValue(eager)) {
                                shareConfig.eager = eager;
                            }
                            if (isValidValue(strictVersion)) {
                                shareConfig.strictVersion = strictVersion;
                            }
                            var options = {
                                version: version,
                                scope: [
                                    scope
                                ],
                                shareConfig: shareConfig,
                                get: factory
                            };
                            if (shared[name]) {
                                shared[name].push(options);
                            } else {
                                shared[name] = [
                                    options
                                ];
                            }
                        }
                    }
                } catch (err) {
                    _didIteratorError1 = true;
                    _iteratorError1 = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion1 && _iterator1["return"] != null) {
                            _iterator1["return"]();
                        }
                    } finally{
                        if (_didIteratorError1) {
                            throw _iteratorError1;
                        }
                    }
                }
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                    _iterator["return"]();
                }
            } finally{
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
        return shared;
    });
    merge(__webpack_require__.federation.initOptions, "remotes", function() {
        return Object.values(__module_federation_remote_infos__).flat().filter(function(remote) {
            return remote.externalType === "script";
        });
    });
    merge(__webpack_require__.federation.initOptions, "plugins", function() {
        return __module_federation_runtime_plugins__;
    });
    early(__webpack_require__.federation, "bundlerRuntimeOptions", function() {
        return {};
    });
    early(__webpack_require__.federation.bundlerRuntimeOptions, "remotes", function() {
        return {};
    });
    early(__webpack_require__.federation.bundlerRuntimeOptions.remotes, "chunkMapping", function() {
        return remotesLoadingChunkMapping;
    });
    early(__webpack_require__.federation.bundlerRuntimeOptions.remotes, "idToExternalAndNameMapping", function() {
        var remotesLoadingIdToExternalAndNameMappingMapping = {};
        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
        try {
            for(var _iterator = Object.entries(remotesLoadingModuleIdToRemoteDataMapping)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                var _step_value = (0,_swc_helpers_sliced_to_array__WEBPACK_IMPORTED_MODULE_4__._)(_step.value, 2), moduleId = _step_value[0], data = _step_value[1];
                remotesLoadingIdToExternalAndNameMappingMapping[moduleId] = [
                    data.shareScope,
                    data.name,
                    data.externalModuleId,
                    data.remoteName
                ];
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                    _iterator["return"]();
                }
            } finally{
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
        return remotesLoadingIdToExternalAndNameMappingMapping;
    });
    early(__webpack_require__.federation.bundlerRuntimeOptions.remotes, "webpackRequire", function() {
        return __webpack_require__;
    });
    merge(__webpack_require__.federation.bundlerRuntimeOptions.remotes, "idToRemoteMap", function() {
        var idToRemoteMap = {};
        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
        try {
            for(var _iterator = Object.entries(remotesLoadingModuleIdToRemoteDataMapping)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                var _step_value = (0,_swc_helpers_sliced_to_array__WEBPACK_IMPORTED_MODULE_4__._)(_step.value, 2), id = _step_value[0], remoteData = _step_value[1];
                var info = __module_federation_remote_infos__[remoteData.remoteName];
                if (info) idToRemoteMap[id] = info;
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                    _iterator["return"]();
                }
            } finally{
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
        return idToRemoteMap;
    });
    override(__webpack_require__, "S", __webpack_require__.federation.bundlerRuntime.S);
    if (__webpack_require__.federation.attachShareScopeMap) {
        __webpack_require__.federation.attachShareScopeMap(__webpack_require__);
    }
    override(__webpack_require__.f, "remotes", function(chunkId, promises) {
        return __webpack_require__.federation.bundlerRuntime.remotes({
            chunkId: chunkId,
            promises: promises,
            chunkMapping: remotesLoadingChunkMapping,
            idToExternalAndNameMapping: __webpack_require__.federation.bundlerRuntimeOptions.remotes.idToExternalAndNameMapping,
            idToRemoteMap: __webpack_require__.federation.bundlerRuntimeOptions.remotes.idToRemoteMap,
            webpackRequire: __webpack_require__
        });
    });
    override(__webpack_require__.f, "consumes", function(chunkId, promises) {
        return __webpack_require__.federation.bundlerRuntime.consumes({
            chunkId: chunkId,
            promises: promises,
            chunkMapping: consumesLoadingChunkMapping,
            moduleToHandlerMapping: __webpack_require__.federation.consumesLoadingModuleToHandlerMapping,
            installedModules: consumesLoadinginstalledModules,
            webpackRequire: __webpack_require__
        });
    });
    override(__webpack_require__, "I", function(name, initScope) {
        return __webpack_require__.federation.bundlerRuntime.I({
            shareScopeName: name,
            initScope: initScope,
            initPromises: initializeSharingInitPromises,
            initTokens: initializeSharingInitTokens,
            webpackRequire: __webpack_require__
        });
    });
    override(__webpack_require__, "initContainer", function(shareScope, initScope, remoteEntryInitOptions) {
        return __webpack_require__.federation.bundlerRuntime.initContainerEntry({
            shareScope: shareScope,
            initScope: initScope,
            remoteEntryInitOptions: remoteEntryInitOptions,
            shareScopeKey: containerShareScope,
            webpackRequire: __webpack_require__
        });
    });
    override(__webpack_require__, "getContainer", function(module1, getScope) {
        var moduleMap = __webpack_require__.initializeExposesData.moduleMap;
        __webpack_require__.R = getScope;
        getScope = Object.prototype.hasOwnProperty.call(moduleMap, module1) ? moduleMap[module1]() : Promise.resolve().then(function() {
            throw new Error('Module "' + module1 + '" does not exist in container.');
        });
        __webpack_require__.R = undefined;
        return getScope;
    });
    __webpack_require__.federation.instance = __webpack_require__.federation.runtime.init(__webpack_require__.federation.initOptions);
    if ((__webpack_require___consumesLoadingData2 = __webpack_require__.consumesLoadingData) === null || __webpack_require___consumesLoadingData2 === void 0 ? void 0 : __webpack_require___consumesLoadingData2.initialConsumes) {
        __webpack_require__.federation.bundlerRuntime.installInitialConsumes({
            webpackRequire: __webpack_require__,
            installedModules: consumesLoadinginstalledModules,
            initialConsumes: __webpack_require__.consumesLoadingData.initialConsumes,
            moduleToHandlerMapping: __webpack_require__.federation.consumesLoadingModuleToHandlerMapping
        });
    }
}


}),
97186: (function (__unused_webpack_module, exports, __webpack_require__) {
var __webpack_unused_export__;
__webpack_unused_export__ = ({
    value: true
});
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return _default;
    }
}));
var _async_to_generator = __webpack_require__(37297);
var _ts_generator = __webpack_require__(63563);
var repackFederationRuntimePlugin = function() {
    return {
        name: 'repack-federation-runtime-plugin',
        afterResolve: function(args) {
            var ScriptManager = (__webpack_require__(19510)/* .ScriptManager */.ScriptManager);
            var remoteInfo = args.remoteInfo;
            ScriptManager.shared.addResolver(function(scriptId, caller, referenceUrl) {
                return _async_to_generator._(function() {
                    var publicPath, bundlePath;
                    return _ts_generator._(this, function(_state) {
                        if (scriptId === remoteInfo.entryGlobalName) {
                            return [
                                2,
                                {
                                    url: remoteInfo.entry
                                }
                            ];
                        }
                        if (referenceUrl && caller === remoteInfo.entryGlobalName) {
                            publicPath = remoteInfo.entry.split('/').slice(0, -1).join('/');
                            bundlePath = scriptId + referenceUrl.split(scriptId)[1];
                            return [
                                2,
                                {
                                    url: publicPath + '/' + bundlePath
                                }
                            ];
                        }
                        return [
                            2
                        ];
                    });
                })();
            }, {
                key: remoteInfo.entryGlobalName
            });
            return args;
        },
        loadEntry: function(param) {
            var remoteInfo = param.remoteInfo;
            return _async_to_generator._(function() {
                var client, ScriptManager, getWebpackContext, entry, entryGlobalName, e;
                return _ts_generator._(this, function(_state) {
                    switch(_state.label){
                        case 0:
                            client = __webpack_require__(19510);
                            ScriptManager = client.ScriptManager, getWebpackContext = client.getWebpackContext;
                            entry = remoteInfo.entry, entryGlobalName = remoteInfo.entryGlobalName;
                            _state.label = 1;
                        case 1:
                            _state.trys.push([
                                1,
                                3,
                                ,
                                4
                            ]);
                            return [
                                4,
                                ScriptManager.shared.loadScript(entryGlobalName, undefined, getWebpackContext(), entry)
                            ];
                        case 2:
                            _state.sent();
                            // @ts-ignore
                            if (!globalThis[entryGlobalName]) {
                                throw new Error();
                            }
                            // @ts-ignore
                            return [
                                2,
                                globalThis[entryGlobalName]
                            ];
                        case 3:
                            e = _state.sent();
                            console.error("Failed to load " + entryGlobalName + " entry");
                            return [
                                3,
                                4
                            ];
                        case 4:
                            return [
                                2
                            ];
                    }
                });
            })();
        }
    };
};
var _default = repackFederationRuntimePlugin;


}),
97727: (function (__unused_webpack_module, exports) {
"use strict";

function _non_iterable_spread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
exports._ = _non_iterable_spread;


}),
99741: (function (__unused_webpack_module, exports) {
"use strict";

function _non_iterable_rest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
exports._ = _non_iterable_rest;


}),

});
/************************************************************************/
// The module cache
var __webpack_module_cache__ = {};

// The require function
function __webpack_require__(moduleId) {

// Check if module is in cache
var cachedModule = __webpack_module_cache__[moduleId];
if (cachedModule !== undefined) {
return cachedModule.exports;
}
// Create a new module (and put it into the cache)
var module = (__webpack_module_cache__[moduleId] = {
id: moduleId,
loaded: false,
exports: {}
});
// Execute the module function
__webpack_modules__[moduleId](module, module.exports, __webpack_require__);

// Flag the module as loaded
module.loaded = true;
// Return the exports of the module
return module.exports;

}

// expose the modules object (__webpack_modules__)
__webpack_require__.m = __webpack_modules__;

// expose the module cache
__webpack_require__.c = __webpack_module_cache__;

/************************************************************************/
// module_federation/runtime
!function() {

if(!__webpack_require__.federation){
    __webpack_require__.federation = {
        
chunkMatcher: function(chunkId) {
    return !/^webpack_sharing_consume_default_react(\-native(_(Libraries_(NativeComponent_NativeComponentRegistr\-554570|ReactPrivate_ReactNativePrivateInitial\-b25a9a)|assets\-registry_(path\-support_react\-native_assets\-dcd7c5|registry_react\-native_assets\-reg\-45747a)|normalize\-colors_react\-native_normalize\-colors|src_private_featureflags_ReactNativeFeatureFlags\-8ff4c2|virtualized\-lists_react\-native_virtualized\-lists\-e922cf)|\-paper_react\-native\-paper|\-safe\-area\-context_react\-native\-safe\-area\-context\-9b594a)|_react)$/.test(chunkId);
},
rootOutputDir: "",

    };
}

}();
// webpack/runtime/compat_get_default_export
!function() {
// getDefaultExport function for compatibility with non-ESM modules
__webpack_require__.n = function(module) {
	var getter = module && module.__esModule ?
		function() { return module['default']; } :
		function() { return module; };
	__webpack_require__.d(getter, { a: getter });
	return getter;
};

}();
// webpack/runtime/define_property_getters
!function() {
__webpack_require__.d = function(exports, definition) {
	for(var key in definition) {
        if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
            Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
        }
    }
};
}();
// webpack/runtime/ensure_chunk
!function() {
__webpack_require__.f = {};
// This file contains only the entry chunk.
// The chunk loading function for additional chunks
__webpack_require__.e = function(chunkId) {
	return Promise.all(
		Object.keys(__webpack_require__.f).reduce(function(promises, key) {
			__webpack_require__.f[key](chunkId, promises);
			return promises;
		}, [])
	);
};
}();
// webpack/runtime/get javascript chunk filename
!function() {
// This function allow to reference chunks
__webpack_require__.u = function(chunkId) {
  // return url for filenames not based on template
  
  // return url for filenames based on template
  return "" + chunkId + ".chunk.bundle"
}
}();
// webpack/runtime/global
!function() {
__webpack_require__.g = (function() {
	if (typeof globalThis === 'object') return globalThis;
	try {
		return this || new Function('return this')();
	} catch (e) {
		if (typeof window === 'object') return window;
	}
})();
}();
// webpack/runtime/has_own_property
!function() {
__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
}();
// webpack/runtime/load_script
!function() {
  __webpack_require__.l = function loadScript(url, done, key, chunkId) {
    if (key && chunkId) {
      __webpack_require__.repack.loadScript(chunkId, 'auth', done, url);
    } else if (key) {
      __webpack_require__.repack.loadScript(key, undefined, done, url);
    } else {
      __webpack_require__.repack.loadHotUpdate(url, done);
    }
  };
// Repack runtime initialization logic
  var repackRuntime = {
    loadScript,
    loadHotUpdate,
    shared: self.__repack__ && self.__repack__.shared || __webpack_require__.repack && __webpack_require__.repack.shared || {
      scriptManager: undefined
    }
  };
  __webpack_require__.repack = self.__repack__ = repackRuntime;
  function loadScript(name, caller, done, referenceUrl) {
    if (repackRuntime.shared.scriptManager) {
      repackRuntime.shared.scriptManager.loadScript(name, caller, __webpack_require__, referenceUrl).then(function () {
        done();
        return;
      }).catch(function (reason) {
        console.error('[RepackRuntime] Loading script failed:', reason);
        done({
          type: 'exec',
          target: {
            src: name
          }
        });
      });
    } else {
      console.error('[RepackRuntime] Script manager was not provided');
      done({
        type: 'exec',
        target: {
          src: name
        }
      });
    }
  }
  function loadHotUpdate(url, done) {
    if (!false) {
      console.error('[RepackRuntime] Loading HMR update chunks is disabled');
      done({
        type: 'disabled',
        target: {
          src: url
        }
      });
      return;
    }
    fetch(url).then(function (response) {
      if (!response.ok) {
        console.error('[RepackRuntime] Loading HMR update failed:', response.statusText);
        done({
          type: response.statusText,
          target: {
            src: url
          }
        });
        return;
      }
      return response.text();
    }).then(function (script) {
      if (script) {
        if (repackRuntime.shared.scriptManager) {
          repackRuntime.shared.scriptManager.unstable_evaluateScript(script, url);
        } else {
          eval(script);
        }
      }
      return;
    }).catch(function (reason) {
      console.error('[RepackRuntime] Loading HMR update chunk failed:', reason);
      done({
        type: 'exec',
        target: {
          src: url
        }
      });
    });
  }
}();
// webpack/runtime/make_namespace_object
!function() {
// define __esModule on exports
__webpack_require__.r = function(exports) {
	if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
		Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
	}
	Object.defineProperty(exports, '__esModule', { value: true });
};
}();
// webpack/runtime/node_module_decorator
!function() {
__webpack_require__.nmd = function(module) {
  module.paths = [];
  if (!module.children) module.children = [];
  return module;
};
}();
// webpack/runtime/public_path
!function() {
__webpack_require__.p = "https://thanhthai198.github.io/my_cdn/android/auth/";
}();
// webpack/runtime/rspack_version
!function() {
__webpack_require__.rv = function() { return "1.3.13"; }
}();
// webpack/runtime/sharing
!function() {

__webpack_require__.S = {};
__webpack_require__.initializeSharingData = { scopeToSharingDataMapping: { "default": [{ name: "@react-native-async-storage/async-storage", version: "2.0.0", factory: function() { return __webpack_require__.e("vendors-node_modules_react-native-async-storage_async-storage_src_index_ts").then(function() { return function() { return __webpack_require__(27470); }; }); }, eager: 0, singleton: 1, requiredVersion: "1.17.11" }, { name: "@react-native/assets-registry/path-support", version: "0.76.1", factory: function() { return __webpack_require__.e("node_modules_react-native_assets-registry_path-support_js").then(function() { return function() { return __webpack_require__(73836); }; }); }, eager: 0, singleton: 1, requiredVersion: "*" }, { name: "@react-native/assets-registry/registry", version: "0.76.1", factory: function() { return __webpack_require__.e("node_modules_react-native_assets-registry_registry_js").then(function() { return function() { return __webpack_require__(25082); }; }); }, eager: 0, singleton: 1, requiredVersion: "*" }, { name: "@react-native/normalize-colors", version: "0.76.1", factory: function() { return __webpack_require__.e("node_modules_react-native_normalize-colors_index_js").then(function() { return function() { return __webpack_require__(98878); }; }); }, eager: 0, singleton: 1, requiredVersion: "*" }, { name: "@react-native/virtualized-lists", version: "0.76.1", factory: function() { return Promise.all([__webpack_require__.e("vendors-node_modules_react-native_virtualized-lists_index_js"), __webpack_require__.e("webpack_sharing_consume_default_react_react"), __webpack_require__.e("webpack_sharing_consume_default_react-native_src_private_featureflags_ReactNativeFeatureFlags-8ff4c2"), __webpack_require__.e("node_modules_swc_helpers_cjs__extends_cjs-node_modules_swc_helpers_cjs__object_without_proper-71cbf6")]).then(function() { return function() { return __webpack_require__(47609); }; }); }, eager: 0, singleton: 1, requiredVersion: "*" }, { name: "react-native-paper", version: "5.12.5", factory: function() { return Promise.all([__webpack_require__.e("vendors-node_modules_react-native-paper_src_index_tsx"), __webpack_require__.e("webpack_sharing_consume_default_react_react"), __webpack_require__.e("webpack_sharing_consume_default_react-native-safe-area-context_react-native-safe-area-context-9b594a")]).then(function() { return function() { return __webpack_require__(70325); }; }); }, eager: 0, singleton: 1, requiredVersion: "5.0.0-rc.10" }, { name: "react-native-safe-area-context", version: "4.12.0", factory: function() { return Promise.all([__webpack_require__.e("webpack_sharing_consume_default_react_react"), __webpack_require__.e("webpack_sharing_consume_default_react-native_Libraries_NativeComponent_NativeComponentRegistr-554570"), __webpack_require__.e("node_modules_react-native-safe-area-context_src_index_tsx-_dbff1")]).then(function() { return function() { return __webpack_require__(21866); }; }); }, eager: 0, singleton: 1, requiredVersion: "4.4.1" }, { name: "react-native/Libraries/Image/AssetRegistry", version: "0.76.1", factory: function() { return Promise.all([__webpack_require__.e("webpack_sharing_consume_default_react-native_assets-registry_registry_react-native_assets-reg-45747a"), __webpack_require__.e("node_modules_react-native_Libraries_Image_AssetRegistry_js")]).then(function() { return function() { return __webpack_require__(34626); }; }); }, eager: 0, singleton: 1, requiredVersion: "*" }, { name: "react-native/Libraries/NativeComponent/NativeComponentRegistry", version: "0.76.1", factory: function() { return Promise.all([__webpack_require__.e("vendors-node_modules_react-native_Libraries_TurboModule_TurboModuleRegistry_js"), __webpack_require__.e("vendors-node_modules_react-native_Libraries_NativeComponent_NativeComponentRegistry_js"), __webpack_require__.e("webpack_sharing_consume_default_react_react"), __webpack_require__.e("webpack_sharing_consume_default_react-native_normalize-colors_react-native_normalize-colors"), __webpack_require__.e("webpack_sharing_consume_default_react-native_assets-registry_registry_react-native_assets-reg-45747a"), __webpack_require__.e("webpack_sharing_consume_default_react-native_assets-registry_path-support_react-native_assets-dcd7c5"), __webpack_require__.e("node_modules_swc_helpers_cjs__extends_cjs-node_modules_invariant_browser_js-node_modules_reac-c1e649")]).then(function() { return function() { return __webpack_require__(68493); }; }); }, eager: 0, singleton: 1, requiredVersion: "*" }, { name: "react-native/Libraries/NativeComponent/ViewConfigIgnore", version: "0.76.1", factory: function() { return Promise.all([__webpack_require__.e("vendors-node_modules_react-native_Libraries_TurboModule_TurboModuleRegistry_js"), __webpack_require__.e("node_modules_invariant_browser_js-node_modules_react-native_Libraries_NativeComponent_ViewCon-ee6472")]).then(function() { return function() { return __webpack_require__(89529); }; }); }, eager: 0, singleton: 1, requiredVersion: "*" }, { name: "react-native/Libraries/ReactNative/RendererProxy", version: "0.76.1", factory: function() { return Promise.all([__webpack_require__.e("vendors-node_modules_react-native_Libraries_TurboModule_TurboModuleRegistry_js"), __webpack_require__.e("vendors-node_modules_invariant_browser_js-node_modules_react-native_Libraries_ReactNative_Ren-8cb159"), __webpack_require__.e("webpack_sharing_consume_default_react_react"), __webpack_require__.e("webpack_sharing_consume_default_react-native_Libraries_ReactPrivate_ReactNativePrivateInitial-b25a9a")]).then(function() { return function() { return __webpack_require__(14288); }; }); }, eager: 0, singleton: 1, requiredVersion: "*" }, { name: "react-native/Libraries/ReactPrivate/ReactNativePrivateInitializeCore", version: "0.76.1", factory: function() { return Promise.all([__webpack_require__.e("vendors-node_modules_react-native_Libraries_TurboModule_TurboModuleRegistry_js"), __webpack_require__.e("vendors-node_modules_react-native_Libraries_NativeComponent_NativeComponentRegistry_js"), __webpack_require__.e("vendors-node_modules_react-native_Libraries_StyleSheet_flattenStyle_js-node_modules_react-nat-41ecd5"), __webpack_require__.e("vendors-node_modules_invariant_browser_js-node_modules_react-native_Libraries_ReactNative_Ren-8cb159"), __webpack_require__.e("vendors-node_modules_react-native_Libraries_Alert_Alert_js-node_modules_react-native_Librarie-9c2a1e"), __webpack_require__.e("vendors-node_modules_react-native_Libraries_ReactPrivate_ReactNativePrivateInitializeCore_js"), __webpack_require__.e("webpack_sharing_consume_default_react_react"), __webpack_require__.e("webpack_sharing_consume_default_react-native_normalize-colors_react-native_normalize-colors"), __webpack_require__.e("webpack_sharing_consume_default_react-native_assets-registry_registry_react-native_assets-reg-45747a"), __webpack_require__.e("webpack_sharing_consume_default_react-native_assets-registry_path-support_react-native_assets-dcd7c5"), __webpack_require__.e("webpack_sharing_consume_default_react-native_Libraries_ReactPrivate_ReactNativePrivateInitial-b25a9a")]).then(function() { return function() { return __webpack_require__(87720); }; }); }, eager: 0, singleton: 1, requiredVersion: "*" }, { name: "react-native/Libraries/ReactPrivate/ReactNativePrivateInterface", version: "0.76.1", factory: function() { return Promise.all([__webpack_require__.e("vendors-node_modules_react-native_Libraries_TurboModule_TurboModuleRegistry_js"), __webpack_require__.e("vendors-node_modules_react-native_Libraries_NativeComponent_NativeComponentRegistry_js"), __webpack_require__.e("vendors-node_modules_react-native_Libraries_StyleSheet_flattenStyle_js-node_modules_react-nat-41ecd5"), __webpack_require__.e("vendors-node_modules_invariant_browser_js-node_modules_react-native_Libraries_ReactNative_Ren-8cb159"), __webpack_require__.e("vendors-node_modules_react-native_Libraries_Components_AccessibilityInfo_legacySendAccessibil-155e24"), __webpack_require__.e("vendors-node_modules_react-native_Libraries_ReactPrivate_ReactNativePrivateInterface_js"), __webpack_require__.e("webpack_sharing_consume_default_react_react"), __webpack_require__.e("webpack_sharing_consume_default_react-native_normalize-colors_react-native_normalize-colors"), __webpack_require__.e("webpack_sharing_consume_default_react-native_assets-registry_registry_react-native_assets-reg-45747a"), __webpack_require__.e("webpack_sharing_consume_default_react-native_assets-registry_path-support_react-native_assets-dcd7c5"), __webpack_require__.e("webpack_sharing_consume_default_react-native_Libraries_ReactPrivate_ReactNativePrivateInitial-b25a9a")]).then(function() { return function() { return __webpack_require__(43859); }; }); }, eager: 0, singleton: 1, requiredVersion: "*" }, { name: "react-native/Libraries/StyleSheet/processColor", version: "0.76.1", factory: function() { return Promise.all([__webpack_require__.e("vendors-node_modules_react-native_Libraries_TurboModule_TurboModuleRegistry_js"), __webpack_require__.e("webpack_sharing_consume_default_react-native_normalize-colors_react-native_normalize-colors"), __webpack_require__.e("node_modules_invariant_browser_js-node_modules_react-native_Libraries_StyleSheet_processColor_js")]).then(function() { return function() { return __webpack_require__(83900); }; }); }, eager: 0, singleton: 1, requiredVersion: "*" }, { name: "react-native/Libraries/StyleSheet/processColorArray", version: "0.76.1", factory: function() { return Promise.all([__webpack_require__.e("vendors-node_modules_react-native_Libraries_TurboModule_TurboModuleRegistry_js"), __webpack_require__.e("webpack_sharing_consume_default_react-native_normalize-colors_react-native_normalize-colors"), __webpack_require__.e("node_modules_invariant_browser_js-node_modules_react-native_Libraries_StyleSheet_processColor-5fa1bb")]).then(function() { return function() { return __webpack_require__(43080); }; }); }, eager: 0, singleton: 1, requiredVersion: "*" }, { name: "react-native/src/private/featureflags/ReactNativeFeatureFlags", version: "0.76.1", factory: function() { return Promise.all([__webpack_require__.e("vendors-node_modules_react-native_Libraries_TurboModule_TurboModuleRegistry_js"), __webpack_require__.e("node_modules_invariant_browser_js-node_modules_react-native_src_private_featureflags_ReactNat-438b0b")]).then(function() { return function() { return __webpack_require__(26044); }; }); }, eager: 0, singleton: 1, requiredVersion: "*" }, { name: "react-native", version: "0.76.1", factory: function() { return Promise.all([__webpack_require__.e("vendors-node_modules_react-native_Libraries_TurboModule_TurboModuleRegistry_js"), __webpack_require__.e("vendors-node_modules_react-native_Libraries_NativeComponent_NativeComponentRegistry_js"), __webpack_require__.e("vendors-node_modules_react-native_Libraries_StyleSheet_flattenStyle_js-node_modules_react-nat-41ecd5"), __webpack_require__.e("vendors-node_modules_invariant_browser_js-node_modules_react-native_Libraries_ReactNative_Ren-8cb159"), __webpack_require__.e("vendors-node_modules_react-native_Libraries_Alert_Alert_js-node_modules_react-native_Librarie-9c2a1e"), __webpack_require__.e("vendors-node_modules_react-native_Libraries_Components_AccessibilityInfo_legacySendAccessibil-155e24"), __webpack_require__.e("vendors-node_modules_react-native_index_js"), __webpack_require__.e("webpack_sharing_consume_default_react_react"), __webpack_require__.e("webpack_sharing_consume_default_react-native_normalize-colors_react-native_normalize-colors"), __webpack_require__.e("webpack_sharing_consume_default_react-native_assets-registry_registry_react-native_assets-reg-45747a"), __webpack_require__.e("webpack_sharing_consume_default_react-native_assets-registry_path-support_react-native_assets-dcd7c5"), __webpack_require__.e("webpack_sharing_consume_default_react-native_Libraries_ReactPrivate_ReactNativePrivateInitial-b25a9a"), __webpack_require__.e("webpack_sharing_consume_default_react-native_Libraries_NativeComponent_NativeComponentRegistr-554570"), __webpack_require__.e("webpack_sharing_consume_default_react-native_virtualized-lists_react-native_virtualized-lists-e922cf")]).then(function() { return function() { return __webpack_require__(58520); }; }); }, eager: 0, singleton: 1, requiredVersion: "0.71.8" }, { name: "react", version: "18.3.1", factory: function() { return __webpack_require__.e("node_modules_react_index_js").then(function() { return function() { return __webpack_require__(67294); }; }); }, eager: 0, singleton: 1, requiredVersion: "18.2.0" }] }, uniqueName: "sas-auth" };
__webpack_require__.I = __webpack_require__.I || function() { throw new Error("should have __webpack_require__.I") }

}();
// webpack/runtime/consumes_loading
!function() {

__webpack_require__.consumesLoadingData = { chunkMapping: {"webpack_sharing_consume_default_react-native-paper_react-native-paper":["62366"],"webpack_sharing_consume_default_react-native-safe-area-context_react-native-safe-area-context-9b594a":["2704","84408"],"__federation_expose_AuthProvider":["36707"],"webpack_sharing_consume_default_react-native_src_private_featureflags_ReactNativeFeatureFlags-8ff4c2":["59241"],"webpack_sharing_consume_default_react_react":["41845"],"auth":["64598"],"webpack_sharing_consume_default_react-native_normalize-colors_react-native_normalize-colors":["13520"],"webpack_sharing_consume_default_react-native_assets-registry_registry_react-native_assets-reg-45747a":["2392"],"webpack_sharing_consume_default_react-native_assets-registry_path-support_react-native_assets-dcd7c5":["23347"],"webpack_sharing_consume_default_react-native_Libraries_ReactPrivate_ReactNativePrivateInitial-b25a9a":["19982","81558"],"webpack_sharing_consume_default_react-native_Libraries_NativeComponent_NativeComponentRegistr-554570":["83089","72499"],"webpack_sharing_consume_default_react-native_virtualized-lists_react-native_virtualized-lists-e922cf":["83712","28936","36551","22841"]}, moduleIdToConsumeDataMapping: { "64598": { shareScope: "default", shareKey: "react-native", import: "react-native", requiredVersion: "0.71.8", strictVersion: false, singleton: true, eager: false, fallback: function() { return Promise.all([__webpack_require__.e("vendors-node_modules_react-native_Libraries_TurboModule_TurboModuleRegistry_js"), __webpack_require__.e("vendors-node_modules_react-native_Libraries_NativeComponent_NativeComponentRegistry_js"), __webpack_require__.e("vendors-node_modules_react-native_Libraries_StyleSheet_flattenStyle_js-node_modules_react-nat-41ecd5"), __webpack_require__.e("vendors-node_modules_invariant_browser_js-node_modules_react-native_Libraries_ReactNative_Ren-8cb159"), __webpack_require__.e("vendors-node_modules_react-native_Libraries_Alert_Alert_js-node_modules_react-native_Librarie-9c2a1e"), __webpack_require__.e("vendors-node_modules_react-native_Libraries_Components_AccessibilityInfo_legacySendAccessibil-155e24"), __webpack_require__.e("vendors-node_modules_react-native_index_js"), __webpack_require__.e("webpack_sharing_consume_default_react_react"), __webpack_require__.e("webpack_sharing_consume_default_react-native_normalize-colors_react-native_normalize-colors"), __webpack_require__.e("webpack_sharing_consume_default_react-native_assets-registry_registry_react-native_assets-reg-45747a"), __webpack_require__.e("webpack_sharing_consume_default_react-native_assets-registry_path-support_react-native_assets-dcd7c5"), __webpack_require__.e("webpack_sharing_consume_default_react-native_Libraries_ReactPrivate_ReactNativePrivateInitial-b25a9a"), __webpack_require__.e("webpack_sharing_consume_default_react-native_Libraries_NativeComponent_NativeComponentRegistr-554570"), __webpack_require__.e("webpack_sharing_consume_default_react-native_virtualized-lists_react-native_virtualized-lists-e922cf")]).then(function() { return function() { return __webpack_require__(58520); }; }); } }, "83089": { shareScope: "default", shareKey: "react-native/Libraries/NativeComponent/ViewConfigIgnore", import: "react-native/Libraries/NativeComponent/ViewConfigIgnore", requiredVersion: "*", strictVersion: false, singleton: true, eager: false, fallback: function() { return Promise.all([__webpack_require__.e("vendors-node_modules_react-native_Libraries_TurboModule_TurboModuleRegistry_js"), __webpack_require__.e("node_modules_invariant_browser_js-node_modules_react-native_Libraries_NativeComponent_ViewCon-ee6472")]).then(function() { return function() { return __webpack_require__(89529); }; }); } }, "36551": { shareScope: "default", shareKey: "react-native/Libraries/StyleSheet/processColorArray", import: "react-native/Libraries/StyleSheet/processColorArray", requiredVersion: "*", strictVersion: false, singleton: true, eager: false, fallback: function() { return function() { return __webpack_require__(43080); }; } }, "22841": { shareScope: "default", shareKey: "react-native/Libraries/ReactNative/RendererProxy", import: "react-native/Libraries/ReactNative/RendererProxy", requiredVersion: "*", strictVersion: false, singleton: true, eager: false, fallback: function() { return function() { return __webpack_require__(14288); }; } }, "41845": { shareScope: "default", shareKey: "react", import: "react", requiredVersion: "18.2.0", strictVersion: false, singleton: true, eager: false, fallback: function() { return __webpack_require__.e("node_modules_react_index_js").then(function() { return function() { return __webpack_require__(67294); }; }); } }, "23347": { shareScope: "default", shareKey: "@react-native/assets-registry/path-support", import: "@react-native/assets-registry/path-support", requiredVersion: "*", strictVersion: false, singleton: true, eager: false, fallback: function() { return __webpack_require__.e("node_modules_react-native_assets-registry_path-support_js").then(function() { return function() { return __webpack_require__(73836); }; }); } }, "83712": { shareScope: "default", shareKey: "@react-native/virtualized-lists", import: "@react-native/virtualized-lists", requiredVersion: "*", strictVersion: false, singleton: true, eager: false, fallback: function() { return Promise.all([__webpack_require__.e("vendors-node_modules_react-native_virtualized-lists_index_js"), __webpack_require__.e("webpack_sharing_consume_default_react-native_src_private_featureflags_ReactNativeFeatureFlags-8ff4c2")]).then(function() { return function() { return __webpack_require__(47609); }; }); } }, "72499": { shareScope: "default", shareKey: "react-native/Libraries/NativeComponent/NativeComponentRegistry", import: "react-native/Libraries/NativeComponent/NativeComponentRegistry", requiredVersion: "*", strictVersion: false, singleton: true, eager: false, fallback: function() { return Promise.all([__webpack_require__.e("vendors-node_modules_react-native_Libraries_TurboModule_TurboModuleRegistry_js"), __webpack_require__.e("vendors-node_modules_react-native_Libraries_NativeComponent_NativeComponentRegistry_js"), __webpack_require__.e("webpack_sharing_consume_default_react-native_normalize-colors_react-native_normalize-colors"), __webpack_require__.e("webpack_sharing_consume_default_react-native_assets-registry_registry_react-native_assets-reg-45747a"), __webpack_require__.e("webpack_sharing_consume_default_react-native_assets-registry_path-support_react-native_assets-dcd7c5"), __webpack_require__.e("node_modules_invariant_browser_js-node_modules_react-native_Libraries_Utilities_Platform_android_js")]).then(function() { return function() { return __webpack_require__(68493); }; }); } }, "62366": { shareScope: "default", shareKey: "react-native-paper", import: "react-native-paper", requiredVersion: "5.0.0-rc.10", strictVersion: false, singleton: true, eager: false, fallback: function() { return Promise.all([__webpack_require__.e("vendors-node_modules_react-native-paper_src_index_tsx"), __webpack_require__.e("webpack_sharing_consume_default_react-native-safe-area-context_react-native-safe-area-context-9b594a")]).then(function() { return function() { return __webpack_require__(70325); }; }); } }, "36707": { shareScope: "default", shareKey: "@react-native-async-storage/async-storage", import: "@react-native-async-storage/async-storage", requiredVersion: "1.17.11", strictVersion: false, singleton: true, eager: false, fallback: function() { return __webpack_require__.e("vendors-node_modules_react-native-async-storage_async-storage_src_index_ts").then(function() { return function() { return __webpack_require__(27470); }; }); } }, "13520": { shareScope: "default", shareKey: "@react-native/normalize-colors", import: "@react-native/normalize-colors", requiredVersion: "*", strictVersion: false, singleton: true, eager: false, fallback: function() { return __webpack_require__.e("node_modules_react-native_normalize-colors_index_js").then(function() { return function() { return __webpack_require__(98878); }; }); } }, "84408": { shareScope: "default", shareKey: "react-native/Libraries/Image/AssetRegistry", import: "react-native/Libraries/Image/AssetRegistry", requiredVersion: "*", strictVersion: false, singleton: true, eager: false, fallback: function() { return Promise.all([__webpack_require__.e("webpack_sharing_consume_default_react-native_assets-registry_registry_react-native_assets-reg-45747a"), __webpack_require__.e("node_modules_react-native_Libraries_Image_AssetRegistry_js")]).then(function() { return function() { return __webpack_require__(34626); }; }); } }, "28936": { shareScope: "default", shareKey: "react-native/Libraries/StyleSheet/processColor", import: "react-native/Libraries/StyleSheet/processColor", requiredVersion: "*", strictVersion: false, singleton: true, eager: false, fallback: function() { return function() { return __webpack_require__(83900); }; } }, "59241": { shareScope: "default", shareKey: "react-native/src/private/featureflags/ReactNativeFeatureFlags", import: "react-native/src/private/featureflags/ReactNativeFeatureFlags", requiredVersion: "*", strictVersion: false, singleton: true, eager: false, fallback: function() { return Promise.all([__webpack_require__.e("vendors-node_modules_react-native_Libraries_TurboModule_TurboModuleRegistry_js"), __webpack_require__.e("node_modules_react-native_src_private_featureflags_ReactNativeFeatureFlags_js")]).then(function() { return function() { return __webpack_require__(26044); }; }); } }, "2392": { shareScope: "default", shareKey: "@react-native/assets-registry/registry", import: "@react-native/assets-registry/registry", requiredVersion: "*", strictVersion: false, singleton: true, eager: false, fallback: function() { return __webpack_require__.e("node_modules_react-native_assets-registry_registry_js").then(function() { return function() { return __webpack_require__(25082); }; }); } }, "2704": { shareScope: "default", shareKey: "react-native-safe-area-context", import: "react-native-safe-area-context", requiredVersion: "4.4.1", strictVersion: false, singleton: true, eager: false, fallback: function() { return Promise.all([__webpack_require__.e("webpack_sharing_consume_default_react-native_Libraries_NativeComponent_NativeComponentRegistr-554570"), __webpack_require__.e("node_modules_react-native-safe-area-context_src_index_tsx-_dbff0")]).then(function() { return function() { return __webpack_require__(21866); }; }); } }, "19982": { shareScope: "default", shareKey: "react-native/Libraries/ReactPrivate/ReactNativePrivateInterface", import: "react-native/Libraries/ReactPrivate/ReactNativePrivateInterface", requiredVersion: "*", strictVersion: false, singleton: true, eager: false, fallback: function() { return Promise.all([__webpack_require__.e("vendors-node_modules_react-native_Libraries_NativeComponent_NativeComponentRegistry_js"), __webpack_require__.e("vendors-node_modules_react-native_Libraries_StyleSheet_flattenStyle_js-node_modules_react-nat-41ecd5"), __webpack_require__.e("vendors-node_modules_react-native_Libraries_Components_AccessibilityInfo_legacySendAccessibil-155e24"), __webpack_require__.e("vendors-node_modules_react-native_Libraries_ReactPrivate_ReactNativePrivateInterface_js"), __webpack_require__.e("webpack_sharing_consume_default_react-native_normalize-colors_react-native_normalize-colors"), __webpack_require__.e("webpack_sharing_consume_default_react-native_assets-registry_registry_react-native_assets-reg-45747a"), __webpack_require__.e("webpack_sharing_consume_default_react-native_assets-registry_path-support_react-native_assets-dcd7c5")]).then(function() { return function() { return __webpack_require__(43859); }; }); } }, "81558": { shareScope: "default", shareKey: "react-native/Libraries/ReactPrivate/ReactNativePrivateInitializeCore", import: "react-native/Libraries/ReactPrivate/ReactNativePrivateInitializeCore", requiredVersion: "*", strictVersion: false, singleton: true, eager: false, fallback: function() { return Promise.all([__webpack_require__.e("vendors-node_modules_react-native_Libraries_NativeComponent_NativeComponentRegistry_js"), __webpack_require__.e("vendors-node_modules_react-native_Libraries_StyleSheet_flattenStyle_js-node_modules_react-nat-41ecd5"), __webpack_require__.e("vendors-node_modules_react-native_Libraries_Alert_Alert_js-node_modules_react-native_Librarie-9c2a1e"), __webpack_require__.e("vendors-node_modules_react-native_Libraries_ReactPrivate_ReactNativePrivateInitializeCore_js"), __webpack_require__.e("webpack_sharing_consume_default_react-native_normalize-colors_react-native_normalize-colors"), __webpack_require__.e("webpack_sharing_consume_default_react-native_assets-registry_registry_react-native_assets-reg-45747a"), __webpack_require__.e("webpack_sharing_consume_default_react-native_assets-registry_path-support_react-native_assets-dcd7c5")]).then(function() { return function() { return __webpack_require__(87720); }; }); } } }, initialConsumes: ["64598"] };
__webpack_require__.f.consumes = __webpack_require__.f.consumes || function() { throw new Error("should have __webpack_require__.f.consumes") }
}();
// webpack/runtime/initialize_exposes
!function() {

__webpack_require__.initializeExposesData = {
  moduleMap: {
  "./AccountScreen": function() {
return Promise.all(/*  | __federation_expose_AccountScreen */ [__webpack_require__.e("webpack_sharing_consume_default_react_react"), __webpack_require__.e("webpack_sharing_consume_default_react-native-paper_react-native-paper"), __webpack_require__.e("__federation_expose_AccountScreen")]).then(function() { return function() { return __webpack_require__(71333); }; });
},
"./SignInScreen": function() {
return Promise.all(/*  | __federation_expose_SignInScreen */ [__webpack_require__.e("webpack_sharing_consume_default_react_react"), __webpack_require__.e("webpack_sharing_consume_default_react-native-paper_react-native-paper"), __webpack_require__.e("__federation_expose_SignInScreen")]).then(function() { return function() { return __webpack_require__(84985); }; });
},
"./AuthProvider": function() {
return Promise.all(/*  | __federation_expose_AuthProvider */ [__webpack_require__.e("webpack_sharing_consume_default_react_react"), __webpack_require__.e("__federation_expose_AuthProvider")]).then(function() { return function() { return __webpack_require__(99637); }; });
},
},
  shareScope: "default",
};
__webpack_require__.getContainer = __webpack_require__.getContainer || function() { throw new Error("should have __webpack_require__.getContainer") };__webpack_require__.initContainer = __webpack_require__.initContainer || function() { throw new Error("should have __webpack_require__.initContainer") };
}();
// webpack/runtime/jsonp_chunk_loading
!function() {

      // object to store loaded and loading chunks
      // undefined = chunk not loaded, null = chunk preloaded/prefetched
      // [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
      var installedChunks = {"auth": 0,};
      
        __webpack_require__.f.j = function (chunkId, promises) {
          // JSONP chunk loading for javascript
var installedChunkData = __webpack_require__.o(installedChunks, chunkId)
	? installedChunks[chunkId]
	: undefined;
if (installedChunkData !== 0) {
	// 0 means "already installed".

	// a Promise means "currently loading".
	if (installedChunkData) {
		promises.push(installedChunkData[2]);
	} else {
		if (!/^webpack_sharing_consume_default_react(\-native(_(Libraries_(NativeComponent_NativeComponentRegistr\-554570|ReactPrivate_ReactNativePrivateInitial\-b25a9a)|assets\-registry_(path\-support_react\-native_assets\-dcd7c5|registry_react\-native_assets\-reg\-45747a)|normalize\-colors_react\-native_normalize\-colors|src_private_featureflags_ReactNativeFeatureFlags\-8ff4c2|virtualized\-lists_react\-native_virtualized\-lists\-e922cf)|\-paper_react\-native\-paper|\-safe\-area\-context_react\-native\-safe\-area\-context\-9b594a)|_react)$/.test(chunkId)) {
			// setup Promise in chunk cache
			var promise = new Promise(function(resolve, reject) { installedChunkData = installedChunks[chunkId] = [resolve, reject]; });
			promises.push((installedChunkData[2] = promise));

			// start chunk loading
			var url = __webpack_require__.p + __webpack_require__.u(chunkId);
			// create error before stack unwound to get useful stacktrace later
			var error = new Error();
			var loadingEnded = function (event) {
				if (__webpack_require__.o(installedChunks, chunkId)) {
					installedChunkData = installedChunks[chunkId];
					if (installedChunkData !== 0) installedChunks[chunkId] = undefined;
					if (installedChunkData) {
						var errorType =
							event && (event.type === 'load' ? 'missing' : event.type);
						var realSrc = event && event.target && event.target.src;
						error.message =
							'Loading chunk ' +
							chunkId +
							' failed.\n(' +
							errorType +
							': ' +
							realSrc +
							')';
						error.name = 'ChunkLoadError';
						error.type = errorType;
						error.request = realSrc;
						installedChunkData[1](error);
					}
				}
			};
			__webpack_require__.l(url, loadingEnded, "chunk-" + chunkId, chunkId);
		} else installedChunks[chunkId] = 0;

	}
}

        }
        // install a JSONP callback for chunk loading
var webpackJsonpCallback = function(parentChunkLoadingFunction, data) {
	var chunkIds = data[0];
var moreModules = data[1];
var runtime = data[2];
	// add "moreModules" to the modules object,
	// then flag all "chunkIds" as loaded and fire callback
	var moduleId, chunkId, i = 0;
	if (chunkIds.some(function(id) { return installedChunks[id] !== 0; })) {
		for (moduleId in moreModules) {
			if (__webpack_require__.o(moreModules, moduleId)) {
				__webpack_require__.m[moduleId] = moreModules[moduleId];
			}
		}
		if (runtime) var result = runtime(__webpack_require__);
	}
	if (parentChunkLoadingFunction) parentChunkLoadingFunction(data);
	for (; i < chunkIds.length; i++) {
		chunkId = chunkIds[i];
		if (
			__webpack_require__.o(installedChunks, chunkId) &&
			installedChunks[chunkId]
		) {
			installedChunks[chunkId][0]();
		}
		installedChunks[chunkId] = 0;
	}
	
};

var chunkLoadingGlobal = self["webpackChunksas_auth"] = self["webpackChunksas_auth"] || [];
chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));

}();
// webpack/runtime/rspack_unique_id
!function() {
__webpack_require__.ruid = "bundler=rspack@1.3.13";

}();
/************************************************************************/
// module cache are used so entry inlining is disabled
// startup
// Load entry module and return exports
__webpack_require__(95094);
var __webpack_exports__ = __webpack_require__(52109);
self.auth = __webpack_exports__;
})()
;//# sourceMappingURL=auth.container.js.bundle.map?platform=android/* RCSSB */eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJoYXNoIjoiN2UzYWEwMTZkODhmYzFlNzBmYTVlNzQ3YWI1NTM3MTBmOTZkNGQ3MjIxODdkNWQ0ZWI2MDVjM2Q5MjQzOGJlNiIsImlhdCI6MTc0ODkzMTI0MH0.kdhcaCYwxepWscQXv4rax1TswZA1YG9p4Hifiql7ld4ccgS1sQ2jRut9yVBC6bwhBto4qe24UTuAvAPOKmW5yYmD63BwEi1M8jbcRVC_Nn9n7E2mo32Pb0UIc4c6oV0Cb_-SuBY4q_Agpf92VjYkzxyeRMm4A85QT9nDj7CgwIcihtNpX7C-PqEQ2K3zbB9-uwC59SOp5BDqFCvgyS7XcbWGXQXLs01-wcgUO0EO2YbPgrjRqeDMsM7R54uTae9IwPPkN_JBm-LQ32f0wvFKK9zNpAIBHm1aU25-RfHFDGCFtGuxunpXdUSmxklOmPwQrji5ZOT59iuFnTIRA9Tsug                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              