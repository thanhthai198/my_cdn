(self["webpackChunksas_auth"] = self["webpackChunksas_auth"] || []).push([["vendors-node_modules_react-native_virtualized-lists_index_js"], {
20342: (function (module) {
"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @format
 *       strict
 */ 
function clamp(min, value, max) {
    if (value < min) {
        return min;
    }
    if (value > max) {
        return max;
    }
    return value;
}
module.exports = clamp;


}),
24624: (function (__unused_webpack_module, exports, __webpack_require__) {
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *      
 * @format
 */ Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return CellRenderer;
    }
}));
var _extends = __webpack_require__(87383);
var _inherits = __webpack_require__(85428);
var _interop_require_default = __webpack_require__(48810);
var _interop_require_wildcard = __webpack_require__(38504);
var _ReactNativeFeatureFlags = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(59241));
var _VirtualizedListContext = __webpack_require__(36021);
var _invariant = /*#__PURE__*/ _interop_require_default._(__webpack_require__(27761));
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(41845));
var _reactnative = __webpack_require__(64598);
var CellRenderer = /*#__PURE__*/ function(_React_PureComponent) {
    "use strict";
    _inherits._(CellRenderer, _React_PureComponent);
    function CellRenderer() {
        var _this;
        _this = _React_PureComponent.apply(this, arguments) || this, _this.state = {
            separatorProps: {
                highlighted: false,
                leadingItem: _this.props.item
            }
        }, // TODO: consider factoring separator stuff out of VirtualizedList into FlatList since it's not
        // reused by SectionList and we can keep VirtualizedList simpler.
        // $FlowFixMe[missing-local-annot]
        _this._separators = {
            highlight: function() {
                var _this_props = _this.props, cellKey = _this_props.cellKey, prevCellKey = _this_props.prevCellKey;
                _this.props.onUpdateSeparators([
                    cellKey,
                    prevCellKey
                ], {
                    highlighted: true
                });
            },
            unhighlight: function() {
                var _this_props = _this.props, cellKey = _this_props.cellKey, prevCellKey = _this_props.prevCellKey;
                _this.props.onUpdateSeparators([
                    cellKey,
                    prevCellKey
                ], {
                    highlighted: false
                });
            },
            updateProps: function(select, newProps) {
                var _this_props = _this.props, cellKey = _this_props.cellKey, prevCellKey = _this_props.prevCellKey;
                _this.props.onUpdateSeparators([
                    select === 'leading' ? prevCellKey : cellKey
                ], newProps);
            }
        }, _this._onLayout = function(nativeEvent) {
            _this.props.onCellLayout == null ? void 0 : _this.props.onCellLayout.call(_this.props, nativeEvent, _this.props.cellKey, _this.props.index);
        }, _this._onCellFocusCapture = function(e) {
            _this.props.onCellFocusCapture == null ? void 0 : _this.props.onCellFocusCapture.call(_this.props, _this.props.cellKey);
        };
        return _this;
    }
    var _proto = CellRenderer.prototype;
    _proto.updateSeparatorProps = function updateSeparatorProps(newProps) {
        this.setState(function(state) {
            return {
                separatorProps: _extends._({}, state.separatorProps, newProps)
            };
        });
    };
    _proto.componentWillUnmount = function componentWillUnmount() {
        this.props.onUnmount(this.props.cellKey);
    };
    _proto._renderElement = function _renderElement(renderItem, ListItemComponent, item, index) {
        if (renderItem && ListItemComponent) {
            console.warn('VirtualizedList: Both ListItemComponent and renderItem props are present. ListItemComponent will take' + ' precedence over renderItem.');
        }
        if (ListItemComponent) {
            return /*#__PURE__*/ _react.createElement(ListItemComponent, {
                item: item,
                index: index,
                separators: this._separators
            });
        }
        if (renderItem) {
            return renderItem({
                item: item,
                index: index,
                separators: this._separators
            });
        }
        (0, _invariant.default)(false, 'VirtualizedList: Either ListItemComponent or renderItem props are required but none were found.');
    };
    _proto.render = function render() {
        var _this_props = this.props, CellRendererComponent = _this_props.CellRendererComponent, ItemSeparatorComponent = _this_props.ItemSeparatorComponent, ListItemComponent = _this_props.ListItemComponent, cellKey = _this_props.cellKey, horizontal = _this_props.horizontal, item = _this_props.item, index = _this_props.index, inversionStyle = _this_props.inversionStyle, onCellLayout = _this_props.onCellLayout, renderItem = _this_props.renderItem;
        var element = this._renderElement(renderItem, ListItemComponent, item, index);
        // NOTE: that when this is a sticky header, `onLayout` will get automatically extracted and
        // called explicitly by `ScrollViewStickyHeader`.
        var itemSeparator = /*#__PURE__*/ _react.isValidElement(ItemSeparatorComponent) ? ItemSeparatorComponent : ItemSeparatorComponent && /*#__PURE__*/ _react.createElement(ItemSeparatorComponent, this.state.separatorProps);
        var cellStyle = inversionStyle ? horizontal ? [
            styles.rowReverse,
            inversionStyle
        ] : [
            styles.columnReverse,
            inversionStyle
        ] : horizontal ? [
            styles.row,
            inversionStyle
        ] : inversionStyle;
        var result = !CellRendererComponent ? /*#__PURE__*/ _react.createElement(_reactnative.View, _extends._({
            style: cellStyle,
            onFocusCapture: this._onCellFocusCapture
        }, onCellLayout && {
            onLayout: this._onLayout
        }), element, itemSeparator) : /*#__PURE__*/ _react.createElement(CellRendererComponent, _extends._({
            cellKey: cellKey,
            index: index,
            item: item,
            style: cellStyle,
            onFocusCapture: this._onCellFocusCapture
        }, onCellLayout && {
            onLayout: this._onLayout
        }), element, itemSeparator);
        return /*#__PURE__*/ _react.createElement(_VirtualizedListContext.VirtualizedListCellContextProvider, {
            cellKey: this.props.cellKey
        }, result);
    };
    CellRenderer.getDerivedStateFromProps = function getDerivedStateFromProps(props, prevState) {
        if (_ReactNativeFeatureFlags.enableOptimisedVirtualizedCells()) {
            if (props.item !== prevState.separatorProps.leadingItem) {
                return {
                    separatorProps: _extends._({}, prevState.separatorProps, {
                        leadingItem: props.item
                    })
                };
            }
            return null;
        } else {
            return {
                separatorProps: _extends._({}, prevState.separatorProps, {
                    leadingItem: props.item
                })
            };
        }
    };
    return CellRenderer;
}(_react.PureComponent);
var styles = _reactnative.StyleSheet.create({
    row: {
        flexDirection: 'row'
    },
    rowReverse: {
        flexDirection: 'row-reverse'
    },
    columnReverse: {
        flexDirection: 'column-reverse'
    }
});


}),
31606: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *      
 * @format
 */ 
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get computeWindowedRenderLimits () {
        return computeWindowedRenderLimits;
    },
    get elementsThatOverlapOffsets () {
        return elementsThatOverlapOffsets;
    },
    get keyExtractor () {
        return keyExtractor;
    },
    get newRangeCount () {
        return newRangeCount;
    }
});
var _sliced_to_array = __webpack_require__(21193);
var _type_of = __webpack_require__(29936);
function elementsThatOverlapOffsets(offsets, props, listMetrics, zoomScale) {
    if (zoomScale === void 0) zoomScale = 1;
    var itemCount = props.getItemCount(props.data);
    var result = [];
    for(var offsetIndex = 0; offsetIndex < offsets.length; offsetIndex++){
        var currentOffset = offsets[offsetIndex];
        var left = 0;
        var right = itemCount - 1;
        while(left <= right){
            var mid = left + Math.floor((right - left) / 2);
            var frame = listMetrics.getCellMetricsApprox(mid, props);
            var scaledOffsetStart = frame.offset * zoomScale;
            var scaledOffsetEnd = (frame.offset + frame.length) * zoomScale;
            // We want the first frame that contains the offset, with inclusive bounds. Thus, for the
            // first frame the scaledOffsetStart is inclusive, while for other frames it is exclusive.
            if (mid === 0 && currentOffset < scaledOffsetStart || mid !== 0 && currentOffset <= scaledOffsetStart) {
                right = mid - 1;
            } else if (currentOffset > scaledOffsetEnd) {
                left = mid + 1;
            } else {
                result[offsetIndex] = mid;
                break;
            }
        }
    }
    return result;
}
function newRangeCount(prev, next) {
    return next.last - next.first + 1 - Math.max(0, 1 + Math.min(next.last, prev.last) - Math.max(next.first, prev.first));
}
function computeWindowedRenderLimits(props, maxToRenderPerBatch, windowSize, prev, listMetrics, scrollMetrics) {
    var itemCount = props.getItemCount(props.data);
    if (itemCount === 0) {
        return {
            first: 0,
            last: -1
        };
    }
    var offset = scrollMetrics.offset, velocity = scrollMetrics.velocity, visibleLength = scrollMetrics.visibleLength, _scrollMetrics_zoomScale = scrollMetrics.zoomScale, zoomScale = _scrollMetrics_zoomScale === void 0 ? 1 : _scrollMetrics_zoomScale;
    // Start with visible area, then compute maximum overscan region by expanding from there, biased
    // in the direction of scroll. Total overscan area is capped, which should cap memory consumption
    // too.
    var visibleBegin = Math.max(0, offset);
    var visibleEnd = visibleBegin + visibleLength;
    var overscanLength = (windowSize - 1) * visibleLength;
    // Considering velocity seems to introduce more churn than it's worth.
    var leadFactor = 0.5; // Math.max(0, Math.min(1, velocity / 25 + 0.5));
    var fillPreference = velocity > 1 ? 'after' : velocity < -1 ? 'before' : 'none';
    var overscanBegin = Math.max(0, visibleBegin - (1 - leadFactor) * overscanLength);
    var overscanEnd = Math.max(0, visibleEnd + leadFactor * overscanLength);
    var lastItemOffset = listMetrics.getCellMetricsApprox(itemCount - 1, props).offset * zoomScale;
    if (lastItemOffset < overscanBegin) {
        // Entire list is before our overscan window
        return {
            first: Math.max(0, itemCount - 1 - maxToRenderPerBatch),
            last: itemCount - 1
        };
    }
    // Find the indices that correspond to the items at the render boundaries we're targeting.
    var _elementsThatOverlapOffsets = _sliced_to_array._(elementsThatOverlapOffsets([
        overscanBegin,
        visibleBegin,
        visibleEnd,
        overscanEnd
    ], props, listMetrics, zoomScale), 4), overscanFirst = _elementsThatOverlapOffsets[0], first = _elementsThatOverlapOffsets[1], last = _elementsThatOverlapOffsets[2], overscanLast = _elementsThatOverlapOffsets[3];
    overscanFirst = overscanFirst == null ? 0 : overscanFirst;
    first = first == null ? Math.max(0, overscanFirst) : first;
    overscanLast = overscanLast == null ? itemCount - 1 : overscanLast;
    last = last == null ? Math.min(overscanLast, first + maxToRenderPerBatch - 1) : last;
    var visible = {
        first: first,
        last: last
    };
    // We want to limit the number of new cells we're rendering per batch so that we can fill the
    // content on the screen quickly. If we rendered the entire overscan window at once, the user
    // could be staring at white space for a long time waiting for a bunch of offscreen content to
    // render.
    var newCellCount = newRangeCount(prev, visible);
    while(true){
        if (first <= overscanFirst && last >= overscanLast) {
            break;
        }
        var maxNewCells = newCellCount >= maxToRenderPerBatch;
        var firstWillAddMore = first <= prev.first || first > prev.last;
        var firstShouldIncrement = first > overscanFirst && (!maxNewCells || !firstWillAddMore);
        var lastWillAddMore = last >= prev.last || last < prev.first;
        var lastShouldIncrement = last < overscanLast && (!maxNewCells || !lastWillAddMore);
        if (maxNewCells && !firstShouldIncrement && !lastShouldIncrement) {
            break;
        }
        if (firstShouldIncrement && !(fillPreference === 'after' && lastShouldIncrement && lastWillAddMore)) {
            if (firstWillAddMore) {
                newCellCount++;
            }
            first--;
        }
        if (lastShouldIncrement && !(fillPreference === 'before' && firstShouldIncrement && firstWillAddMore)) {
            if (lastWillAddMore) {
                newCellCount++;
            }
            last++;
        }
    }
    if (!(last >= first && first >= 0 && last < itemCount && first >= overscanFirst && last <= overscanLast && first <= visible.first && last >= visible.last)) {
        throw new Error('Bad window calculation ' + JSON.stringify({
            first: first,
            last: last,
            itemCount: itemCount,
            overscanFirst: overscanFirst,
            overscanLast: overscanLast,
            visible: visible
        }));
    }
    return {
        first: first,
        last: last
    };
}
function keyExtractor(item, index) {
    if ((typeof item === "undefined" ? "undefined" : _type_of._(item)) === 'object' && (item == null ? void 0 : item.key) != null) {
        return item.key;
    }
    if ((typeof item === "undefined" ? "undefined" : _type_of._(item)) === 'object' && (item == null ? void 0 : item.id) != null) {
        return item.id;
    }
    return String(index);
}


}),
36021: (function (__unused_webpack_module, exports, __webpack_require__) {
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *       strict-local
 * @format
 */ Object.defineProperty(exports, "__esModule", ({
    value: true
}));
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get VirtualizedListCellContextProvider () {
        return VirtualizedListCellContextProvider;
    },
    get VirtualizedListContext () {
        return VirtualizedListContext;
    },
    get VirtualizedListContextProvider () {
        return VirtualizedListContextProvider;
    },
    get VirtualizedListContextResetter () {
        return VirtualizedListContextResetter;
    }
});
var _extends = __webpack_require__(87383);
var _interop_require_wildcard = __webpack_require__(38504);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(41845));
var VirtualizedListContext = /*#__PURE__*/ _react.createContext(null);
if (false) {}
function VirtualizedListContextResetter(param) {
    var children = param.children;
    return /*#__PURE__*/ _react.createElement(VirtualizedListContext.Provider, {
        value: null
    }, children);
}
function VirtualizedListContextProvider(param) {
    var children = param.children, value = param.value;
    // Avoid setting a newly created context object if the values are identical.
    var context = (0, _react.useMemo)(function() {
        return {
            cellKey: null,
            getScrollMetrics: value.getScrollMetrics,
            horizontal: value.horizontal,
            getOutermostParentListRef: value.getOutermostParentListRef,
            registerAsNestedChild: value.registerAsNestedChild,
            unregisterAsNestedChild: value.unregisterAsNestedChild
        };
    }, [
        value.getScrollMetrics,
        value.horizontal,
        value.getOutermostParentListRef,
        value.registerAsNestedChild,
        value.unregisterAsNestedChild
    ]);
    return /*#__PURE__*/ _react.createElement(VirtualizedListContext.Provider, {
        value: context
    }, children);
}
function VirtualizedListCellContextProvider(param) {
    var cellKey = param.cellKey, children = param.children;
    // Avoid setting a newly created context object if the values are identical.
    var currContext = (0, _react.useContext)(VirtualizedListContext);
    var context = (0, _react.useMemo)(function() {
        return currContext == null ? null : _extends._({}, currContext, {
            cellKey: cellKey
        });
    }, [
        currContext,
        cellKey
    ]);
    return /*#__PURE__*/ _react.createElement(VirtualizedListContext.Provider, {
        value: context
    }, children);
}


}),
39966: (function (module, exports, __webpack_require__) {
"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *      
 * @format
 */ 
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _extends = __webpack_require__(87383);
var _interop_require_default = __webpack_require__(48810);
var _ListMetricsAggregator = /*#__PURE__*/ _interop_require_default._(__webpack_require__(43967));
var Info = function Info() {
    this.any_blank_count = 0;
    this.any_blank_ms = 0;
    this.any_blank_speed_sum = 0;
    this.mostly_blank_count = 0;
    this.mostly_blank_ms = 0;
    this.pixels_blank = 0;
    this.pixels_sampled = 0;
    this.pixels_scrolled = 0;
    this.total_time_spent = 0;
    this.sample_count = 0;
};
var DEBUG = false;
var _listeners = [];
var _minSampleCount = 10;
var _sampleRate = DEBUG ? 1 : null;
/**
 * A helper class for detecting when the maximem fill rate of `VirtualizedList` is exceeded.
 * By default the sampling rate is set to zero and this will do nothing. If you want to collect
 * samples (e.g. to log them), make sure to call `FillRateHelper.setSampleRate(0.0-1.0)`.
 *
 * Listeners and sample rate are global for all `VirtualizedList`s - typical usage will combine with
 * `SceneTracker.getActiveScene` to determine the context of the events.
 */ var FillRateHelper = /*#__PURE__*/ function() {
    function FillRateHelper(listMetrics) {
        this._anyBlankStartTime = null;
        this._enabled = false;
        this._info = new Info();
        this._mostlyBlankStartTime = null;
        this._samplesStartTime = null;
        this._listMetrics = listMetrics;
        this._enabled = (_sampleRate || 0) > Math.random();
        this._resetData();
    }
    var _proto = FillRateHelper.prototype;
    _proto.activate = function activate() {
        if (this._enabled && this._samplesStartTime == null) {
            DEBUG && console.debug('FillRateHelper: activate');
            this._samplesStartTime = __webpack_require__.g.performance.now();
        }
    };
    _proto.deactivateAndFlush = function deactivateAndFlush() {
        if (!this._enabled) {
            return;
        }
        var start = this._samplesStartTime; // const for flow
        if (start == null) {
            DEBUG && console.debug('FillRateHelper: bail on deactivate with no start time');
            return;
        }
        if (this._info.sample_count < _minSampleCount) {
            // Don't bother with under-sampled events.
            this._resetData();
            return;
        }
        var total_time_spent = __webpack_require__.g.performance.now() - start;
        var info = _extends._({}, this._info, {
            total_time_spent: total_time_spent
        });
        if (DEBUG) {
            var derived = {
                avg_blankness: this._info.pixels_blank / this._info.pixels_sampled,
                avg_speed: this._info.pixels_scrolled / (total_time_spent / 1000),
                avg_speed_when_any_blank: this._info.any_blank_speed_sum / this._info.any_blank_count,
                any_blank_per_min: this._info.any_blank_count / (total_time_spent / 1000 / 60),
                any_blank_time_frac: this._info.any_blank_ms / total_time_spent,
                mostly_blank_per_min: this._info.mostly_blank_count / (total_time_spent / 1000 / 60),
                mostly_blank_time_frac: this._info.mostly_blank_ms / total_time_spent
            };
            for(var key in derived){
                // $FlowFixMe[prop-missing]
                // $FlowFixMe[invalid-computed-prop]
                derived[key] = Math.round(1000 * derived[key]) / 1000;
            }
            console.debug('FillRateHelper deactivateAndFlush: ', {
                derived: derived,
                info: info
            });
        }
        _listeners.forEach(function(listener) {
            return listener(info);
        });
        this._resetData();
    };
    _proto.computeBlankness = function computeBlankness(props, cellsAroundViewport, scrollMetrics) {
        if (!this._enabled || props.getItemCount(props.data) === 0 || cellsAroundViewport.last < cellsAroundViewport.first || this._samplesStartTime == null) {
            return 0;
        }
        var dOffset = scrollMetrics.dOffset, offset = scrollMetrics.offset, velocity = scrollMetrics.velocity, visibleLength = scrollMetrics.visibleLength;
        // Denominator metrics that we track for all events - most of the time there is no blankness and
        // we want to capture that.
        this._info.sample_count++;
        this._info.pixels_sampled += Math.round(visibleLength);
        this._info.pixels_scrolled += Math.round(Math.abs(dOffset));
        var scrollSpeed = Math.round(Math.abs(velocity) * 1000); // px / sec
        // Whether blank now or not, record the elapsed time blank if we were blank last time.
        var now = __webpack_require__.g.performance.now();
        if (this._anyBlankStartTime != null) {
            this._info.any_blank_ms += now - this._anyBlankStartTime;
        }
        this._anyBlankStartTime = null;
        if (this._mostlyBlankStartTime != null) {
            this._info.mostly_blank_ms += now - this._mostlyBlankStartTime;
        }
        this._mostlyBlankStartTime = null;
        var blankTop = 0;
        var first = cellsAroundViewport.first;
        var firstFrame = this._listMetrics.getCellMetrics(first, props);
        while(first <= cellsAroundViewport.last && (!firstFrame || !firstFrame.isMounted)){
            firstFrame = this._listMetrics.getCellMetrics(first, props);
            first++;
        }
        // Only count blankTop if we aren't rendering the first item, otherwise we will count the header
        // as blank.
        if (firstFrame && first > 0) {
            blankTop = Math.min(visibleLength, Math.max(0, firstFrame.offset - offset));
        }
        var blankBottom = 0;
        var last = cellsAroundViewport.last;
        var lastFrame = this._listMetrics.getCellMetrics(last, props);
        while(last >= cellsAroundViewport.first && (!lastFrame || !lastFrame.isMounted)){
            lastFrame = this._listMetrics.getCellMetrics(last, props);
            last--;
        }
        // Only count blankBottom if we aren't rendering the last item, otherwise we will count the
        // footer as blank.
        if (lastFrame && last < props.getItemCount(props.data) - 1) {
            var bottomEdge = lastFrame.offset + lastFrame.length;
            blankBottom = Math.min(visibleLength, Math.max(0, offset + visibleLength - bottomEdge));
        }
        var pixels_blank = Math.round(blankTop + blankBottom);
        var blankness = pixels_blank / visibleLength;
        if (blankness > 0) {
            this._anyBlankStartTime = now;
            this._info.any_blank_speed_sum += scrollSpeed;
            this._info.any_blank_count++;
            this._info.pixels_blank += pixels_blank;
            if (blankness > 0.5) {
                this._mostlyBlankStartTime = now;
                this._info.mostly_blank_count++;
            }
        } else if (scrollSpeed < 0.01 || Math.abs(dOffset) < 1) {
            this.deactivateAndFlush();
        }
        return blankness;
    };
    _proto.enabled = function enabled() {
        return this._enabled;
    };
    _proto._resetData = function _resetData() {
        this._anyBlankStartTime = null;
        this._info = new Info();
        this._mostlyBlankStartTime = null;
        this._samplesStartTime = null;
    };
    FillRateHelper.addListener = function addListener(callback) {
        if (_sampleRate === null) {
            console.warn('Call `FillRateHelper.setSampleRate` before `addListener`.');
        }
        _listeners.push(callback);
        return {
            remove: function() {
                _listeners = _listeners.filter(function(listener) {
                    return callback !== listener;
                });
            }
        };
    };
    FillRateHelper.setSampleRate = function setSampleRate(sampleRate) {
        _sampleRate = sampleRate;
    };
    FillRateHelper.setMinSampleCount = function setMinSampleCount(minSampleCount) {
        _minSampleCount = minSampleCount;
    };
    return FillRateHelper;
}();
module.exports = FillRateHelper;


}),
40541: (function (module, exports, __webpack_require__) {
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *      
 * @format
 */ Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _extends = __webpack_require__(87383);
var _inherits = __webpack_require__(85428);
var _interop_require_default = __webpack_require__(48810);
var _interop_require_wildcard = __webpack_require__(38504);
var _object_without_properties_loose = __webpack_require__(35684);
var _sliced_to_array = __webpack_require__(21193);
var _VirtualizedList = /*#__PURE__*/ _interop_require_default._(__webpack_require__(44902));
var _VirtualizeUtils = __webpack_require__(31606);
var _invariant = /*#__PURE__*/ _interop_require_default._(__webpack_require__(27761));
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(41845));
/**
 * Right now this just flattens everything into one list and uses VirtualizedList under the
 * hood. The only operation that might not scale well is concatting the data arrays of all the
 * sections when new props are received, which should be plenty fast for up to ~10,000 items.
 */ var VirtualizedSectionList = /*#__PURE__*/ function(_React_PureComponent) {
    "use strict";
    _inherits._(VirtualizedSectionList, _React_PureComponent);
    function VirtualizedSectionList() {
        var _this;
        _this = _React_PureComponent.apply(this, arguments) || this, // $FlowFixMe[missing-local-annot]
        _this._keyExtractor = function(item, index) {
            var info = _this._subExtractor(index);
            return info && info.key || String(index);
        }, _this._convertViewable = function(viewable) {
            (0, _invariant.default)(viewable.index != null, 'Received a broken ViewToken');
            var info = _this._subExtractor(viewable.index);
            if (!info) {
                return null;
            }
            var keyExtractorWithNullableIndex = info.section.keyExtractor;
            var keyExtractorWithNonNullableIndex = _this.props.keyExtractor || _VirtualizeUtils.keyExtractor;
            var _info_index;
            var key = keyExtractorWithNullableIndex != null ? keyExtractorWithNullableIndex(viewable.item, info.index) : keyExtractorWithNonNullableIndex(viewable.item, (_info_index = info.index) != null ? _info_index : 0);
            return _extends._({}, viewable, {
                index: info.index,
                key: key,
                section: info.section
            });
        }, _this._onViewableItemsChanged = function(param) {
            var viewableItems = param.viewableItems, changed = param.changed;
            var onViewableItemsChanged = _this.props.onViewableItemsChanged;
            if (onViewableItemsChanged != null) {
                onViewableItemsChanged({
                    viewableItems: viewableItems.map(_this._convertViewable, _this).filter(Boolean),
                    changed: changed.map(_this._convertViewable, _this).filter(Boolean)
                });
            }
        }, _this._renderItem = function(listItemCount) {
            return(// eslint-disable-next-line react/no-unstable-nested-components
            function(param) {
                var item = param.item, index = param.index;
                var info = _this._subExtractor(index);
                if (!info) {
                    return null;
                }
                var infoIndex = info.index;
                if (infoIndex == null) {
                    var section = info.section;
                    if (info.header === true) {
                        var renderSectionHeader = _this.props.renderSectionHeader;
                        return renderSectionHeader ? renderSectionHeader({
                            section: section
                        }) : null;
                    } else {
                        var renderSectionFooter = _this.props.renderSectionFooter;
                        return renderSectionFooter ? renderSectionFooter({
                            section: section
                        }) : null;
                    }
                } else {
                    var renderItem = info.section.renderItem || _this.props.renderItem;
                    var SeparatorComponent = _this._getSeparatorComponent(index, info, listItemCount);
                    (0, _invariant.default)(renderItem, 'no renderItem!');
                    return /*#__PURE__*/ _react.createElement(ItemWithSeparator, {
                        SeparatorComponent: SeparatorComponent,
                        LeadingSeparatorComponent: infoIndex === 0 ? _this.props.SectionSeparatorComponent : undefined,
                        cellKey: info.key,
                        index: infoIndex,
                        item: item,
                        leadingItem: info.leadingItem,
                        leadingSection: info.leadingSection,
                        prevCellKey: (_this._subExtractor(index - 1) || {}).key,
                        // Callback to provide updateHighlight for this item
                        setSelfHighlightCallback: _this._setUpdateHighlightFor,
                        setSelfUpdatePropsCallback: _this._setUpdatePropsFor,
                        // Provide child ability to set highlight/updateProps for previous item using prevCellKey
                        updateHighlightFor: _this._updateHighlightFor,
                        updatePropsFor: _this._updatePropsFor,
                        renderItem: renderItem,
                        section: info.section,
                        trailingItem: info.trailingItem,
                        trailingSection: info.trailingSection,
                        inverted: !!_this.props.inverted
                    });
                }
            });
        }, _this._updatePropsFor = function(cellKey, value) {
            var updateProps = _this._updatePropsMap[cellKey];
            if (updateProps != null) {
                updateProps(value);
            }
        }, _this._updateHighlightFor = function(cellKey, value) {
            var updateHighlight = _this._updateHighlightMap[cellKey];
            if (updateHighlight != null) {
                updateHighlight(value);
            }
        }, _this._setUpdateHighlightFor = function(cellKey, updateHighlightFn) {
            if (updateHighlightFn != null) {
                _this._updateHighlightMap[cellKey] = updateHighlightFn;
            } else {
                // $FlowFixMe[prop-missing]
                delete _this._updateHighlightFor[cellKey];
            }
        }, _this._setUpdatePropsFor = function(cellKey, updatePropsFn) {
            if (updatePropsFn != null) {
                _this._updatePropsMap[cellKey] = updatePropsFn;
            } else {
                delete _this._updatePropsMap[cellKey];
            }
        }, _this._updateHighlightMap = {}, _this._updatePropsMap = {}, _this._captureRef = function(ref) {
            _this._listRef = ref;
        };
        return _this;
    }
    var _proto = VirtualizedSectionList.prototype;
    _proto.scrollToLocation = function scrollToLocation(params) {
        var index = params.itemIndex;
        for(var i = 0; i < params.sectionIndex; i++){
            index += this.props.getItemCount(this.props.sections[i].data) + 2;
        }
        var viewOffset = params.viewOffset || 0;
        if (this._listRef == null) {
            return;
        }
        var listRef = this._listRef;
        if (params.itemIndex > 0 && this.props.stickySectionHeadersEnabled) {
            var frame = listRef.__getListMetrics().getCellMetricsApprox(index - params.itemIndex, listRef.props);
            viewOffset += frame.length;
        }
        var toIndexParams = _extends._({}, params, {
            viewOffset: viewOffset,
            index: index
        });
        // $FlowFixMe[incompatible-use]
        this._listRef.scrollToIndex(toIndexParams);
    };
    _proto.getListRef = function getListRef() {
        return this._listRef;
    };
    _proto.render = function render() {
        var _this = this;
        var _this_props = this.props, ItemSeparatorComponent = _this_props.ItemSeparatorComponent, SectionSeparatorComponent = _this_props.SectionSeparatorComponent, _renderItem = _this_props.renderItem, renderSectionFooter = _this_props.renderSectionFooter, renderSectionHeader = _this_props.renderSectionHeader, _sections = _this_props.sections, stickySectionHeadersEnabled = _this_props.stickySectionHeadersEnabled, passThroughProps = _object_without_properties_loose._(_this_props, [
            "ItemSeparatorComponent",
            "SectionSeparatorComponent",
            "renderItem",
            "renderSectionFooter",
            "renderSectionHeader",
            "sections",
            "stickySectionHeadersEnabled"
        ]);
        var listHeaderOffset = this.props.ListHeaderComponent ? 1 : 0;
        var stickyHeaderIndices = this.props.stickySectionHeadersEnabled ? [] : undefined;
        var itemCount = 0;
        for(var _i = 0, _this_props_sections = this.props.sections; _i < _this_props_sections.length; _i++){
            var section = _this_props_sections[_i];
            // Track the section header indices
            if (stickyHeaderIndices != null) {
                stickyHeaderIndices.push(itemCount + listHeaderOffset);
            }
            // Add two for the section header and footer.
            itemCount += 2;
            itemCount += this.props.getItemCount(section.data);
        }
        var renderItem = this._renderItem(itemCount);
        return /*#__PURE__*/ _react.createElement(_VirtualizedList.default, _extends._({}, passThroughProps, {
            keyExtractor: this._keyExtractor,
            stickyHeaderIndices: stickyHeaderIndices,
            renderItem: renderItem,
            data: this.props.sections,
            getItem: function(sections, index) {
                return _this._getItem(_this.props, sections, index);
            },
            getItemCount: function() {
                return itemCount;
            },
            onViewableItemsChanged: this.props.onViewableItemsChanged ? this._onViewableItemsChanged : undefined,
            ref: this._captureRef
        }));
    };
    _proto._getItem = function _getItem(props, sections, index) {
        if (!sections) {
            return null;
        }
        var itemIdx = index - 1;
        for(var i = 0; i < sections.length; i++){
            var section = sections[i];
            var sectionData = section.data;
            var itemCount = props.getItemCount(sectionData);
            if (itemIdx === -1 || itemIdx === itemCount) {
                // We intend for there to be overflow by one on both ends of the list.
                // This will be for headers and footers. When returning a header or footer
                // item the section itself is the item.
                return section;
            } else if (itemIdx < itemCount) {
                // If we are in the bounds of the list's data then return the item.
                return props.getItem(sectionData, itemIdx);
            } else {
                itemIdx -= itemCount + 2; // Add two for the header and footer
            }
        }
        return null;
    };
    _proto._subExtractor = function _subExtractor(index) {
        var itemIndex = index;
        var _this_props = this.props, getItem = _this_props.getItem, getItemCount = _this_props.getItemCount, keyExtractor = _this_props.keyExtractor, sections = _this_props.sections;
        for(var i = 0; i < sections.length; i++){
            var section = sections[i];
            var sectionData = section.data;
            var key = section.key || String(i);
            itemIndex -= 1; // The section adds an item for the header
            if (itemIndex >= getItemCount(sectionData) + 1) {
                itemIndex -= getItemCount(sectionData) + 1; // The section adds an item for the footer.
            } else if (itemIndex === -1) {
                return {
                    section: section,
                    key: key + ':header',
                    index: null,
                    header: true,
                    trailingSection: sections[i + 1]
                };
            } else if (itemIndex === getItemCount(sectionData)) {
                return {
                    section: section,
                    key: key + ':footer',
                    index: null,
                    header: false,
                    trailingSection: sections[i + 1]
                };
            } else {
                var extractor = section.keyExtractor || keyExtractor || _VirtualizeUtils.keyExtractor;
                return {
                    section: section,
                    key: key + ':' + extractor(getItem(sectionData, itemIndex), itemIndex),
                    index: itemIndex,
                    leadingItem: getItem(sectionData, itemIndex - 1),
                    leadingSection: sections[i - 1],
                    trailingItem: getItem(sectionData, itemIndex + 1),
                    trailingSection: sections[i + 1]
                };
            }
        }
    };
    _proto._getSeparatorComponent = function _getSeparatorComponent(index, info, listItemCount) {
        info = info || this._subExtractor(index);
        if (!info) {
            return null;
        }
        var ItemSeparatorComponent = info.section.ItemSeparatorComponent || this.props.ItemSeparatorComponent;
        var SectionSeparatorComponent = this.props.SectionSeparatorComponent;
        var isLastItemInList = index === listItemCount - 1;
        var isLastItemInSection = info.index === this.props.getItemCount(info.section.data) - 1;
        if (SectionSeparatorComponent && isLastItemInSection) {
            return SectionSeparatorComponent;
        }
        if (ItemSeparatorComponent && !isLastItemInSection && !isLastItemInList) {
            return ItemSeparatorComponent;
        }
        return null;
    };
    return VirtualizedSectionList;
}(_react.PureComponent);
function ItemWithSeparator(props) {
    var LeadingSeparatorComponent = props.LeadingSeparatorComponent, // this is the trailing separator and is associated with this item
    SeparatorComponent = props.SeparatorComponent, cellKey = props.cellKey, prevCellKey = props.prevCellKey, setSelfHighlightCallback = props.setSelfHighlightCallback, updateHighlightFor = props.updateHighlightFor, setSelfUpdatePropsCallback = props.setSelfUpdatePropsCallback, updatePropsFor = props.updatePropsFor, item = props.item, index = props.index, section = props.section, inverted = props.inverted;
    var _React_useState = _sliced_to_array._(_react.useState(false), 2), leadingSeparatorHiglighted = _React_useState[0], setLeadingSeparatorHighlighted = _React_useState[1];
    var _React_useState1 = _sliced_to_array._(_react.useState(false), 2), separatorHighlighted = _React_useState1[0], setSeparatorHighlighted = _React_useState1[1];
    var _React_useState2 = _sliced_to_array._(_react.useState({
        leadingItem: props.leadingItem,
        leadingSection: props.leadingSection,
        section: props.section,
        trailingItem: props.item,
        trailingSection: props.trailingSection
    }), 2), leadingSeparatorProps = _React_useState2[0], setLeadingSeparatorProps = _React_useState2[1];
    var _React_useState3 = _sliced_to_array._(_react.useState({
        leadingItem: props.item,
        leadingSection: props.leadingSection,
        section: props.section,
        trailingItem: props.trailingItem,
        trailingSection: props.trailingSection
    }), 2), separatorProps = _React_useState3[0], setSeparatorProps = _React_useState3[1];
    _react.useEffect(function() {
        setSelfHighlightCallback(cellKey, setSeparatorHighlighted);
        // $FlowFixMe[incompatible-call]
        setSelfUpdatePropsCallback(cellKey, setSeparatorProps);
        return function() {
            setSelfUpdatePropsCallback(cellKey, null);
            setSelfHighlightCallback(cellKey, null);
        };
    }, [
        cellKey,
        setSelfHighlightCallback,
        setSeparatorProps,
        setSelfUpdatePropsCallback
    ]);
    var separators = {
        highlight: function() {
            setLeadingSeparatorHighlighted(true);
            setSeparatorHighlighted(true);
            if (prevCellKey != null) {
                updateHighlightFor(prevCellKey, true);
            }
        },
        unhighlight: function() {
            setLeadingSeparatorHighlighted(false);
            setSeparatorHighlighted(false);
            if (prevCellKey != null) {
                updateHighlightFor(prevCellKey, false);
            }
        },
        updateProps: function(select, newProps) {
            if (select === 'leading') {
                if (LeadingSeparatorComponent != null) {
                    setLeadingSeparatorProps(_extends._({}, leadingSeparatorProps, newProps));
                } else if (prevCellKey != null) {
                    // update the previous item's separator
                    updatePropsFor(prevCellKey, _extends._({}, leadingSeparatorProps, newProps));
                }
            } else if (select === 'trailing' && SeparatorComponent != null) {
                setSeparatorProps(_extends._({}, separatorProps, newProps));
            }
        }
    };
    var element = props.renderItem({
        item: item,
        index: index,
        section: section,
        separators: separators
    });
    var leadingSeparator = LeadingSeparatorComponent != null && /*#__PURE__*/ _react.createElement(LeadingSeparatorComponent, _extends._({
        highlighted: leadingSeparatorHiglighted
    }, leadingSeparatorProps));
    var separator = SeparatorComponent != null && /*#__PURE__*/ _react.createElement(SeparatorComponent, _extends._({
        highlighted: separatorHighlighted
    }, separatorProps));
    var RenderSeparator = leadingSeparator || separator;
    var firstSeparator = inverted === false ? leadingSeparator : separator;
    var secondSeparator = inverted === false ? separator : leadingSeparator;
    return /*#__PURE__*/ _react.createElement(_react.Fragment, null, RenderSeparator ? firstSeparator : null, element, RenderSeparator ? secondSeparator : null);
}
/* $FlowFixMe[class-object-subtyping] added when improving typing for this
 * parameters */ // $FlowFixMe[method-unbinding]
module.exports = VirtualizedSectionList;


}),
43332: (function (__unused_webpack_module, exports, __webpack_require__) {
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *       strict
 * @format
 */ Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "CellRenderMask", ({
    enumerable: true,
    get: function() {
        return CellRenderMask;
    }
}));
var _extends = __webpack_require__(87383);
var _interop_require_default = __webpack_require__(48810);
var _sliced_to_array = __webpack_require__(21193);
var _to_consumable_array = __webpack_require__(8034);
var _invariant = /*#__PURE__*/ _interop_require_default._(__webpack_require__(27761));
var CellRenderMask = /*#__PURE__*/ function() {
    "use strict";
    function CellRenderMask(numCells) {
        (0, _invariant.default)(numCells >= 0, 'CellRenderMask must contain a non-negative number os cells');
        this._numCells = numCells;
        if (numCells === 0) {
            this._regions = [];
        } else {
            this._regions = [
                {
                    first: 0,
                    last: numCells - 1,
                    isSpacer: true
                }
            ];
        }
    }
    var _proto = CellRenderMask.prototype;
    _proto.enumerateRegions = function enumerateRegions() {
        return this._regions;
    };
    _proto.addCells = function addCells(cells) {
        var _this__regions;
        (0, _invariant.default)(cells.first >= 0 && cells.first < this._numCells && cells.last >= -1 && cells.last < this._numCells && cells.last >= cells.first - 1, 'CellRenderMask.addCells called with invalid cell range');
        // VirtualizedList uses inclusive ranges, where zero-count states are
        // possible. E.g. [0, -1] for no cells, starting at 0.
        if (cells.last < cells.first) {
            return;
        }
        var _this__findRegion = _sliced_to_array._(this._findRegion(cells.first), 2), firstIntersect = _this__findRegion[0], firstIntersectIdx = _this__findRegion[1];
        var _this__findRegion1 = _sliced_to_array._(this._findRegion(cells.last), 2), lastIntersect = _this__findRegion1[0], lastIntersectIdx = _this__findRegion1[1];
        // Fast-path if the cells to add are already all present in the mask. We
        // will otherwise need to do some mutation.
        if (firstIntersectIdx === lastIntersectIdx && !firstIntersect.isSpacer) {
            return;
        }
        // We need to replace the existing covered regions with 1-3 new regions
        // depending whether we need to split spacers out of overlapping regions.
        var newLeadRegion = [];
        var newTailRegion = [];
        var newMainRegion = _extends._({}, cells, {
            isSpacer: false
        });
        if (firstIntersect.first < newMainRegion.first) {
            if (firstIntersect.isSpacer) {
                newLeadRegion.push({
                    first: firstIntersect.first,
                    last: newMainRegion.first - 1,
                    isSpacer: true
                });
            } else {
                newMainRegion.first = firstIntersect.first;
            }
        }
        if (lastIntersect.last > newMainRegion.last) {
            if (lastIntersect.isSpacer) {
                newTailRegion.push({
                    first: newMainRegion.last + 1,
                    last: lastIntersect.last,
                    isSpacer: true
                });
            } else {
                newMainRegion.last = lastIntersect.last;
            }
        }
        var replacementRegions = _to_consumable_array._(newLeadRegion).concat([
            newMainRegion
        ], _to_consumable_array._(newTailRegion));
        var numRegionsToDelete = lastIntersectIdx - firstIntersectIdx + 1;
        (_this__regions = this._regions).splice.apply(_this__regions, [
            firstIntersectIdx,
            numRegionsToDelete
        ].concat(_to_consumable_array._(replacementRegions)));
    };
    _proto.numCells = function numCells() {
        return this._numCells;
    };
    _proto.equals = function equals(other) {
        return this._numCells === other._numCells && this._regions.length === other._regions.length && this._regions.every(function(region, i) {
            return region.first === other._regions[i].first && region.last === other._regions[i].last && region.isSpacer === other._regions[i].isSpacer;
        });
    };
    _proto._findRegion = function _findRegion(cellIdx) {
        var firstIdx = 0;
        var lastIdx = this._regions.length - 1;
        while(firstIdx <= lastIdx){
            var middleIdx = Math.floor((firstIdx + lastIdx) / 2);
            var middleRegion = this._regions[middleIdx];
            if (cellIdx >= middleRegion.first && cellIdx <= middleRegion.last) {
                return [
                    middleRegion,
                    middleIdx
                ];
            } else if (cellIdx < middleRegion.first) {
                lastIdx = middleIdx - 1;
            } else if (cellIdx > middleRegion.last) {
                firstIdx = middleIdx + 1;
            }
        }
        (0, _invariant.default)(false, "A region was not found containing cellIdx " + cellIdx);
    };
    return CellRenderMask;
}();


}),
43967: (function (__unused_webpack_module, exports, __webpack_require__) {
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *       strict-local
 * @format
 */ Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return ListMetricsAggregator;
    }
}));
var _interop_require_default = __webpack_require__(48810);
var _VirtualizeUtils = __webpack_require__(31606);
var _invariant = /*#__PURE__*/ _interop_require_default._(__webpack_require__(27761));
var ListMetricsAggregator = /*#__PURE__*/ function() {
    "use strict";
    function ListMetricsAggregator() {
        this._averageCellLength = 0;
        this._cellMetrics = new Map();
        this._highestMeasuredCellIndex = 0;
        this._measuredCellsLength = 0;
        this._measuredCellsCount = 0;
        this._orientation = {
            horizontal: false,
            rtl: false
        };
    }
    var _proto = ListMetricsAggregator.prototype;
    /**
   * Notify the ListMetricsAggregator that a cell has been laid out.
   *
   * @returns whether the cell layout has changed since last notification
   */ _proto.notifyCellLayout = function notifyCellLayout(param) {
        var cellIndex = param.cellIndex, cellKey = param.cellKey, orientation = param.orientation, layout = param.layout;
        this._invalidateIfOrientationChanged(orientation);
        var next = {
            index: cellIndex,
            length: this._selectLength(layout),
            isMounted: true,
            offset: this.flowRelativeOffset(layout)
        };
        var curr = this._cellMetrics.get(cellKey);
        if (!curr || next.offset !== curr.offset || next.length !== curr.length) {
            if (curr) {
                var dLength = next.length - curr.length;
                this._measuredCellsLength += dLength;
            } else {
                this._measuredCellsLength += next.length;
                this._measuredCellsCount += 1;
            }
            this._averageCellLength = this._measuredCellsLength / this._measuredCellsCount;
            this._cellMetrics.set(cellKey, next);
            this._highestMeasuredCellIndex = Math.max(this._highestMeasuredCellIndex, cellIndex);
            return true;
        } else {
            curr.isMounted = true;
            return false;
        }
    };
    /**
   * Notify ListMetricsAggregator that a cell has been unmounted.
   */ _proto.notifyCellUnmounted = function notifyCellUnmounted(cellKey) {
        var curr = this._cellMetrics.get(cellKey);
        if (curr) {
            curr.isMounted = false;
        }
    };
    /**
   * Notify ListMetricsAggregator that the lists content container has been laid out.
   */ _proto.notifyListContentLayout = function notifyListContentLayout(param) {
        var orientation = param.orientation, layout = param.layout;
        this._invalidateIfOrientationChanged(orientation);
        this._contentLength = this._selectLength(layout);
    };
    /**
   * Return the average length of the cells which have been measured
   */ _proto.getAverageCellLength = function getAverageCellLength() {
        return this._averageCellLength;
    };
    /**
   * Return the highest measured cell index (or 0 if nothing has been measured
   * yet)
   */ _proto.getHighestMeasuredCellIndex = function getHighestMeasuredCellIndex() {
        return this._highestMeasuredCellIndex;
    };
    /**
   * Returns the exact metrics of a cell if it has already been laid out,
   * otherwise an estimate based on the average length of previously measured
   * cells
   */ _proto.getCellMetricsApprox = function getCellMetricsApprox(index, props) {
        var frame = this.getCellMetrics(index, props);
        if (frame && frame.index === index) {
            // check for invalid frames due to row re-ordering
            return frame;
        } else {
            var data = props.data, getItemCount = props.getItemCount;
            (0, _invariant.default)(index >= 0 && index < getItemCount(data), 'Tried to get frame for out of range index ' + index);
            return {
                length: this._averageCellLength,
                offset: this._averageCellLength * index,
                index: index,
                isMounted: false
            };
        }
    };
    /**
   * Returns the exact metrics of a cell if it has already been laid out
   */ _proto.getCellMetrics = function getCellMetrics(index, props) {
        var data = props.data, getItem = props.getItem, getItemCount = props.getItemCount, getItemLayout = props.getItemLayout;
        (0, _invariant.default)(index >= 0 && index < getItemCount(data), 'Tried to get metrics for out of range cell index ' + index);
        var _props_keyExtractor;
        var keyExtractor = (_props_keyExtractor = props.keyExtractor) != null ? _props_keyExtractor : _VirtualizeUtils.keyExtractor;
        var frame = this._cellMetrics.get(keyExtractor(getItem(data, index), index));
        if (frame && frame.index === index) {
            return frame;
        }
        if (getItemLayout) {
            var _getItemLayout = getItemLayout(data, index), length = _getItemLayout.length, offset = _getItemLayout.offset;
            // TODO: `isMounted` is used for both "is exact layout" and "has been
            // unmounted". Should be refactored.
            return {
                index: index,
                length: length,
                offset: offset,
                isMounted: true
            };
        }
        return null;
    };
    /**
   * Gets an approximate offset to an item at a given index. Supports
   * fractional indices.
   */ _proto.getCellOffsetApprox = function getCellOffsetApprox(index, props) {
        if (Number.isInteger(index)) {
            return this.getCellMetricsApprox(index, props).offset;
        } else {
            var frameMetrics = this.getCellMetricsApprox(Math.floor(index), props);
            var remainder = index - Math.floor(index);
            return frameMetrics.offset + remainder * frameMetrics.length;
        }
    };
    /**
   * Returns the length of all ScrollView content along the scrolling axis.
   */ _proto.getContentLength = function getContentLength() {
        var _this__contentLength;
        return (_this__contentLength = this._contentLength) != null ? _this__contentLength : 0;
    };
    /**
   * Whether a content length has been observed
   */ _proto.hasContentLength = function hasContentLength() {
        return this._contentLength != null;
    };
    /**
   * Finds the flow-relative offset (e.g. starting from the left in LTR, but
   * right in RTL) from a layout box.
   */ _proto.flowRelativeOffset = function flowRelativeOffset(layout, referenceContentLength) {
        var _this__orientation = this._orientation, horizontal = _this__orientation.horizontal, rtl = _this__orientation.rtl;
        if (horizontal && rtl) {
            var contentLength = referenceContentLength != null ? referenceContentLength : this._contentLength;
            (0, _invariant.default)(contentLength != null, 'ListMetricsAggregator must be notified of list content layout before resolving offsets');
            return contentLength - (this._selectOffset(layout) + this._selectLength(layout));
        } else {
            return this._selectOffset(layout);
        }
    };
    /**
   * Converts a flow-relative offset to a cartesian offset
   */ _proto.cartesianOffset = function cartesianOffset(flowRelativeOffset) {
        var _this__orientation = this._orientation, horizontal = _this__orientation.horizontal, rtl = _this__orientation.rtl;
        if (horizontal && rtl) {
            (0, _invariant.default)(this._contentLength != null, 'ListMetricsAggregator must be notified of list content layout before resolving offsets');
            return this._contentLength - flowRelativeOffset;
        } else {
            return flowRelativeOffset;
        }
    };
    _proto._invalidateIfOrientationChanged = function _invalidateIfOrientationChanged(orientation) {
        if (orientation.rtl !== this._orientation.rtl) {
            this._cellMetrics.clear();
        }
        if (orientation.horizontal !== this._orientation.horizontal) {
            this._averageCellLength = 0;
            this._highestMeasuredCellIndex = 0;
            this._measuredCellsLength = 0;
            this._measuredCellsCount = 0;
        }
        this._orientation = orientation;
    };
    _proto._selectLength = function _selectLength(param) {
        var width = param.width, height = param.height;
        return this._orientation.horizontal ? width : height;
    };
    _proto._selectOffset = function _selectOffset(param) {
        var x = param.x, y = param.y;
        return this._orientation.horizontal ? x : y;
    };
    return ListMetricsAggregator;
}();


}),
44327: (function (module, __unused_webpack_exports, __webpack_require__) {
"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @format
 *       strict-local
 */ 
var InteractionManager = (__webpack_require__(64598)/* .InteractionManager */.InteractionManager);
/**
 * A simple class for batching up invocations of a low-pri callback. A timeout is set to run the
 * callback once after a delay, no matter how many times it's scheduled. Once the delay is reached,
 * InteractionManager.runAfterInteractions is used to invoke the callback after any hi-pri
 * interactions are done running.
 *
 * Make sure to cleanup with dispose().  Example:
 *
 *   class Widget extends React.Component {
 *     _batchedSave: new Batchinator(() => this._saveState, 1000);
 *     _saveSate() {
 *       // save this.state to disk
 *     }
 *     componentDidUpdate() {
 *       this._batchedSave.schedule();
 *     }
 *     componentWillUnmount() {
 *       this._batchedSave.dispose();
 *     }
 *     ...
 *   }
 */ var Batchinator = /*#__PURE__*/ function() {
    function Batchinator(callback, delayMS) {
        this._delay = delayMS;
        this._callback = callback;
    }
    var _proto = Batchinator.prototype;
    /*
   * Cleanup any pending tasks.
   *
   * By default, if there is a pending task the callback is run immediately. Set the option abort to
   * true to not call the callback if it was pending.
   */ _proto.dispose = function dispose(options) {
        if (options === void 0) options = {
            abort: false
        };
        if (this._taskHandle) {
            this._taskHandle.cancel();
            if (!options.abort) {
                this._callback();
            }
            this._taskHandle = null;
        }
    };
    _proto.schedule = function schedule() {
        var _this = this;
        if (this._taskHandle) {
            return;
        }
        var timeoutHandle = setTimeout(function() {
            _this._taskHandle = InteractionManager.runAfterInteractions(function() {
                // Note that we clear the handle before invoking the callback so that if the callback calls
                // schedule again, it will actually schedule another task.
                _this._taskHandle = null;
                _this._callback();
            });
        }, this._delay);
        this._taskHandle = {
            cancel: function() {
                return clearTimeout(timeoutHandle);
            }
        };
    };
    return Batchinator;
}();
module.exports = Batchinator;


}),
44902: (function (module, exports, __webpack_require__) {
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *      
 * @format
 */ Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _define_property = __webpack_require__(5303);
var _extends = __webpack_require__(87383);
var _inherits = __webpack_require__(85428);
var _interop_require_default = __webpack_require__(48810);
var _interop_require_wildcard = __webpack_require__(38504);
var _object_without_properties_loose = __webpack_require__(35684);
var _to_consumable_array = __webpack_require__(8034);
var _Batchinator = /*#__PURE__*/ _interop_require_default._(__webpack_require__(44327));
var _clamp = /*#__PURE__*/ _interop_require_default._(__webpack_require__(20342));
var _infoLog = /*#__PURE__*/ _interop_require_default._(__webpack_require__(72169));
var _CellRenderMask = __webpack_require__(43332);
var _ChildListCollection = /*#__PURE__*/ _interop_require_default._(__webpack_require__(51632));
var _FillRateHelper = /*#__PURE__*/ _interop_require_default._(__webpack_require__(39966));
var _ListMetricsAggregator = /*#__PURE__*/ _interop_require_default._(__webpack_require__(43967));
var _StateSafePureComponent = /*#__PURE__*/ _interop_require_default._(__webpack_require__(71121));
var _ViewabilityHelper = /*#__PURE__*/ _interop_require_default._(__webpack_require__(60309));
var _VirtualizedListCellRenderer = /*#__PURE__*/ _interop_require_default._(__webpack_require__(24624));
var _VirtualizedListContext = __webpack_require__(36021);
var _VirtualizedListProps = __webpack_require__(54586);
var _VirtualizeUtils = __webpack_require__(31606);
var _invariant = /*#__PURE__*/ _interop_require_default._(__webpack_require__(27761));
var _nullthrows = /*#__PURE__*/ _interop_require_default._(__webpack_require__(89169));
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(41845));
var _reactnative = __webpack_require__(64598);
var ON_EDGE_REACHED_EPSILON = 0.001;
var _usedIndexForKey = false;
var _keylessItemComponentName = '';
function getScrollingThreshold(threshold, visibleLength) {
    return threshold * visibleLength / 2;
}
/**
 * Base implementation for the more convenient [`<FlatList>`](https://reactnative.dev/docs/flatlist)
 * and [`<SectionList>`](https://reactnative.dev/docs/sectionlist) components, which are also better
 * documented. In general, this should only really be used if you need more flexibility than
 * `FlatList` provides, e.g. for use with immutable data instead of plain arrays.
 *
 * Virtualization massively improves memory consumption and performance of large lists by
 * maintaining a finite render window of active items and replacing all items outside of the render
 * window with appropriately sized blank space. The window adapts to scrolling behavior, and items
 * are rendered incrementally with low-pri (after any running interactions) if they are far from the
 * visible area, or with hi-pri otherwise to minimize the potential of seeing blank space.
 *
 * Some caveats:
 *
 * - Internal state is not preserved when content scrolls out of the render window. Make sure all
 *   your data is captured in the item data or external stores like Flux, Redux, or Relay.
 * - This is a `PureComponent` which means that it will not re-render if `props` remain shallow-
 *   equal. Make sure that everything your `renderItem` function depends on is passed as a prop
 *   (e.g. `extraData`) that is not `===` after updates, otherwise your UI may not update on
 *   changes. This includes the `data` prop and parent component state.
 * - In order to constrain memory and enable smooth scrolling, content is rendered asynchronously
 *   offscreen. This means it's possible to scroll faster than the fill rate ands momentarily see
 *   blank content. This is a tradeoff that can be adjusted to suit the needs of each application,
 *   and we are working on improving it behind the scenes.
 * - By default, the list looks for a `key` or `id` prop on each item and uses that for the React key.
 *   Alternatively, you can provide a custom `keyExtractor` prop.
 * - As an effort to remove defaultProps, use helper functions when referencing certain props
 *
 */ var VirtualizedList = /*#__PURE__*/ function(StateSafePureComponent) {
    "use strict";
    _inherits._(VirtualizedList, StateSafePureComponent);
    function VirtualizedList(props) {
        var _this;
        var _this_props_maintainVisibleContentPosition;
        _this = StateSafePureComponent.call(this, props) || this, // $FlowFixMe[missing-local-annot]
        _this._getScrollMetrics = function() {
            return _this._scrollMetrics;
        }, // $FlowFixMe[missing-local-annot]
        _this._getOutermostParentListRef = function() {
            if (_this._isNestedWithSameOrientation()) {
                return _this.context.getOutermostParentListRef();
            } else {
                return _this;
            }
        }, _this._registerAsNestedChild = function(childList) {
            _this._nestedChildLists.add(childList.ref, childList.cellKey);
            if (_this._hasInteracted) {
                childList.ref.recordInteraction();
            }
        }, _this._unregisterAsNestedChild = function(childList) {
            _this._nestedChildLists.remove(childList.ref);
        }, _this._onUpdateSeparators = function(keys, newProps) {
            keys.forEach(function(key) {
                var ref = key != null && _this._cellRefs[key];
                ref && ref.updateSeparatorProps(newProps);
            });
        }, _this._getSpacerKey = function(isVertical) {
            return isVertical ? 'height' : 'width';
        }, _this._cellRefs = {}, _this._listMetrics = new _ListMetricsAggregator.default(), _this._footerLength = 0, // Used for preventing scrollToIndex from being called multiple times for initialScrollIndex
        _this._hasTriggeredInitialScrollToIndex = false, _this._hasInteracted = false, _this._hasMore = false, _this._hasWarned = {}, _this._headerLength = 0, _this._hiPriInProgress = false // flag to prevent infinite hiPri cell limit update
        , _this._indicesToKeys = new Map(), _this._lastFocusedCellKey = null, _this._nestedChildLists = new _ChildListCollection.default(), _this._offsetFromParentVirtualizedList = 0, _this._pendingViewabilityUpdate = false, _this._prevParentOffset = 0, _this._scrollMetrics = {
            dOffset: 0,
            dt: 10,
            offset: 0,
            timestamp: 0,
            velocity: 0,
            visibleLength: 0,
            zoomScale: 1
        }, _this._scrollRef = null, _this._sentStartForContentLength = 0, _this._sentEndForContentLength = 0, _this._viewabilityTuples = [], /* $FlowFixMe[missing-local-annot] The type annotation(s) required by Flow's
   * LTI update could not be added via codemod */ _this._captureScrollRef = function(ref) {
            _this._scrollRef = ref;
        }, /* $FlowFixMe[missing-local-annot] The type annotation(s) required by Flow's
   * LTI update could not be added via codemod */ _this._defaultRenderScrollComponent = function(props) {
            var onRefresh = props.onRefresh;
            if (_this._isNestedWithSameOrientation()) {
                // Prevent VirtualizedList._onContentSizeChange from being triggered by a bubbling onContentSizeChange event.
                // This could lead to internal inconsistencies within VirtualizedList.
                var onContentSizeChange = props.onContentSizeChange, otherProps = _object_without_properties_loose._(props, [
                    "onContentSizeChange"
                ]);
                return /*#__PURE__*/ _react.createElement(_reactnative.View, otherProps);
            } else if (onRefresh) {
                var _props_refreshing;
                (0, _invariant.default)(typeof props.refreshing === 'boolean', '`refreshing` prop must be set as a boolean in order to use `onRefresh`, but got `' + JSON.stringify((_props_refreshing = props.refreshing) != null ? _props_refreshing : 'undefined') + '`');
                return(// $FlowFixMe[prop-missing] Invalid prop usage
                // $FlowFixMe[incompatible-use]
                /*#__PURE__*/ _react.createElement(_reactnative.ScrollView, _extends._({}, props, {
                    refreshControl: props.refreshControl == null ? /*#__PURE__*/ _react.createElement(_reactnative.RefreshControl, {
                        // $FlowFixMe[incompatible-type]
                        refreshing: props.refreshing,
                        onRefresh: onRefresh,
                        progressViewOffset: props.progressViewOffset
                    }) : props.refreshControl
                })));
            } else {
                // $FlowFixMe[prop-missing] Invalid prop usage
                // $FlowFixMe[incompatible-use]
                return /*#__PURE__*/ _react.createElement(_reactnative.ScrollView, props);
            }
        }, _this._onCellLayout = function(e, cellKey, cellIndex) {
            var layoutHasChanged = _this._listMetrics.notifyCellLayout({
                cellIndex: cellIndex,
                cellKey: cellKey,
                layout: e.nativeEvent.layout,
                orientation: _this._orientation()
            });
            if (layoutHasChanged) {
                _this._scheduleCellsToRenderUpdate();
            }
            _this._triggerRemeasureForChildListsInCell(cellKey);
            _this._computeBlankness();
            _this._updateViewableItems(_this.props, _this.state.cellsAroundViewport);
        }, _this._onCellFocusCapture = function(cellKey) {
            _this._lastFocusedCellKey = cellKey;
            _this._updateCellsToRender();
        }, _this._onCellUnmount = function(cellKey) {
            delete _this._cellRefs[cellKey];
            _this._listMetrics.notifyCellUnmounted(cellKey);
        }, _this._onLayout = function(e) {
            if (_this._isNestedWithSameOrientation()) {
                // Need to adjust our scroll metrics to be relative to our containing
                // VirtualizedList before we can make claims about list item viewability
                _this.measureLayoutRelativeToContainingList();
            } else {
                _this._scrollMetrics.visibleLength = _this._selectLength(e.nativeEvent.layout);
            }
            _this.props.onLayout && _this.props.onLayout(e);
            _this._scheduleCellsToRenderUpdate();
            _this._maybeCallOnEdgeReached();
        }, _this._onLayoutEmpty = function(e) {
            _this.props.onLayout && _this.props.onLayout(e);
        }, _this._onLayoutFooter = function(e) {
            _this._triggerRemeasureForChildListsInCell(_this._getFooterCellKey());
            _this._footerLength = _this._selectLength(e.nativeEvent.layout);
        }, _this._onLayoutHeader = function(e) {
            _this._headerLength = _this._selectLength(e.nativeEvent.layout);
        }, _this._onContentSizeChange = function(width, height) {
            _this._listMetrics.notifyListContentLayout({
                layout: {
                    width: width,
                    height: height
                },
                orientation: _this._orientation()
            });
            _this._maybeScrollToInitialScrollIndex(width, height);
            if (_this.props.onContentSizeChange) {
                _this.props.onContentSizeChange(width, height);
            }
            _this._scheduleCellsToRenderUpdate();
            _this._maybeCallOnEdgeReached();
        }, /* Translates metrics from a scroll event in a parent VirtualizedList into
   * coordinates relative to the child list.
   */ _this._convertParentScrollMetrics = function(metrics) {
            // Offset of the top of the nested list relative to the top of its parent's viewport
            var offset = metrics.offset - _this._offsetFromParentVirtualizedList;
            // Child's visible length is the same as its parent's
            var visibleLength = metrics.visibleLength;
            var dOffset = offset - _this._scrollMetrics.offset;
            var contentLength = _this._listMetrics.getContentLength();
            return {
                visibleLength: visibleLength,
                contentLength: contentLength,
                offset: offset,
                dOffset: dOffset
            };
        }, _this._onScroll = function(e) {
            _this._nestedChildLists.forEach(function(childList) {
                childList._onScroll(e);
            });
            if (_this.props.onScroll) {
                _this.props.onScroll(e);
            }
            var timestamp = e.timeStamp;
            var visibleLength = _this._selectLength(e.nativeEvent.layoutMeasurement);
            var contentLength = _this._selectLength(e.nativeEvent.contentSize);
            var offset = _this._offsetFromScrollEvent(e);
            var dOffset = offset - _this._scrollMetrics.offset;
            if (_this._isNestedWithSameOrientation()) {
                if (_this._listMetrics.getContentLength() === 0) {
                    // Ignore scroll events until onLayout has been called and we
                    // know our offset from our offset from our parent
                    return;
                }
                var ref;
                ref = _this._convertParentScrollMetrics({
                    visibleLength: visibleLength,
                    offset: offset
                }), visibleLength = ref.visibleLength, contentLength = ref.contentLength, offset = ref.offset, dOffset = ref.dOffset, ref;
            }
            var dt = _this._scrollMetrics.timestamp ? Math.max(1, timestamp - _this._scrollMetrics.timestamp) : 1;
            var velocity = dOffset / dt;
            if (dt > 500 && _this._scrollMetrics.dt > 500 && contentLength > 5 * visibleLength && !_this._hasWarned.perf) {
                (0, _infoLog.default)('VirtualizedList: You have a large list that is slow to update - make sure your ' + 'renderItem function renders components that follow React performance best practices ' + 'like PureComponent, shouldComponentUpdate, etc.', {
                    dt: dt,
                    prevDt: _this._scrollMetrics.dt,
                    contentLength: contentLength
                });
                _this._hasWarned.perf = true;
            }
            // For invalid negative values (w/ RTL), set this to 1.
            var zoomScale = e.nativeEvent.zoomScale < 0 ? 1 : e.nativeEvent.zoomScale;
            _this._scrollMetrics = {
                dt: dt,
                dOffset: dOffset,
                offset: offset,
                timestamp: timestamp,
                velocity: velocity,
                visibleLength: visibleLength,
                zoomScale: zoomScale
            };
            if (_this.state.pendingScrollUpdateCount > 0) {
                _this.setState(function(state) {
                    return {
                        pendingScrollUpdateCount: state.pendingScrollUpdateCount - 1
                    };
                });
            }
            _this._updateViewableItems(_this.props, _this.state.cellsAroundViewport);
            if (!_this.props) {
                return;
            }
            _this._maybeCallOnEdgeReached();
            if (velocity !== 0) {
                _this._fillRateHelper.activate();
            }
            _this._computeBlankness();
            _this._scheduleCellsToRenderUpdate();
        }, _this._onScrollBeginDrag = function(e) {
            _this._nestedChildLists.forEach(function(childList) {
                childList._onScrollBeginDrag(e);
            });
            _this._viewabilityTuples.forEach(function(tuple) {
                tuple.viewabilityHelper.recordInteraction();
            });
            _this._hasInteracted = true;
            _this.props.onScrollBeginDrag && _this.props.onScrollBeginDrag(e);
        }, _this._onScrollEndDrag = function(e) {
            _this._nestedChildLists.forEach(function(childList) {
                childList._onScrollEndDrag(e);
            });
            var velocity = e.nativeEvent.velocity;
            if (velocity) {
                _this._scrollMetrics.velocity = _this._selectOffset(velocity);
            }
            _this._computeBlankness();
            _this.props.onScrollEndDrag && _this.props.onScrollEndDrag(e);
        }, _this._onMomentumScrollBegin = function(e) {
            _this._nestedChildLists.forEach(function(childList) {
                childList._onMomentumScrollBegin(e);
            });
            _this.props.onMomentumScrollBegin && _this.props.onMomentumScrollBegin(e);
        }, _this._onMomentumScrollEnd = function(e) {
            _this._nestedChildLists.forEach(function(childList) {
                childList._onMomentumScrollEnd(e);
            });
            _this._scrollMetrics.velocity = 0;
            _this._computeBlankness();
            _this.props.onMomentumScrollEnd && _this.props.onMomentumScrollEnd(e);
        }, _this._updateCellsToRender = function() {
            _this._updateViewableItems(_this.props, _this.state.cellsAroundViewport);
            _this.setState(function(state, props) {
                var cellsAroundViewport = _this._adjustCellsAroundViewport(props, state.cellsAroundViewport, state.pendingScrollUpdateCount);
                var renderMask = VirtualizedList._createRenderMask(props, cellsAroundViewport, _this._getNonViewportRenderRegions(props));
                if (cellsAroundViewport.first === state.cellsAroundViewport.first && cellsAroundViewport.last === state.cellsAroundViewport.last && renderMask.equals(state.renderMask)) {
                    return null;
                }
                return {
                    cellsAroundViewport: cellsAroundViewport,
                    renderMask: renderMask
                };
            });
        }, _this._createViewToken = function(index, isViewable, props) {
            var data = props.data, getItem = props.getItem;
            var item = getItem(data, index);
            return {
                index: index,
                item: item,
                key: VirtualizedList._keyExtractor(item, index, props),
                isViewable: isViewable
            };
        }, _this._getNonViewportRenderRegions = function(props) {
            // Keep a viewport's worth of content around the last focused cell to allow
            // random navigation around it without any blanking. E.g. tabbing from one
            // focused item out of viewport to another.
            if (!(_this._lastFocusedCellKey && _this._cellRefs[_this._lastFocusedCellKey])) {
                return [];
            }
            var lastFocusedCellRenderer = _this._cellRefs[_this._lastFocusedCellKey];
            var focusedCellIndex = lastFocusedCellRenderer.props.index;
            var itemCount = props.getItemCount(props.data);
            // The last cell we rendered may be at a new index. Bail if we don't know
            // where it is.
            if (focusedCellIndex >= itemCount || VirtualizedList._getItemKey(props, focusedCellIndex) !== _this._lastFocusedCellKey) {
                return [];
            }
            var first = focusedCellIndex;
            var heightOfCellsBeforeFocused = 0;
            for(var i = first - 1; i >= 0 && heightOfCellsBeforeFocused < _this._scrollMetrics.visibleLength; i--){
                first--;
                heightOfCellsBeforeFocused += _this._listMetrics.getCellMetricsApprox(i, props).length;
            }
            var last = focusedCellIndex;
            var heightOfCellsAfterFocused = 0;
            for(var i1 = last + 1; i1 < itemCount && heightOfCellsAfterFocused < _this._scrollMetrics.visibleLength; i1++){
                last++;
                heightOfCellsAfterFocused += _this._listMetrics.getCellMetricsApprox(i1, props).length;
            }
            return [
                {
                    first: first,
                    last: last
                }
            ];
        };
        _this._checkProps(props);
        _this._fillRateHelper = new _FillRateHelper.default(_this._listMetrics);
        var _this_props_updateCellsBatchingPeriod;
        _this._updateCellsToRenderBatcher = new _Batchinator.default(_this._updateCellsToRender, (_this_props_updateCellsBatchingPeriod = _this.props.updateCellsBatchingPeriod) != null ? _this_props_updateCellsBatchingPeriod : 50);
        if (_this.props.viewabilityConfigCallbackPairs) {
            _this._viewabilityTuples = _this.props.viewabilityConfigCallbackPairs.map(function(pair) {
                return {
                    viewabilityHelper: new _ViewabilityHelper.default(pair.viewabilityConfig),
                    onViewableItemsChanged: pair.onViewableItemsChanged
                };
            });
        } else {
            var _this_props = _this.props, onViewableItemsChanged = _this_props.onViewableItemsChanged, viewabilityConfig = _this_props.viewabilityConfig;
            if (onViewableItemsChanged) {
                _this._viewabilityTuples.push({
                    viewabilityHelper: new _ViewabilityHelper.default(viewabilityConfig),
                    onViewableItemsChanged: onViewableItemsChanged
                });
            }
        }
        var initialRenderRegion = VirtualizedList._initialRenderRegion(props);
        var _this_props_maintainVisibleContentPosition_minIndexForVisible;
        var minIndexForVisible = (_this_props_maintainVisibleContentPosition_minIndexForVisible = (_this_props_maintainVisibleContentPosition = _this.props.maintainVisibleContentPosition) == null ? void 0 : _this_props_maintainVisibleContentPosition.minIndexForVisible) != null ? _this_props_maintainVisibleContentPosition_minIndexForVisible : 0;
        _this.state = {
            cellsAroundViewport: initialRenderRegion,
            renderMask: VirtualizedList._createRenderMask(props, initialRenderRegion),
            firstVisibleItemKey: _this.props.getItemCount(_this.props.data) > minIndexForVisible ? VirtualizedList._getItemKey(_this.props, minIndexForVisible) : null,
            // When we have a non-zero initialScrollIndex, we will receive a
            // scroll event later so this will prevent the window from updating
            // until we get a valid offset.
            pendingScrollUpdateCount: _this.props.initialScrollIndex != null && _this.props.initialScrollIndex > 0 ? 1 : 0
        };
        return _this;
    }
    var _proto = VirtualizedList.prototype;
    // scrollToEnd may be janky without getItemLayout prop
    _proto.scrollToEnd = function scrollToEnd(params) {
        var animated = params ? params.animated : true;
        var veryLast = this.props.getItemCount(this.props.data) - 1;
        if (veryLast < 0) {
            return;
        }
        var frame = this._listMetrics.getCellMetricsApprox(veryLast, this.props);
        var offset = Math.max(0, frame.offset + frame.length + this._footerLength - this._scrollMetrics.visibleLength);
        // TODO: consider using `ref.scrollToEnd` directly
        this.scrollToOffset({
            animated: animated,
            offset: offset
        });
    };
    // scrollToIndex may be janky without getItemLayout prop
    _proto.scrollToIndex = function scrollToIndex(params) {
        var _this_props = this.props, data = _this_props.data, getItemCount = _this_props.getItemCount, getItemLayout = _this_props.getItemLayout, onScrollToIndexFailed = _this_props.onScrollToIndexFailed;
        var animated = params.animated, index = params.index, viewOffset = params.viewOffset, viewPosition = params.viewPosition;
        (0, _invariant.default)(index >= 0, "scrollToIndex out of range: requested index " + index + " but minimum is 0");
        (0, _invariant.default)(getItemCount(data) >= 1, "scrollToIndex out of range: item length " + getItemCount(data) + " but minimum is 1");
        (0, _invariant.default)(index < getItemCount(data), "scrollToIndex out of range: requested index " + index + " is out of 0 to " + (getItemCount(data) - 1));
        if (!getItemLayout && index > this._listMetrics.getHighestMeasuredCellIndex()) {
            (0, _invariant.default)(!!onScrollToIndexFailed, 'scrollToIndex should be used in conjunction with getItemLayout or onScrollToIndexFailed, ' + 'otherwise there is no way to know the location of offscreen indices or handle failures.');
            onScrollToIndexFailed({
                averageItemLength: this._listMetrics.getAverageCellLength(),
                highestMeasuredFrameIndex: this._listMetrics.getHighestMeasuredCellIndex(),
                index: index
            });
            return;
        }
        var frame = this._listMetrics.getCellMetricsApprox(Math.floor(index), this.props);
        var offset = Math.max(0, this._listMetrics.getCellOffsetApprox(index, this.props) - (viewPosition || 0) * (this._scrollMetrics.visibleLength - frame.length)) - (viewOffset || 0);
        this.scrollToOffset({
            offset: offset,
            animated: animated
        });
    };
    // scrollToItem may be janky without getItemLayout prop. Required linear scan through items -
    // use scrollToIndex instead if possible.
    _proto.scrollToItem = function scrollToItem(params) {
        var item = params.item;
        var _this_props = this.props, data = _this_props.data, getItem = _this_props.getItem, getItemCount = _this_props.getItemCount;
        var itemCount = getItemCount(data);
        for(var index = 0; index < itemCount; index++){
            if (getItem(data, index) === item) {
                this.scrollToIndex(_extends._({}, params, {
                    index: index
                }));
                break;
            }
        }
    };
    /**
   * Scroll to a specific content pixel offset in the list.
   *
   * Param `offset` expects the offset to scroll to.
   * In case of `horizontal` is true, the offset is the x-value,
   * in any other case the offset is the y-value.
   *
   * Param `animated` (`true` by default) defines whether the list
   * should do an animation while scrolling.
   */ _proto.scrollToOffset = function scrollToOffset(params) {
        var animated = params.animated, offset = params.offset;
        var scrollRef = this._scrollRef;
        if (scrollRef == null) {
            return;
        }
        if (scrollRef.scrollTo == null) {
            console.warn('No scrollTo method provided. This may be because you have two nested ' + 'VirtualizedLists with the same orientation, or because you are ' + 'using a custom component that does not implement scrollTo.');
            return;
        }
        var _this__orientation = this._orientation(), horizontal = _this__orientation.horizontal, rtl = _this__orientation.rtl;
        if (horizontal && rtl && !this._listMetrics.hasContentLength()) {
            console.warn('scrollToOffset may not be called in RTL before content is laid out');
            return;
        }
        scrollRef.scrollTo(_extends._({
            animated: animated
        }, this._scrollToParamsFromOffset(offset)));
    };
    _proto._scrollToParamsFromOffset = function _scrollToParamsFromOffset(offset) {
        var _this__orientation = this._orientation(), horizontal = _this__orientation.horizontal, rtl = _this__orientation.rtl;
        if (horizontal && rtl) {
            // Add the visible length of the scrollview so that the offset is right-aligned
            var cartOffset = this._listMetrics.cartesianOffset(offset + this._scrollMetrics.visibleLength);
            return horizontal ? {
                x: cartOffset
            } : {
                y: cartOffset
            };
        } else {
            return horizontal ? {
                x: offset
            } : {
                y: offset
            };
        }
    };
    _proto.recordInteraction = function recordInteraction() {
        this._nestedChildLists.forEach(function(childList) {
            childList.recordInteraction();
        });
        this._viewabilityTuples.forEach(function(t) {
            t.viewabilityHelper.recordInteraction();
        });
        this._updateViewableItems(this.props, this.state.cellsAroundViewport);
    };
    _proto.flashScrollIndicators = function flashScrollIndicators() {
        if (this._scrollRef == null) {
            return;
        }
        this._scrollRef.flashScrollIndicators();
    };
    /**
   * Provides a handle to the underlying scroll responder.
   * Note that `this._scrollRef` might not be a `ScrollView`, so we
   * need to check that it responds to `getScrollResponder` before calling it.
   */ _proto.getScrollResponder = function getScrollResponder() {
        if (this._scrollRef && this._scrollRef.getScrollResponder) {
            return this._scrollRef.getScrollResponder();
        }
    };
    _proto.getScrollableNode = function getScrollableNode() {
        if (this._scrollRef && this._scrollRef.getScrollableNode) {
            return this._scrollRef.getScrollableNode();
        } else {
            return (0, _reactnative.findNodeHandle)(this._scrollRef);
        }
    };
    _proto.getScrollRef = function getScrollRef() {
        if (this._scrollRef && this._scrollRef.getScrollRef) {
            return this._scrollRef.getScrollRef();
        } else {
            return this._scrollRef;
        }
    };
    _proto.setNativeProps = function setNativeProps(props) {
        if (this._scrollRef) {
            this._scrollRef.setNativeProps(props);
        }
    };
    _proto._getCellKey = function _getCellKey() {
        var _this_context;
        return ((_this_context = this.context) == null ? void 0 : _this_context.cellKey) || 'rootList';
    };
    _proto.hasMore = function hasMore() {
        return this._hasMore;
    };
    _proto._checkProps = function _checkProps(props) {
        var onScroll = props.onScroll, windowSize = props.windowSize, getItemCount = props.getItemCount, data = props.data, initialScrollIndex = props.initialScrollIndex;
        (0, _invariant.default)(// $FlowFixMe[prop-missing]
        !onScroll || !onScroll.__isNative, 'Components based on VirtualizedList must be wrapped with Animated.createAnimatedComponent ' + 'to support native onScroll events with useNativeDriver');
        (0, _invariant.default)((0, _VirtualizedListProps.windowSizeOrDefault)(windowSize) > 0, 'VirtualizedList: The windowSize prop must be present and set to a value greater than 0.');
        (0, _invariant.default)(getItemCount, 'VirtualizedList: The "getItemCount" prop must be provided');
        var itemCount = getItemCount(data);
        if (initialScrollIndex != null && !this._hasTriggeredInitialScrollToIndex && (initialScrollIndex < 0 || itemCount > 0 && initialScrollIndex >= itemCount) && !this._hasWarned.initialScrollIndex) {
            console.warn('initialScrollIndex "' + initialScrollIndex + '" is not valid (list has ' + itemCount + " items)");
            this._hasWarned.initialScrollIndex = true;
        }
        if (false) { var flatStyles }
    };
    _proto._adjustCellsAroundViewport = function _adjustCellsAroundViewport(props, cellsAroundViewport, pendingScrollUpdateCount) {
        var data = props.data, getItemCount = props.getItemCount;
        var onEndReachedThreshold = (0, _VirtualizedListProps.onEndReachedThresholdOrDefault)(props.onEndReachedThreshold);
        var _this__scrollMetrics = this._scrollMetrics, offset = _this__scrollMetrics.offset, visibleLength = _this__scrollMetrics.visibleLength;
        var contentLength = this._listMetrics.getContentLength();
        var distanceFromEnd = contentLength - visibleLength - offset;
        // Wait until the scroll view metrics have been set up. And until then,
        // we will trust the initialNumToRender suggestion
        if (visibleLength <= 0 || contentLength <= 0) {
            return cellsAroundViewport.last >= getItemCount(data) ? VirtualizedList._constrainToItemCount(cellsAroundViewport, props) : cellsAroundViewport;
        }
        var newCellsAroundViewport;
        if (props.disableVirtualization) {
            var renderAhead = distanceFromEnd < onEndReachedThreshold * visibleLength ? (0, _VirtualizedListProps.maxToRenderPerBatchOrDefault)(props.maxToRenderPerBatch) : 0;
            newCellsAroundViewport = {
                first: 0,
                last: Math.min(cellsAroundViewport.last + renderAhead, getItemCount(data) - 1)
            };
        } else {
            // If we have a pending scroll update, we should not adjust the render window as it
            // might override the correct window.
            if (pendingScrollUpdateCount > 0) {
                return cellsAroundViewport.last >= getItemCount(data) ? VirtualizedList._constrainToItemCount(cellsAroundViewport, props) : cellsAroundViewport;
            }
            newCellsAroundViewport = (0, _VirtualizeUtils.computeWindowedRenderLimits)(props, (0, _VirtualizedListProps.maxToRenderPerBatchOrDefault)(props.maxToRenderPerBatch), (0, _VirtualizedListProps.windowSizeOrDefault)(props.windowSize), cellsAroundViewport, this._listMetrics, this._scrollMetrics);
            (0, _invariant.default)(newCellsAroundViewport.last < getItemCount(data), 'computeWindowedRenderLimits() should return range in-bounds');
        }
        if (this._nestedChildLists.size() > 0) {
            // If some cell in the new state has a child list in it, we should only render
            // up through that item, so that we give that list a chance to render.
            // Otherwise there's churn from multiple child lists mounting and un-mounting
            // their items.
            // Will this prevent rendering if the nested list doesn't realize the end?
            var childIdx = this._findFirstChildWithMore(newCellsAroundViewport.first, newCellsAroundViewport.last);
            newCellsAroundViewport.last = childIdx != null ? childIdx : newCellsAroundViewport.last;
        }
        return newCellsAroundViewport;
    };
    _proto._findFirstChildWithMore = function _findFirstChildWithMore(first, last) {
        for(var ii = first; ii <= last; ii++){
            var cellKeyForIndex = this._indicesToKeys.get(ii);
            if (cellKeyForIndex != null && this._nestedChildLists.anyInCell(cellKeyForIndex, function(childList) {
                return childList.hasMore();
            })) {
                return ii;
            }
        }
        return null;
    };
    _proto.componentDidMount = function componentDidMount() {
        if (this._isNestedWithSameOrientation()) {
            this.context.registerAsNestedChild({
                ref: this,
                cellKey: this.context.cellKey
            });
        }
    };
    _proto.componentWillUnmount = function componentWillUnmount() {
        if (this._isNestedWithSameOrientation()) {
            this.context.unregisterAsNestedChild({
                ref: this
            });
        }
        this._updateCellsToRenderBatcher.dispose({
            abort: true
        });
        this._viewabilityTuples.forEach(function(tuple) {
            tuple.viewabilityHelper.dispose();
        });
        this._fillRateHelper.deactivateAndFlush();
    };
    _proto._pushCells = function _pushCells(cells, stickyHeaderIndices, stickyIndicesFromProps, first, last, inversionStyle) {
        var _this, _loop = function(ii) {
            var item = getItem(data, ii);
            var key = VirtualizedList._keyExtractor(item, ii, _this.props);
            _this._indicesToKeys.set(ii, key);
            if (stickyIndicesFromProps.has(ii + stickyOffset)) {
                stickyHeaderIndices.push(cells.length);
            }
            var shouldListenForLayout = getItemLayout == null || debug || _this._fillRateHelper.enabled();
            cells.push(/*#__PURE__*/ _react.createElement(_VirtualizedListCellRenderer.default, _extends._({
                CellRendererComponent: CellRendererComponent,
                ItemSeparatorComponent: ii < end ? ItemSeparatorComponent : undefined,
                ListItemComponent: ListItemComponent,
                cellKey: key,
                horizontal: horizontal,
                index: ii,
                inversionStyle: inversionStyle,
                item: item,
                key: key,
                prevCellKey: prevCellKey,
                onUpdateSeparators: _this._onUpdateSeparators,
                onCellFocusCapture: _this._onCellFocusCapture,
                onUnmount: _this._onCellUnmount,
                ref: function(ref) {
                    _this1._cellRefs[key] = ref;
                },
                renderItem: renderItem
            }, shouldListenForLayout && {
                onCellLayout: _this._onCellLayout
            })));
            prevCellKey = key;
        };
        var _this1 = this;
        var _this_props = this.props, CellRendererComponent = _this_props.CellRendererComponent, ItemSeparatorComponent = _this_props.ItemSeparatorComponent, ListHeaderComponent = _this_props.ListHeaderComponent, ListItemComponent = _this_props.ListItemComponent, data = _this_props.data, debug = _this_props.debug, getItem = _this_props.getItem, getItemCount = _this_props.getItemCount, getItemLayout = _this_props.getItemLayout, horizontal = _this_props.horizontal, renderItem = _this_props.renderItem;
        var stickyOffset = ListHeaderComponent ? 1 : 0;
        var end = getItemCount(data) - 1;
        var prevCellKey;
        last = Math.min(end, last);
        for(var ii = first; ii <= last; ii++)_this = this, _loop(ii);
    };
    _proto._isNestedWithSameOrientation = function _isNestedWithSameOrientation() {
        var nestedContext = this.context;
        return !!(nestedContext && !!nestedContext.horizontal === (0, _VirtualizedListProps.horizontalOrDefault)(this.props.horizontal));
    };
    _proto.render = function render() {
        var _this = this;
        this._checkProps(this.props);
        var _this_props = this.props, ListEmptyComponent = _this_props.ListEmptyComponent, ListFooterComponent = _this_props.ListFooterComponent, ListHeaderComponent = _this_props.ListHeaderComponent;
        var _this_props1 = this.props, data = _this_props1.data, horizontal = _this_props1.horizontal;
        var inversionStyle = this.props.inverted ? (0, _VirtualizedListProps.horizontalOrDefault)(this.props.horizontal) ? styles.horizontallyInverted : styles.verticallyInverted : null;
        var cells = [];
        var stickyIndicesFromProps = new Set(this.props.stickyHeaderIndices);
        var stickyHeaderIndices = [];
        // 1. Add cell for ListHeaderComponent
        if (ListHeaderComponent) {
            if (stickyIndicesFromProps.has(0)) {
                stickyHeaderIndices.push(0);
            }
            var element = /*#__PURE__*/ _react.isValidElement(ListHeaderComponent) ? ListHeaderComponent : // $FlowFixMe[not-a-component]
            // $FlowFixMe[incompatible-type-arg]
            /*#__PURE__*/ _react.createElement(ListHeaderComponent, null);
            cells.push(/*#__PURE__*/ _react.createElement(_VirtualizedListContext.VirtualizedListCellContextProvider, {
                cellKey: this._getCellKey() + '-header',
                key: "$header"
            }, /*#__PURE__*/ _react.createElement(_reactnative.View, {
                // We expect that header component will be a single native view so make it
                // not collapsable to avoid this view being flattened and make this assumption
                // no longer true.
                collapsable: false,
                onLayout: this._onLayoutHeader,
                style: _reactnative.StyleSheet.compose(inversionStyle, this.props.ListHeaderComponentStyle)
            }, // $FlowFixMe[incompatible-type] - Typing ReactNativeComponent revealed errors
            element)));
        }
        // 2a. Add a cell for ListEmptyComponent if applicable
        var itemCount = this.props.getItemCount(data);
        if (itemCount === 0 && ListEmptyComponent) {
            var element1 = /*#__PURE__*/ _react.isValidElement(ListEmptyComponent) ? ListEmptyComponent : // $FlowFixMe[not-a-component]
            // $FlowFixMe[incompatible-type-arg]
            /*#__PURE__*/ _react.createElement(ListEmptyComponent, null);
            cells.push(/*#__PURE__*/ _react.createElement(_VirtualizedListContext.VirtualizedListCellContextProvider, {
                cellKey: this._getCellKey() + '-empty',
                key: "$empty"
            }, /*#__PURE__*/ _react.cloneElement(element1, {
                onLayout: function(event) {
                    _this._onLayoutEmpty(event);
                    // $FlowFixMe[prop-missing] React.Element internal inspection
                    if (element1.props.onLayout) {
                        element1.props.onLayout(event);
                    }
                },
                // $FlowFixMe[prop-missing] React.Element internal inspection
                style: _reactnative.StyleSheet.compose(inversionStyle, element1.props.style)
            })));
        }
        // 2b. Add cells and spacers for each item
        if (itemCount > 0) {
            _usedIndexForKey = false;
            _keylessItemComponentName = '';
            var spacerKey = this._getSpacerKey(!horizontal);
            var renderRegions = this.state.renderMask.enumerateRegions();
            var lastRegion = renderRegions[renderRegions.length - 1];
            var lastSpacer = (lastRegion == null ? void 0 : lastRegion.isSpacer) ? lastRegion : null;
            for(var _i = 0; _i < renderRegions.length; _i++){
                var section = renderRegions[_i];
                if (section.isSpacer) {
                    // Legacy behavior is to avoid spacers when virtualization is
                    // disabled (including head spacers on initial render).
                    if (this.props.disableVirtualization) {
                        continue;
                    }
                    // Without getItemLayout, we limit our tail spacer to the _highestMeasuredFrameIndex to
                    // prevent the user for hyperscrolling into un-measured area because otherwise content will
                    // likely jump around as it renders in above the viewport.
                    var isLastSpacer = section === lastSpacer;
                    var constrainToMeasured = isLastSpacer && !this.props.getItemLayout;
                    var last = constrainToMeasured ? (0, _clamp.default)(section.first - 1, section.last, this._listMetrics.getHighestMeasuredCellIndex()) : section.last;
                    var firstMetrics = this._listMetrics.getCellMetricsApprox(section.first, this.props);
                    var lastMetrics = this._listMetrics.getCellMetricsApprox(last, this.props);
                    var spacerSize = lastMetrics.offset + lastMetrics.length - firstMetrics.offset;
                    cells.push(/*#__PURE__*/ _react.createElement(_reactnative.View, {
                        key: "$spacer-" + section.first,
                        style: _define_property._({}, spacerKey, spacerSize)
                    }));
                } else {
                    this._pushCells(cells, stickyHeaderIndices, stickyIndicesFromProps, section.first, section.last, inversionStyle);
                }
            }
            if (!this._hasWarned.keys && _usedIndexForKey) {
                console.warn('VirtualizedList: missing keys for items, make sure to specify a key or id property on each ' + 'item or provide a custom keyExtractor.', _keylessItemComponentName);
                this._hasWarned.keys = true;
            }
        }
        // 3. Add cell for ListFooterComponent
        if (ListFooterComponent) {
            var element2 = /*#__PURE__*/ _react.isValidElement(ListFooterComponent) ? ListFooterComponent : // $FlowFixMe[not-a-component]
            // $FlowFixMe[incompatible-type-arg]
            /*#__PURE__*/ _react.createElement(ListFooterComponent, null);
            cells.push(/*#__PURE__*/ _react.createElement(_VirtualizedListContext.VirtualizedListCellContextProvider, {
                cellKey: this._getFooterCellKey(),
                key: "$footer"
            }, /*#__PURE__*/ _react.createElement(_reactnative.View, {
                onLayout: this._onLayoutFooter,
                style: _reactnative.StyleSheet.compose(inversionStyle, this.props.ListFooterComponentStyle)
            }, // $FlowFixMe[incompatible-type] - Typing ReactNativeComponent revealed errors
            element2)));
        }
        var _this_props_scrollEventThrottle;
        // 4. Render the ScrollView
        var scrollProps = _extends._({}, this.props, {
            onContentSizeChange: this._onContentSizeChange,
            onLayout: this._onLayout,
            onScroll: this._onScroll,
            onScrollBeginDrag: this._onScrollBeginDrag,
            onScrollEndDrag: this._onScrollEndDrag,
            onMomentumScrollBegin: this._onMomentumScrollBegin,
            onMomentumScrollEnd: this._onMomentumScrollEnd,
            // iOS/macOS requires a non-zero scrollEventThrottle to fire more than a
            // single notification while scrolling. This will otherwise no-op.
            scrollEventThrottle: (_this_props_scrollEventThrottle = this.props.scrollEventThrottle) != null ? _this_props_scrollEventThrottle : 0.0001,
            invertStickyHeaders: this.props.invertStickyHeaders !== undefined ? this.props.invertStickyHeaders : this.props.inverted,
            stickyHeaderIndices: stickyHeaderIndices,
            style: inversionStyle ? [
                inversionStyle,
                this.props.style
            ] : this.props.style,
            isInvertedVirtualizedList: this.props.inverted,
            maintainVisibleContentPosition: this.props.maintainVisibleContentPosition != null ? _extends._({}, this.props.maintainVisibleContentPosition, {
                // Adjust index to account for ListHeaderComponent.
                minIndexForVisible: this.props.maintainVisibleContentPosition.minIndexForVisible + (this.props.ListHeaderComponent ? 1 : 0)
            }) : undefined
        });
        this._hasMore = this.state.cellsAroundViewport.last < itemCount - 1;
        var innerRet = /*#__PURE__*/ _react.createElement(_VirtualizedListContext.VirtualizedListContextProvider, {
            value: {
                cellKey: null,
                getScrollMetrics: this._getScrollMetrics,
                horizontal: (0, _VirtualizedListProps.horizontalOrDefault)(this.props.horizontal),
                getOutermostParentListRef: this._getOutermostParentListRef,
                registerAsNestedChild: this._registerAsNestedChild,
                unregisterAsNestedChild: this._unregisterAsNestedChild
            }
        }, /*#__PURE__*/ _react.cloneElement((this.props.renderScrollComponent || this._defaultRenderScrollComponent)(scrollProps), {
            ref: this._captureScrollRef
        }, cells));
        var ret = innerRet;
        if (false) {}
        if (this.props.debug) {
            return /*#__PURE__*/ _react.createElement(_reactnative.View, {
                style: styles.debug
            }, ret, this._renderDebugOverlay());
        } else {
            return ret;
        }
    };
    _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
        var _this_props = this.props, data = _this_props.data, extraData = _this_props.extraData;
        if (data !== prevProps.data || extraData !== prevProps.extraData) {
            // clear the viewableIndices cache to also trigger
            // the onViewableItemsChanged callback with the new data
            this._viewabilityTuples.forEach(function(tuple) {
                tuple.viewabilityHelper.resetViewableIndices();
            });
        }
        // The `this._hiPriInProgress` is guaranteeing a hiPri cell update will only happen
        // once per fiber update. The `_scheduleCellsToRenderUpdate` will set it to true
        // if a hiPri update needs to perform. If `componentDidUpdate` is triggered with
        // `this._hiPriInProgress=true`, means it's triggered by the hiPri update. The
        // `_scheduleCellsToRenderUpdate` will check this condition and not perform
        // another hiPri update.
        var hiPriInProgress = this._hiPriInProgress;
        this._scheduleCellsToRenderUpdate();
        // Make sure setting `this._hiPriInProgress` back to false after `componentDidUpdate`
        // is triggered with `this._hiPriInProgress = true`
        if (hiPriInProgress) {
            this._hiPriInProgress = false;
        }
    };
    _proto._computeBlankness = function _computeBlankness() {
        this._fillRateHelper.computeBlankness(this.props, this.state.cellsAroundViewport, this._scrollMetrics);
    };
    _proto._triggerRemeasureForChildListsInCell = function _triggerRemeasureForChildListsInCell(cellKey) {
        this._nestedChildLists.forEachInCell(cellKey, function(childList) {
            childList.measureLayoutRelativeToContainingList();
        });
    };
    _proto.measureLayoutRelativeToContainingList = function measureLayoutRelativeToContainingList() {
        var _this = this;
        // TODO (T35574538): findNodeHandle sometimes crashes with "Unable to find
        // node on an unmounted component" during scrolling
        try {
            if (!this._scrollRef) {
                return;
            }
            // We are assuming that getOutermostParentListRef().getScrollRef()
            // is a non-null reference to a ScrollView
            this._scrollRef.measureLayout(this.context.getOutermostParentListRef().getScrollRef(), function(x, y, width, height) {
                _this._offsetFromParentVirtualizedList = _this._selectOffset({
                    x: x,
                    y: y
                });
                _this._listMetrics.notifyListContentLayout({
                    layout: {
                        width: width,
                        height: height
                    },
                    orientation: _this._orientation()
                });
                var scrollMetrics = _this._convertParentScrollMetrics(_this.context.getScrollMetrics());
                var metricsChanged = _this._scrollMetrics.visibleLength !== scrollMetrics.visibleLength || _this._scrollMetrics.offset !== scrollMetrics.offset;
                if (metricsChanged) {
                    _this._scrollMetrics.visibleLength = scrollMetrics.visibleLength;
                    _this._scrollMetrics.offset = scrollMetrics.offset;
                    // If metrics of the scrollView changed, then we triggered remeasure for child list
                    // to ensure VirtualizedList has the right information.
                    _this._nestedChildLists.forEach(function(childList) {
                        childList.measureLayoutRelativeToContainingList();
                    });
                }
            }, function(error) {
                console.warn("VirtualizedList: Encountered an error while measuring a list's" + ' offset from its containing VirtualizedList.');
            });
        } catch (error) {
            console.warn('measureLayoutRelativeToContainingList threw an error', error.stack);
        }
    };
    _proto._getFooterCellKey = function _getFooterCellKey() {
        return this._getCellKey() + '-footer';
    };
    // $FlowFixMe[missing-local-annot]
    _proto._renderDebugOverlay = function _renderDebugOverlay() {
        var normalize = this._scrollMetrics.visibleLength / (this._listMetrics.getContentLength() || 1);
        var framesInLayout = [];
        var itemCount = this.props.getItemCount(this.props.data);
        for(var ii = 0; ii < itemCount; ii++){
            var frame = this._listMetrics.getCellMetricsApprox(ii, this.props);
            if (frame.isMounted) {
                framesInLayout.push(frame);
            }
        }
        var windowTop = this._listMetrics.getCellMetricsApprox(this.state.cellsAroundViewport.first, this.props).offset;
        var frameLast = this._listMetrics.getCellMetricsApprox(this.state.cellsAroundViewport.last, this.props);
        var windowLen = frameLast.offset + frameLast.length - windowTop;
        var visTop = this._scrollMetrics.offset;
        var visLen = this._scrollMetrics.visibleLength;
        return /*#__PURE__*/ _react.createElement(_reactnative.View, {
            style: [
                styles.debugOverlayBase,
                styles.debugOverlay
            ]
        }, framesInLayout.map(function(f, ii) {
            return /*#__PURE__*/ _react.createElement(_reactnative.View, {
                key: 'f' + ii,
                style: [
                    styles.debugOverlayBase,
                    styles.debugOverlayFrame,
                    {
                        top: f.offset * normalize,
                        height: f.length * normalize
                    }
                ]
            });
        }), /*#__PURE__*/ _react.createElement(_reactnative.View, {
            style: [
                styles.debugOverlayBase,
                styles.debugOverlayFrameLast,
                {
                    top: windowTop * normalize,
                    height: windowLen * normalize
                }
            ]
        }), /*#__PURE__*/ _react.createElement(_reactnative.View, {
            style: [
                styles.debugOverlayBase,
                styles.debugOverlayFrameVis,
                {
                    top: visTop * normalize,
                    height: visLen * normalize
                }
            ]
        }));
    };
    _proto._selectLength = function _selectLength(metrics) {
        return !(0, _VirtualizedListProps.horizontalOrDefault)(this.props.horizontal) ? metrics.height : metrics.width;
    };
    _proto._selectOffset = function _selectOffset(param) {
        var x = param.x, y = param.y;
        return this._orientation().horizontal ? x : y;
    };
    _proto._orientation = function _orientation() {
        return {
            horizontal: (0, _VirtualizedListProps.horizontalOrDefault)(this.props.horizontal),
            rtl: _reactnative.I18nManager.isRTL
        };
    };
    _proto._maybeCallOnEdgeReached = function _maybeCallOnEdgeReached() {
        var _this_props = this.props, data = _this_props.data, getItemCount = _this_props.getItemCount, onStartReached = _this_props.onStartReached, onStartReachedThreshold = _this_props.onStartReachedThreshold, onEndReached = _this_props.onEndReached, onEndReachedThreshold = _this_props.onEndReachedThreshold;
        // If we have any pending scroll updates it means that the scroll metrics
        // are out of date and we should not call any of the edge reached callbacks.
        if (this.state.pendingScrollUpdateCount > 0) {
            return;
        }
        var _this__scrollMetrics = this._scrollMetrics, visibleLength = _this__scrollMetrics.visibleLength, offset = _this__scrollMetrics.offset;
        var distanceFromStart = offset;
        var distanceFromEnd = this._listMetrics.getContentLength() - visibleLength - offset;
        // Especially when oERT is zero it's necessary to 'floor' very small distance values to be 0
        // since debouncing causes us to not fire this event for every single "pixel" we scroll and can thus
        // be at the edge of the list with a distance approximating 0 but not quite there.
        if (distanceFromStart < ON_EDGE_REACHED_EPSILON) {
            distanceFromStart = 0;
        }
        if (distanceFromEnd < ON_EDGE_REACHED_EPSILON) {
            distanceFromEnd = 0;
        }
        // TODO: T121172172 Look into why we're "defaulting" to a threshold of 2px
        // when oERT is not present (different from 2 viewports used elsewhere)
        var DEFAULT_THRESHOLD_PX = 2;
        var startThreshold = onStartReachedThreshold != null ? onStartReachedThreshold * visibleLength : DEFAULT_THRESHOLD_PX;
        var endThreshold = onEndReachedThreshold != null ? onEndReachedThreshold * visibleLength : DEFAULT_THRESHOLD_PX;
        var isWithinStartThreshold = distanceFromStart <= startThreshold;
        var isWithinEndThreshold = distanceFromEnd <= endThreshold;
        // First check if the user just scrolled within the end threshold
        // and call onEndReached only once for a given content length,
        // and only if onStartReached is not being executed
        if (onEndReached && this.state.cellsAroundViewport.last === getItemCount(data) - 1 && isWithinEndThreshold && this._listMetrics.getContentLength() !== this._sentEndForContentLength) {
            this._sentEndForContentLength = this._listMetrics.getContentLength();
            onEndReached({
                distanceFromEnd: distanceFromEnd
            });
        }
        // Next check if the user just scrolled within the start threshold
        // and call onStartReached only once for a given content length,
        // and only if onEndReached is not being executed
        if (onStartReached != null && this.state.cellsAroundViewport.first === 0 && isWithinStartThreshold && this._listMetrics.getContentLength() !== this._sentStartForContentLength) {
            this._sentStartForContentLength = this._listMetrics.getContentLength();
            onStartReached({
                distanceFromStart: distanceFromStart
            });
        }
        // If the user scrolls away from the start or end and back again,
        // cause onStartReached or onEndReached to be triggered again
        if (!isWithinStartThreshold) {
            this._sentStartForContentLength = 0;
        }
        if (!isWithinEndThreshold) {
            this._sentEndForContentLength = 0;
        }
    };
    /**
   * Scroll to a specified `initialScrollIndex` prop after the ScrollView
   * content has been laid out, if it is still valid. Only a single scroll is
   * triggered throughout the lifetime of the list.
   */ _proto._maybeScrollToInitialScrollIndex = function _maybeScrollToInitialScrollIndex(contentWidth, contentHeight) {
        if (contentWidth > 0 && contentHeight > 0 && this.props.initialScrollIndex != null && this.props.initialScrollIndex > 0 && !this._hasTriggeredInitialScrollToIndex) {
            if (this.props.contentOffset == null) {
                if (this.props.initialScrollIndex < this.props.getItemCount(this.props.data)) {
                    this.scrollToIndex({
                        animated: false,
                        index: (0, _nullthrows.default)(this.props.initialScrollIndex)
                    });
                } else {
                    this.scrollToEnd({
                        animated: false
                    });
                }
            }
            this._hasTriggeredInitialScrollToIndex = true;
        }
    };
    _proto._offsetFromScrollEvent = function _offsetFromScrollEvent(e) {
        var _e_nativeEvent = e.nativeEvent, contentOffset = _e_nativeEvent.contentOffset, contentSize = _e_nativeEvent.contentSize, layoutMeasurement = _e_nativeEvent.layoutMeasurement;
        var _this__orientation = this._orientation(), horizontal = _this__orientation.horizontal, rtl = _this__orientation.rtl;
        if (horizontal && rtl) {
            return this._selectLength(contentSize) - (this._selectOffset(contentOffset) + this._selectLength(layoutMeasurement));
        } else {
            return this._selectOffset(contentOffset);
        }
    };
    _proto._scheduleCellsToRenderUpdate = function _scheduleCellsToRenderUpdate() {
        // Only trigger high-priority updates if we've actually rendered cells,
        // and with that size estimate, accurately compute how many cells we should render.
        // Otherwise, it would just render as many cells as it can (of zero dimension),
        // each time through attempting to render more (limited by maxToRenderPerBatch),
        // starving the renderer from actually laying out the objects and computing _averageCellLength.
        // If this is triggered in an `componentDidUpdate` followed by a hiPri cellToRenderUpdate
        // We shouldn't do another hipri cellToRenderUpdate
        if ((this._listMetrics.getAverageCellLength() > 0 || this.props.getItemLayout != null) && this._shouldRenderWithPriority() && !this._hiPriInProgress) {
            this._hiPriInProgress = true;
            // Don't worry about interactions when scrolling quickly; focus on filling content as fast
            // as possible.
            this._updateCellsToRenderBatcher.dispose({
                abort: true
            });
            this._updateCellsToRender();
            return;
        } else {
            this._updateCellsToRenderBatcher.schedule();
        }
    };
    _proto._shouldRenderWithPriority = function _shouldRenderWithPriority() {
        var _this_state_cellsAroundViewport = this.state.cellsAroundViewport, first = _this_state_cellsAroundViewport.first, last = _this_state_cellsAroundViewport.last;
        var _this__scrollMetrics = this._scrollMetrics, offset = _this__scrollMetrics.offset, visibleLength = _this__scrollMetrics.visibleLength, velocity = _this__scrollMetrics.velocity;
        var itemCount = this.props.getItemCount(this.props.data);
        var hiPri = false;
        var onStartReachedThreshold = (0, _VirtualizedListProps.onStartReachedThresholdOrDefault)(this.props.onStartReachedThreshold);
        var onEndReachedThreshold = (0, _VirtualizedListProps.onEndReachedThresholdOrDefault)(this.props.onEndReachedThreshold);
        // Mark as high priority if we're close to the start of the first item
        // But only if there are items before the first rendered item
        if (first > 0) {
            var distTop = offset - this._listMetrics.getCellMetricsApprox(first, this.props).offset;
            hiPri = distTop < 0 || velocity < -2 && distTop < getScrollingThreshold(onStartReachedThreshold, visibleLength);
        }
        // Mark as high priority if we're close to the end of the last item
        // But only if there are items after the last rendered item
        if (!hiPri && last >= 0 && last < itemCount - 1) {
            var distBottom = this._listMetrics.getCellMetricsApprox(last, this.props).offset - (offset + visibleLength);
            hiPri = distBottom < 0 || velocity > 2 && distBottom < getScrollingThreshold(onEndReachedThreshold, visibleLength);
        }
        return hiPri;
    };
    _proto.__getListMetrics = function __getListMetrics() {
        return this._listMetrics;
    };
    _proto._updateViewableItems = function _updateViewableItems(props, cellsAroundViewport) {
        var _this = this;
        // If we have any pending scroll updates it means that the scroll metrics
        // are out of date and we should not call any of the visibility callbacks.
        if (this.state.pendingScrollUpdateCount > 0) {
            return;
        }
        this._viewabilityTuples.forEach(function(tuple) {
            tuple.viewabilityHelper.onUpdate(props, _this._scrollMetrics.offset, _this._scrollMetrics.visibleLength, _this._listMetrics, _this._createViewToken, tuple.onViewableItemsChanged, cellsAroundViewport);
        });
    };
    VirtualizedList._findItemIndexWithKey = function _findItemIndexWithKey(props, key, hint) {
        var itemCount = props.getItemCount(props.data);
        if (hint != null && hint >= 0 && hint < itemCount) {
            var curKey = VirtualizedList._getItemKey(props, hint);
            if (curKey === key) {
                return hint;
            }
        }
        for(var ii = 0; ii < itemCount; ii++){
            var curKey1 = VirtualizedList._getItemKey(props, ii);
            if (curKey1 === key) {
                return ii;
            }
        }
        return null;
    };
    VirtualizedList._getItemKey = function _getItemKey(props, index) {
        var item = props.getItem(props.data, index);
        return VirtualizedList._keyExtractor(item, index, props);
    };
    VirtualizedList._createRenderMask = function _createRenderMask(props, cellsAroundViewport, additionalRegions) {
        var itemCount = props.getItemCount(props.data);
        (0, _invariant.default)(cellsAroundViewport.first >= 0 && cellsAroundViewport.last >= cellsAroundViewport.first - 1 && cellsAroundViewport.last < itemCount, 'Invalid cells around viewport "[' + cellsAroundViewport.first + ", " + cellsAroundViewport.last + ']" was passed to VirtualizedList._createRenderMask');
        var renderMask = new _CellRenderMask.CellRenderMask(itemCount);
        if (itemCount > 0) {
            var allRegions = [
                cellsAroundViewport
            ].concat(_to_consumable_array._(additionalRegions != null ? additionalRegions : []));
            for(var _i = 0; _i < allRegions.length; _i++){
                var region = allRegions[_i];
                renderMask.addCells(region);
            }
            // The initially rendered cells are retained as part of the
            // "scroll-to-top" optimization
            if (props.initialScrollIndex == null || props.initialScrollIndex <= 0) {
                var initialRegion = VirtualizedList._initialRenderRegion(props);
                renderMask.addCells(initialRegion);
            }
            // The layout coordinates of sticker headers may be off-screen while the
            // actual header is on-screen. Keep the most recent before the viewport
            // rendered, even if its layout coordinates are not in viewport.
            var stickyIndicesSet = new Set(props.stickyHeaderIndices);
            VirtualizedList._ensureClosestStickyHeader(props, stickyIndicesSet, renderMask, cellsAroundViewport.first);
        }
        return renderMask;
    };
    VirtualizedList._initialRenderRegion = function _initialRenderRegion(props) {
        var itemCount = props.getItemCount(props.data);
        var _props_initialScrollIndex;
        var firstCellIndex = Math.max(0, Math.min(itemCount - 1, Math.floor((_props_initialScrollIndex = props.initialScrollIndex) != null ? _props_initialScrollIndex : 0)));
        var lastCellIndex = Math.min(itemCount, firstCellIndex + (0, _VirtualizedListProps.initialNumToRenderOrDefault)(props.initialNumToRender)) - 1;
        return {
            first: firstCellIndex,
            last: lastCellIndex
        };
    };
    VirtualizedList._ensureClosestStickyHeader = function _ensureClosestStickyHeader(props, stickyIndicesSet, renderMask, cellIdx) {
        var stickyOffset = props.ListHeaderComponent ? 1 : 0;
        for(var itemIdx = cellIdx - 1; itemIdx >= 0; itemIdx--){
            if (stickyIndicesSet.has(itemIdx + stickyOffset)) {
                renderMask.addCells({
                    first: itemIdx,
                    last: itemIdx
                });
                break;
            }
        }
    };
    VirtualizedList.getDerivedStateFromProps = function getDerivedStateFromProps(newProps, prevState) {
        var _newProps_maintainVisibleContentPosition;
        // first and last could be stale (e.g. if a new, shorter items props is passed in), so we make
        // sure we're rendering a reasonable range here.
        var itemCount = newProps.getItemCount(newProps.data);
        if (itemCount === prevState.renderMask.numCells()) {
            return prevState;
        }
        var maintainVisibleContentPositionAdjustment = null;
        var prevFirstVisibleItemKey = prevState.firstVisibleItemKey;
        var _newProps_maintainVisibleContentPosition_minIndexForVisible;
        var minIndexForVisible = (_newProps_maintainVisibleContentPosition_minIndexForVisible = (_newProps_maintainVisibleContentPosition = newProps.maintainVisibleContentPosition) == null ? void 0 : _newProps_maintainVisibleContentPosition.minIndexForVisible) != null ? _newProps_maintainVisibleContentPosition_minIndexForVisible : 0;
        var newFirstVisibleItemKey = newProps.getItemCount(newProps.data) > minIndexForVisible ? VirtualizedList._getItemKey(newProps, minIndexForVisible) : null;
        if (newProps.maintainVisibleContentPosition != null && prevFirstVisibleItemKey != null && newFirstVisibleItemKey != null) {
            if (newFirstVisibleItemKey !== prevFirstVisibleItemKey) {
                // Fast path if items were added at the start of the list.
                var hint = itemCount - prevState.renderMask.numCells() + minIndexForVisible;
                var firstVisibleItemIndex = VirtualizedList._findItemIndexWithKey(newProps, prevFirstVisibleItemKey, hint);
                maintainVisibleContentPositionAdjustment = firstVisibleItemIndex != null ? firstVisibleItemIndex - minIndexForVisible : null;
            } else {
                maintainVisibleContentPositionAdjustment = null;
            }
        }
        var constrainedCells = VirtualizedList._constrainToItemCount(maintainVisibleContentPositionAdjustment != null ? {
            first: prevState.cellsAroundViewport.first + maintainVisibleContentPositionAdjustment,
            last: prevState.cellsAroundViewport.last + maintainVisibleContentPositionAdjustment
        } : prevState.cellsAroundViewport, newProps);
        return {
            cellsAroundViewport: constrainedCells,
            renderMask: VirtualizedList._createRenderMask(newProps, constrainedCells),
            firstVisibleItemKey: newFirstVisibleItemKey,
            pendingScrollUpdateCount: maintainVisibleContentPositionAdjustment != null ? prevState.pendingScrollUpdateCount + 1 : prevState.pendingScrollUpdateCount
        };
    };
    VirtualizedList._constrainToItemCount = function _constrainToItemCount(cells, props) {
        var itemCount = props.getItemCount(props.data);
        var lastPossibleCellIndex = itemCount - 1;
        // Constraining `last` may significantly shrink the window. Adjust `first`
        // to expand the window if the new `last` results in a new window smaller
        // than the number of cells rendered per batch.
        var maxToRenderPerBatch = (0, _VirtualizedListProps.maxToRenderPerBatchOrDefault)(props.maxToRenderPerBatch);
        var maxFirst = Math.max(0, lastPossibleCellIndex - maxToRenderPerBatch);
        return {
            first: (0, _clamp.default)(0, cells.first, maxFirst),
            last: Math.min(lastPossibleCellIndex, cells.last)
        };
    };
    VirtualizedList._keyExtractor = function _keyExtractor(item, index, props) {
        if (props.keyExtractor != null) {
            return props.keyExtractor(item, index);
        }
        var key = (0, _VirtualizeUtils.keyExtractor)(item, index);
        if (key === String(index)) {
            _usedIndexForKey = true;
            if (item.type && item.type.displayName) {
                _keylessItemComponentName = item.type.displayName;
            }
        }
        return key;
    };
    return VirtualizedList;
}(_StateSafePureComponent.default);
VirtualizedList.contextType = _VirtualizedListContext.VirtualizedListContext;
var styles = _reactnative.StyleSheet.create({
    verticallyInverted: _reactnative.Platform.OS === 'android' ? {
        transform: [
            {
                scale: -1
            }
        ]
    } : {
        transform: [
            {
                scaleY: -1
            }
        ]
    },
    horizontallyInverted: {
        transform: [
            {
                scaleX: -1
            }
        ]
    },
    debug: {
        flex: 1
    },
    debugOverlayBase: {
        position: 'absolute',
        top: 0,
        right: 0
    },
    debugOverlay: {
        bottom: 0,
        width: 20,
        borderColor: 'blue',
        borderWidth: 1
    },
    debugOverlayFrame: {
        left: 0,
        backgroundColor: 'orange'
    },
    debugOverlayFrameLast: {
        left: 0,
        borderColor: 'green',
        borderWidth: 2
    },
    debugOverlayFrameVis: {
        left: 0,
        borderColor: 'red',
        borderWidth: 2
    }
});
module.exports = VirtualizedList;


}),
47609: (function (module, exports, __webpack_require__) {
"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @format
 *      
 */ 
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
__webpack_require__(36021);
var _VirtualizeUtils = __webpack_require__(31606);
module.exports = {
    keyExtractor: _VirtualizeUtils.keyExtractor,
    get VirtualizedList () {
        return __webpack_require__(44902);
    },
    get VirtualizedSectionList () {
        return __webpack_require__(40541);
    },
    get VirtualizedListContextResetter () {
        var VirtualizedListContext = __webpack_require__(36021);
        return VirtualizedListContext.VirtualizedListContextResetter;
    },
    get ViewabilityHelper () {
        return __webpack_require__(60309);
    },
    get FillRateHelper () {
        return __webpack_require__(39966);
    }
};


}),
51632: (function (__unused_webpack_module, exports, __webpack_require__) {
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *       strict
 * @format
 */ Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return ChildListCollection;
    }
}));
var _interop_require_default = __webpack_require__(48810);
var _invariant = /*#__PURE__*/ _interop_require_default._(__webpack_require__(27761));
var ChildListCollection = /*#__PURE__*/ function() {
    "use strict";
    function ChildListCollection() {
        this._cellKeyToChildren = new Map();
        this._childrenToCellKey = new Map();
    }
    var _proto = ChildListCollection.prototype;
    _proto.add = function add(list, cellKey) {
        (0, _invariant.default)(!this._childrenToCellKey.has(list), 'Trying to add already present child list');
        var _this__cellKeyToChildren_get;
        var cellLists = (_this__cellKeyToChildren_get = this._cellKeyToChildren.get(cellKey)) != null ? _this__cellKeyToChildren_get : new Set();
        cellLists.add(list);
        this._cellKeyToChildren.set(cellKey, cellLists);
        this._childrenToCellKey.set(list, cellKey);
    };
    _proto.remove = function remove(list) {
        var cellKey = this._childrenToCellKey.get(list);
        (0, _invariant.default)(cellKey != null, 'Trying to remove non-present child list');
        this._childrenToCellKey["delete"](list);
        var cellLists = this._cellKeyToChildren.get(cellKey);
        (0, _invariant.default)(cellLists, '_cellKeyToChildren should contain cellKey');
        cellLists["delete"](list);
        if (cellLists.size === 0) {
            this._cellKeyToChildren["delete"](cellKey);
        }
    };
    _proto.forEach = function forEach(fn) {
        for(var _i = 0, _this__cellKeyToChildren_values = this._cellKeyToChildren.values(); _i < _this__cellKeyToChildren_values.length; _i++){
            var listSet = _this__cellKeyToChildren_values[_i];
            for(var _i1 = 0; _i1 < listSet.length; _i1++){
                var list = listSet[_i1];
                fn(list);
            }
        }
    };
    _proto.forEachInCell = function forEachInCell(cellKey, fn) {
        var _this__cellKeyToChildren_get;
        var listSet = (_this__cellKeyToChildren_get = this._cellKeyToChildren.get(cellKey)) != null ? _this__cellKeyToChildren_get : [];
        for(var _i = 0; _i < listSet.length; _i++){
            var list = listSet[_i];
            fn(list);
        }
    };
    _proto.anyInCell = function anyInCell(cellKey, fn) {
        var _this__cellKeyToChildren_get;
        var listSet = (_this__cellKeyToChildren_get = this._cellKeyToChildren.get(cellKey)) != null ? _this__cellKeyToChildren_get : [];
        for(var _i = 0; _i < listSet.length; _i++){
            var list = listSet[_i];
            if (fn(list)) {
                return true;
            }
        }
        return false;
    };
    _proto.size = function size() {
        return this._childrenToCellKey.size;
    };
    return ChildListCollection;
}();


}),
54586: (function (__unused_webpack_module, exports, __webpack_require__) {
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *      
 * @format
 */ Object.defineProperty(exports, "__esModule", ({
    value: true
}));
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get horizontalOrDefault () {
        return horizontalOrDefault;
    },
    get initialNumToRenderOrDefault () {
        return initialNumToRenderOrDefault;
    },
    get maxToRenderPerBatchOrDefault () {
        return maxToRenderPerBatchOrDefault;
    },
    get onEndReachedThresholdOrDefault () {
        return onEndReachedThresholdOrDefault;
    },
    get onStartReachedThresholdOrDefault () {
        return onStartReachedThresholdOrDefault;
    },
    get windowSizeOrDefault () {
        return windowSizeOrDefault;
    }
});
var _interop_require_wildcard = __webpack_require__(38504);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(41845));
__webpack_require__(64598);
function horizontalOrDefault(horizontal) {
    return horizontal != null ? horizontal : false;
}
function initialNumToRenderOrDefault(initialNumToRender) {
    return initialNumToRender != null ? initialNumToRender : 10;
}
function maxToRenderPerBatchOrDefault(maxToRenderPerBatch) {
    return maxToRenderPerBatch != null ? maxToRenderPerBatch : 10;
}
function onStartReachedThresholdOrDefault(onStartReachedThreshold) {
    return onStartReachedThreshold != null ? onStartReachedThreshold : 2;
}
function onEndReachedThresholdOrDefault(onEndReachedThreshold) {
    return onEndReachedThreshold != null ? onEndReachedThreshold : 2;
}
function windowSizeOrDefault(windowSize) {
    return windowSize != null ? windowSize : 21;
}


}),
60309: (function (module, exports, __webpack_require__) {
"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *      
 * @format
 */ 
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _extends = __webpack_require__(87383);
var _interop_require_default = __webpack_require__(48810);
var _sliced_to_array = __webpack_require__(21193);
var _ListMetricsAggregator = /*#__PURE__*/ _interop_require_default._(__webpack_require__(43967));
var invariant = __webpack_require__(27761);
/**
 * A Utility class for calculating viewable items based on current metrics like scroll position and
 * layout.
 *
 * An item is said to be in a "viewable" state when any of the following
 * is true for longer than `minimumViewTime` milliseconds (after an interaction if `waitForInteraction`
 * is true):
 *
 * - Occupying >= `viewAreaCoveragePercentThreshold` of the view area XOR fraction of the item
 *   visible in the view area >= `itemVisiblePercentThreshold`.
 * - Entirely visible on screen
 */ var ViewabilityHelper = /*#__PURE__*/ function() {
    function ViewabilityHelper(config) {
        if (config === void 0) config = {
            viewAreaCoveragePercentThreshold: 0
        };
        this._hasInteracted = false;
        this._timers = new Set();
        this._viewableIndices = [];
        this._viewableItems = new Map();
        this._config = config;
    }
    var _proto = ViewabilityHelper.prototype;
    /**
   * Cleanup, e.g. on unmount. Clears any pending timers.
   */ _proto.dispose = function dispose() {
        /* $FlowFixMe[incompatible-call] (>=0.63.0 site=react_native_fb) This
     * comment suppresses an error found when Flow v0.63 was deployed. To see
     * the error delete this comment and run Flow. */ this._timers.forEach(clearTimeout);
    };
    /**
   * Determines which items are viewable based on the current metrics and config.
   */ _proto.computeViewableItems = function computeViewableItems(props, scrollOffset, viewportHeight, listMetrics, // Optional optimization to reduce the scan size
    renderRange) {
        var itemCount = props.getItemCount(props.data);
        var _this__config = this._config, itemVisiblePercentThreshold = _this__config.itemVisiblePercentThreshold, viewAreaCoveragePercentThreshold = _this__config.viewAreaCoveragePercentThreshold;
        var viewAreaMode = viewAreaCoveragePercentThreshold != null;
        var viewablePercentThreshold = viewAreaMode ? viewAreaCoveragePercentThreshold : itemVisiblePercentThreshold;
        invariant(viewablePercentThreshold != null && itemVisiblePercentThreshold != null !== (viewAreaCoveragePercentThreshold != null), 'Must set exactly one of itemVisiblePercentThreshold or viewAreaCoveragePercentThreshold');
        var viewableIndices = [];
        if (itemCount === 0) {
            return viewableIndices;
        }
        var firstVisible = -1;
        var _ref = renderRange || {
            first: 0,
            last: itemCount - 1
        }, first = _ref.first, last = _ref.last;
        if (last >= itemCount) {
            console.warn('Invalid render range computing viewability ' + JSON.stringify({
                renderRange: renderRange,
                itemCount: itemCount
            }));
            return [];
        }
        for(var idx = first; idx <= last; idx++){
            var metrics = listMetrics.getCellMetrics(idx, props);
            if (!metrics) {
                continue;
            }
            var top = Math.floor(metrics.offset - scrollOffset);
            var bottom = Math.floor(top + metrics.length);
            if (top < viewportHeight && bottom > 0) {
                firstVisible = idx;
                if (_isViewable(viewAreaMode, viewablePercentThreshold, top, bottom, viewportHeight, metrics.length)) {
                    viewableIndices.push(idx);
                }
            } else if (firstVisible >= 0) {
                break;
            }
        }
        return viewableIndices;
    };
    /**
   * Figures out which items are viewable and how that has changed from before and calls
   * `onViewableItemsChanged` as appropriate.
   */ _proto.onUpdate = function onUpdate(props, scrollOffset, viewportHeight, listMetrics, createViewToken, onViewableItemsChanged, // Optional optimization to reduce the scan size
    renderRange) {
        var _this = this;
        var itemCount = props.getItemCount(props.data);
        if (this._config.waitForInteraction && !this._hasInteracted || itemCount === 0 || !listMetrics.getCellMetrics(0, props)) {
            return;
        }
        var viewableIndices = [];
        if (itemCount) {
            viewableIndices = this.computeViewableItems(props, scrollOffset, viewportHeight, listMetrics, renderRange);
        }
        if (this._viewableIndices.length === viewableIndices.length && this._viewableIndices.every(function(v, ii) {
            return v === viewableIndices[ii];
        })) {
            // We might get a lot of scroll events where visibility doesn't change and we don't want to do
            // extra work in those cases.
            return;
        }
        this._viewableIndices = viewableIndices;
        if (this._config.minimumViewTime) {
            var handle = setTimeout(function() {
                /* $FlowFixMe[incompatible-call] (>=0.63.0 site=react_native_fb) This
         * comment suppresses an error found when Flow v0.63 was deployed. To
         * see the error delete this comment and run Flow. */ _this._timers["delete"](handle);
                _this._onUpdateSync(props, viewableIndices, onViewableItemsChanged, createViewToken);
            }, this._config.minimumViewTime);
            /* $FlowFixMe[incompatible-call] (>=0.63.0 site=react_native_fb) This
       * comment suppresses an error found when Flow v0.63 was deployed. To see
       * the error delete this comment and run Flow. */ this._timers.add(handle);
        } else {
            this._onUpdateSync(props, viewableIndices, onViewableItemsChanged, createViewToken);
        }
    };
    /**
   * clean-up cached _viewableIndices to evaluate changed items on next update
   */ _proto.resetViewableIndices = function resetViewableIndices() {
        this._viewableIndices = [];
    };
    /**
   * Records that an interaction has happened even if there has been no scroll.
   */ _proto.recordInteraction = function recordInteraction() {
        this._hasInteracted = true;
    };
    _proto._onUpdateSync = function _onUpdateSync(props, viewableIndicesToCheck, onViewableItemsChanged, createViewToken) {
        var _this = this;
        // Filter out indices that have gone out of view since this call was scheduled.
        viewableIndicesToCheck = viewableIndicesToCheck.filter(function(ii) {
            return _this._viewableIndices.includes(ii);
        });
        var prevItems = this._viewableItems;
        var nextItems = new Map(viewableIndicesToCheck.map(function(ii) {
            var viewable = createViewToken(ii, true, props);
            return [
                viewable.key,
                viewable
            ];
        }));
        var changed = [];
        for(var _i = 0; _i < nextItems.length; _i++){
            var _nextItems__i = _sliced_to_array._(nextItems[_i], 2), key = _nextItems__i[0], viewable = _nextItems__i[1];
            if (!prevItems.has(key)) {
                changed.push(viewable);
            }
        }
        for(var _i1 = 0; _i1 < prevItems.length; _i1++){
            var _prevItems__i = _sliced_to_array._(prevItems[_i1], 2), key1 = _prevItems__i[0], viewable1 = _prevItems__i[1];
            if (!nextItems.has(key1)) {
                changed.push(_extends._({}, viewable1, {
                    isViewable: false
                }));
            }
        }
        if (changed.length > 0) {
            this._viewableItems = nextItems;
            onViewableItemsChanged({
                viewableItems: Array.from(nextItems.values()),
                changed: changed,
                viewabilityConfig: this._config
            });
        }
    };
    return ViewabilityHelper;
}();
function _isViewable(viewAreaMode, viewablePercentThreshold, top, bottom, viewportHeight, itemLength) {
    if (_isEntirelyVisible(top, bottom, viewportHeight)) {
        return true;
    } else {
        var pixels = _getPixelsVisible(top, bottom, viewportHeight);
        var percent = 100 * (viewAreaMode ? pixels / viewportHeight : pixels / itemLength);
        return percent >= viewablePercentThreshold;
    }
}
function _getPixelsVisible(top, bottom, viewportHeight) {
    var visibleHeight = Math.min(bottom, viewportHeight) - Math.max(top, 0);
    return Math.max(0, visibleHeight);
}
function _isEntirelyVisible(top, bottom, viewportHeight) {
    return top >= 0 && bottom <= viewportHeight && bottom > top;
}
module.exports = ViewabilityHelper;


}),
71121: (function (__unused_webpack_module, exports, __webpack_require__) {
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *       strict
 * @format
 */ Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return StateSafePureComponent;
    }
}));
var _inherits = __webpack_require__(85428);
var _interop_require_default = __webpack_require__(48810);
var _interop_require_wildcard = __webpack_require__(38504);
var _invariant = /*#__PURE__*/ _interop_require_default._(__webpack_require__(27761));
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(41845));
var StateSafePureComponent = /*#__PURE__*/ function(_React_PureComponent) {
    "use strict";
    _inherits._(StateSafePureComponent, _React_PureComponent);
    function StateSafePureComponent(props) {
        var _this;
        _this = _React_PureComponent.call(this, props) || this, _this._inAsyncStateUpdate = false;
        _this._installSetStateHooks();
        return _this;
    }
    var _proto = StateSafePureComponent.prototype;
    _proto.setState = function setState(partialState, callback) {
        var _this = this;
        if (typeof partialState === 'function') {
            _React_PureComponent.prototype.setState.call(this, function(state, props) {
                _this._inAsyncStateUpdate = true;
                var ret;
                try {
                    ret = partialState(state, props);
                } catch (err) {
                    throw err;
                } finally{
                    _this._inAsyncStateUpdate = false;
                }
                return ret;
            }, callback);
        } else {
            _React_PureComponent.prototype.setState.call(this, partialState, callback);
        }
    };
    _proto._installSetStateHooks = function _installSetStateHooks() {
        var that = this;
        var _this = this, props = _this.props, state = _this.state;
        Object.defineProperty(this, 'props', {
            get: function() {
                (0, _invariant.default)(!that._inAsyncStateUpdate, '"this.props" should not be accessed during state updates');
                return props;
            },
            set: function(newProps) {
                props = newProps;
            }
        });
        Object.defineProperty(this, 'state', {
            get: function() {
                (0, _invariant.default)(!that._inAsyncStateUpdate, '"this.state" should not be acceessed during state updates');
                return state;
            },
            set: function(newState) {
                state = newState;
            }
        });
    };
    return StateSafePureComponent;
}(_react.PureComponent);


}),
72169: (function (module, exports, __webpack_require__) {
"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @format
 *       strict
 */ 
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _to_consumable_array = __webpack_require__(8034);
/**
 * Intentional info-level logging for clear separation from ad-hoc console debug logging.
 */ function infoLog() {
    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
        args[_key] = arguments[_key];
    }
    var _console;
    return (_console = console).log.apply(_console, _to_consumable_array._(args));
}
module.exports = infoLog;


}),

}]);//# sourceMappingURL=vendors-node_modules_react-native_virtualized-lists_index_js.chunk.bundle.map?platform=ios/* RCSSB */eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJoYXNoIjoiMjM4N2RmOGRmODFmNmRjNjQzMTA2MDg0YzM5YTUxOTE4MmQzMGMzOThmODg2MWU3YzZmNjkwZDhhNWIwZTA0ZSIsImlhdCI6MTc0ODkzMTIzOX0.Th0ZzlZvQeR8LB55BVJdfTwXOpewtKU_RnsfpNVBjprOZ27PMT03ObUzXB1GljOGVR7-sG8IGj5Z5NYUNmTjgABxLaI2F_V8N-k2B5sgYmDPv22Zxy9985IQyl4cMhWgd4ldzKKL992fvpUuJ4VaQx8hugqVGwy4yb3HsIkkPCfwIaO0Ug7O8eIvXXDOy9y5nuR2_2iw5TOiasXPJpBuijFIhqU3ydyQ1TYkH-qjvTccHHbTK94iv-Mzybr8uJhwI_kPH8dk9bkf6h4r0Jaci048O7xY0q0a1937ToPTSLKmU3ebBq4_RFR0ExfW_ptBOfnMTpmZjYiFUZ9IoClBQw                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              