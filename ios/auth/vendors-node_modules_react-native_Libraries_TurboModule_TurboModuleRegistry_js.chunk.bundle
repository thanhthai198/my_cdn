(self["webpackChunksas_auth"] = self["webpackChunksas_auth"] || []).push([["vendors-node_modules_react-native_Libraries_TurboModule_TurboModuleRegistry_js"], {
40863: (function (module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _sliced_to_array = __webpack_require__(21193);
var BatchedBridge = __webpack_require__(70572);
var invariant = __webpack_require__(27761);
function genModule(config, moduleID) {
    if (!config) {
        return null;
    }
    var _config = _sliced_to_array._(config, 5), moduleName = _config[0], constants = _config[1], methods = _config[2], promiseMethods = _config[3], syncMethods = _config[4];
    invariant(!moduleName.startsWith('RCT') && !moduleName.startsWith('RK'), "Module name prefixes should've been stripped by the native side " + "but wasn't for " + moduleName);
    if (!constants && !methods) {
        return {
            name: moduleName
        };
    }
    var _$module = {};
    methods && methods.forEach(function(methodName, methodID) {
        var isPromise = promiseMethods && arrayContains(promiseMethods, methodID) || false;
        var isSync = syncMethods && arrayContains(syncMethods, methodID) || false;
        invariant(!isPromise || !isSync, 'Cannot have a method that is both async and a sync hook');
        var methodType = isPromise ? 'promise' : isSync ? 'sync' : 'async';
        _$module[methodName] = genMethod(moduleID, methodID, methodType);
    });
    Object.assign(_$module, constants);
    if (_$module.getConstants == null) {
        _$module.getConstants = function() {
            return constants || Object.freeze({});
        };
    } else {
        console.warn("Unable to define method 'getConstants()' on NativeModule '" + moduleName + "'. NativeModule '" + moduleName + "' already has a constant or method called 'getConstants'. Please remove it.");
    }
    if (false) {}
    return {
        name: moduleName,
        module: _$module
    };
}
__webpack_require__.g.__fbGenNativeModule = genModule;
function loadModule(name, moduleID) {
    invariant(__webpack_require__.g.nativeRequireModuleConfig, "Can't lazily create module without nativeRequireModuleConfig");
    var config = __webpack_require__.g.nativeRequireModuleConfig(name);
    var info = genModule(config, moduleID);
    return info && info.module;
}
function genMethod(moduleID, methodID, type) {
    var fn = null;
    if (type === 'promise') {
        fn = function promiseMethodWrapper() {
            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                args[_key] = arguments[_key];
            }
            var enqueueingFrameError = new Error();
            return new Promise(function(resolve, reject) {
                BatchedBridge.enqueueNativeCall(moduleID, methodID, args, function(data) {
                    return resolve(data);
                }, function(errorData) {
                    return reject(updateErrorWithErrorData(errorData, enqueueingFrameError));
                });
            });
        };
    } else {
        fn = function nonPromiseMethodWrapper() {
            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                args[_key] = arguments[_key];
            }
            var lastArg = args.length > 0 ? args[args.length - 1] : null;
            var secondLastArg = args.length > 1 ? args[args.length - 2] : null;
            var hasSuccessCallback = typeof lastArg === 'function';
            var hasErrorCallback = typeof secondLastArg === 'function';
            hasErrorCallback && invariant(hasSuccessCallback, 'Cannot have a non-function arg after a function arg.');
            var onSuccess = hasSuccessCallback ? lastArg : null;
            var onFail = hasErrorCallback ? secondLastArg : null;
            var callbackCount = hasSuccessCallback + hasErrorCallback;
            var newArgs = args.slice(0, args.length - callbackCount);
            if (type === 'sync') {
                return BatchedBridge.callNativeSyncHook(moduleID, methodID, newArgs, onFail, onSuccess);
            } else {
                BatchedBridge.enqueueNativeCall(moduleID, methodID, newArgs, onFail, onSuccess);
            }
        };
    }
    fn.type = type;
    return fn;
}
function arrayContains(array, value) {
    return array.indexOf(value) !== -1;
}
function updateErrorWithErrorData(errorData, error) {
    return Object.assign(error, errorData || {});
}
var NativeModules = {};
if (__webpack_require__.g.nativeModuleProxy) {
    NativeModules = __webpack_require__.g.nativeModuleProxy;
} else {
    var bridgeConfig = __webpack_require__.g.__fbBatchedBridgeConfig;
    invariant(bridgeConfig, '__fbBatchedBridgeConfig is not set, cannot invoke native modules');
    var defineLazyObjectProperty = __webpack_require__(78716);
    (bridgeConfig.remoteModuleConfig || []).forEach(function(config, moduleID) {
        var info = genModule(config, moduleID);
        if (!info) {
            return;
        }
        if (info.module) {
            NativeModules[info.name] = info.module;
        } else {
            defineLazyObjectProperty(NativeModules, info.name, {
                get: function() {
                    return loadModule(info.name, moduleID);
                }
            });
        }
    });
}
module.exports = NativeModules;


}),
50940: (function (module, __unused_webpack_exports, __webpack_require__) {
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @format
 *       strict
 */ /**
 * The particular require runtime that we are using looks for a global
 * `ErrorUtils` object and if it exists, then it requires modules with the
 * error handler specified via ErrorUtils.setGlobalHandler by calling the
 * require function with applyWithGuard. Since the require module is loaded
 * before any of the modules, this ErrorUtils must be defined (and the handler
 * set) globally before requiring anything.
 *
 * However, we still want to treat ErrorUtils as a module so that other modules
 * that use it aren't just using a global variable, so simply export the global
 * variable here. ErrorUtils is originally defined in a file named error-guard.js.
 */ module.exports = __webpack_require__.g.ErrorUtils;


}),
53013: (function (module) {
"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @format
 *       strict
 */ 
var warnedKeys = {};
/**
 * A simple function that prints a warning message once per session.
 *
 * @param {string} key - The key used to ensure the message is printed once.
 *                       This should be unique to the callsite.
 * @param {string} message - The message to print
 */ function warnOnce(key, message) {
    if (warnedKeys[key]) {
        return;
    }
    console.warn(message);
    warnedKeys[key] = true;
}
module.exports = warnOnce;


}),
66030: (function (__unused_webpack_module, exports, __webpack_require__) {
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *       strict
 * @format
 */ Object.defineProperty(exports, "__esModule", ({
    value: true
}));
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get get () {
        return get;
    },
    get getEnforcing () {
        return getEnforcing;
    }
});
var _interop_require_default = __webpack_require__(48810);
var _invariant = /*#__PURE__*/ _interop_require_default._(__webpack_require__(27761));
var NativeModules = __webpack_require__(40863);
var turboModuleProxy = __webpack_require__.g.__turboModuleProxy;
var useLegacyNativeModuleInterop = __webpack_require__.g.RN$Bridgeless !== true || __webpack_require__.g.RN$TurboInterop === true;
function requireModule(name) {
    if (turboModuleProxy != null) {
        var module = turboModuleProxy(name);
        if (module != null) {
            return module;
        }
    }
    if (useLegacyNativeModuleInterop) {
        // Backward compatibility layer during migration.
        var legacyModule = NativeModules[name];
        if (legacyModule != null) {
            return legacyModule;
        }
    }
    return null;
}
function get(name) {
    return requireModule(name);
}
function getEnforcing(name) {
    var module = requireModule(name);
    (0, _invariant.default)(module != null, "TurboModuleRegistry.getEnforcing(...): '" + name + "' could not be found. " + 'Verify that a module by this name is registered in the native binary.');
    return module;
}


}),
70572: (function (module, __unused_webpack_exports, __webpack_require__) {
"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @format
 *       strict
 */ 
var MessageQueue = __webpack_require__(83829);
var BatchedBridge = new MessageQueue();
// Wire up the batched bridge on the global object so that we can call into it.
// Ideally, this would be the inverse relationship. I.e. the native environment
// provides this global directly with its script embedded. Then this module
// would export it. A possible fix would be to trim the dependencies in
// MessageQueue to its minimal features and embed that in the native runtime.
Object.defineProperty(__webpack_require__.g, '__fbBatchedBridge', {
    configurable: true,
    value: BatchedBridge
});
module.exports = BatchedBridge;


}),
78716: (function (module) {
"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @format
 *       strict
 */ 
/**
 * Defines a lazily evaluated property on the supplied `object`.
 */ function defineLazyObjectProperty(object, name, descriptor) {
    var get = descriptor.get;
    var enumerable = descriptor.enumerable !== false;
    var writable = descriptor.writable !== false;
    var value;
    var valueSet = false;
    function getValue() {
        // WORKAROUND: A weird infinite loop occurs where calling `getValue` calls
        // `setValue` which calls `Object.defineProperty` which somehow triggers
        // `getValue` again. Adding `valueSet` breaks this loop.
        if (!valueSet) {
            // Calling `get()` here can trigger an infinite loop if it fails to
            // remove the getter on the property, which can happen when executing
            // JS in a V8 context.  `valueSet = true` will break this loop, and
            // sets the value of the property to undefined, until the code in `get()`
            // finishes, at which point the property is set to the correct value.
            valueSet = true;
            setValue(get());
        }
        return value;
    }
    function setValue(newValue) {
        value = newValue;
        valueSet = true;
        Object.defineProperty(object, name, {
            value: newValue,
            configurable: true,
            enumerable: enumerable,
            writable: writable
        });
    }
    Object.defineProperty(object, name, {
        get: getValue,
        set: setValue,
        configurable: true,
        enumerable: enumerable
    });
}
module.exports = defineLazyObjectProperty;


}),
83829: (function (module, exports, __webpack_require__) {
"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *       strict
 * @format
 */ 
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _to_consumable_array = __webpack_require__(8034);
var _type_of = __webpack_require__(29936);
var Systrace = __webpack_require__(87354);
var deepFreezeAndThrowOnMutationInDev = __webpack_require__(91858);
var stringifySafe = (__webpack_require__(93435)/* ["default"] */["default"]);
var warnOnce = __webpack_require__(53013);
var ErrorUtils = __webpack_require__(50940);
var invariant = __webpack_require__(27761);
var TO_JS = 0;
var TO_NATIVE = 1;
var MODULE_IDS = 0;
var METHOD_IDS = 1;
var PARAMS = 2;
var MIN_TIME_BETWEEN_FLUSHES_MS = 5;
// eslint-disable-next-line no-bitwise
var TRACE_TAG_REACT_APPS = (/* unused pure expression or super */ null && (1 << 17));
var DEBUG_INFO_LIMIT = 32;
var MessageQueue = /*#__PURE__*/ function() {
    function MessageQueue() {
        this._lazyCallableModules = {};
        this._queue = [
            [],
            [],
            [],
            0
        ];
        this._successCallbacks = new Map();
        this._failureCallbacks = new Map();
        this._callID = 0;
        this._lastFlush = 0;
        this._eventLoopStartTime = Date.now();
        this._reactNativeMicrotasksCallback = null;
        if (false) {}
        // $FlowFixMe[cannot-write]
        this.callFunctionReturnFlushedQueue = // $FlowFixMe[method-unbinding] added when improving typing for this parameters
        this.callFunctionReturnFlushedQueue.bind(this);
        // $FlowFixMe[cannot-write]
        // $FlowFixMe[method-unbinding] added when improving typing for this parameters
        this.flushedQueue = this.flushedQueue.bind(this);
        // $FlowFixMe[cannot-write]
        this.invokeCallbackAndReturnFlushedQueue = // $FlowFixMe[method-unbinding] added when improving typing for this parameters
        this.invokeCallbackAndReturnFlushedQueue.bind(this);
    }
    var _proto = MessageQueue.prototype;
    _proto.callFunctionReturnFlushedQueue = function callFunctionReturnFlushedQueue(module1, method, args) {
        var _this = this;
        this.__guard(function() {
            _this.__callFunction(module1, method, args);
        });
        return this.flushedQueue();
    };
    _proto.invokeCallbackAndReturnFlushedQueue = function invokeCallbackAndReturnFlushedQueue(cbID, args) {
        var _this = this;
        this.__guard(function() {
            _this.__invokeCallback(cbID, args);
        });
        return this.flushedQueue();
    };
    _proto.flushedQueue = function flushedQueue() {
        var _this = this;
        this.__guard(function() {
            _this.__callReactNativeMicrotasks();
        });
        var queue = this._queue;
        this._queue = [
            [],
            [],
            [],
            this._callID
        ];
        return queue[0].length ? queue : null;
    };
    _proto.getEventLoopRunningTime = function getEventLoopRunningTime() {
        return Date.now() - this._eventLoopStartTime;
    };
    _proto.registerCallableModule = function registerCallableModule(name, module1) {
        this._lazyCallableModules[name] = function() {
            return module1;
        };
    };
    _proto.registerLazyCallableModule = function registerLazyCallableModule(name, factory) {
        var _$module;
        var getValue = factory;
        this._lazyCallableModules[name] = function() {
            if (getValue) {
                _$module = getValue();
                getValue = null;
            }
            /* $FlowFixMe[class-object-subtyping] added when improving typing for
       * this parameters */ return _$module;
        };
    };
    _proto.getCallableModule = function getCallableModule(name) {
        var getValue = this._lazyCallableModules[name];
        return getValue ? getValue() : null;
    };
    _proto.callNativeSyncHook = function callNativeSyncHook(moduleID, methodID, params, onFail, onSucc) {
        if (false) {}
        this.processCallbacks(moduleID, methodID, params, onFail, onSucc);
        return __webpack_require__.g.nativeCallSyncHook(moduleID, methodID, params);
    };
    _proto.processCallbacks = function processCallbacks(moduleID, methodID, params, onFail, onSucc) {
        var _this = this;
        if (onFail || onSucc) {
            if (false) { var info }
            // Encode callIDs into pairs of callback identifiers by shifting left and using the rightmost bit
            // to indicate fail (0) or success (1)
            // eslint-disable-next-line no-bitwise
            onFail && params.push(this._callID << 1);
            // eslint-disable-next-line no-bitwise
            onSucc && params.push(this._callID << 1 | 1);
            this._successCallbacks.set(this._callID, onSucc);
            this._failureCallbacks.set(this._callID, onFail);
        }
        if (false) {}
        this._callID++;
    };
    _proto.enqueueNativeCall = function enqueueNativeCall(moduleID, methodID, params, onFail, onSucc) {
        this.processCallbacks(moduleID, methodID, params, onFail, onSucc);
        this._queue[MODULE_IDS].push(moduleID);
        this._queue[METHOD_IDS].push(methodID);
        if (false) { var replacer, isValidArgument }
        this._queue[PARAMS].push(params);
        var now = Date.now();
        if (__webpack_require__.g.nativeFlushQueueImmediate && now - this._lastFlush >= MIN_TIME_BETWEEN_FLUSHES_MS) {
            var queue = this._queue;
            this._queue = [
                [],
                [],
                [],
                this._callID
            ];
            this._lastFlush = now;
            __webpack_require__.g.nativeFlushQueueImmediate(queue);
        }
        Systrace.counterEvent('pending_js_to_native_queue', this._queue[0].length);
        if (false) {} else if (this.__spy) {
            this.__spy({
                type: TO_NATIVE,
                module: moduleID + '',
                method: methodID,
                args: params
            });
        }
    };
    _proto.createDebugLookup = function createDebugLookup(moduleID, name, methods) {
        if (false) {}
    };
    // For JSTimers to register its callback. Otherwise a circular dependency
    // between modules is introduced. Note that only one callback may be
    // registered at a time.
    _proto.setReactNativeMicrotasksCallback = function setReactNativeMicrotasksCallback(fn) {
        this._reactNativeMicrotasksCallback = fn;
    };
    /**
   * Private methods
   */ _proto.__guard = function __guard(fn) {
        if (this.__shouldPauseOnThrow()) {
            fn();
        } else {
            try {
                fn();
            } catch (error) {
                ErrorUtils.reportFatalError(error);
            }
        }
    };
    // MessageQueue installs a global handler to catch all exceptions where JS users can register their own behavior
    // This handler makes all exceptions to be propagated from inside MessageQueue rather than by the VM at their origin
    // This makes stacktraces to be placed at MessageQueue rather than at where they were launched
    // The parameter DebuggerInternal.shouldPauseOnThrow is used to check before catching all exceptions and
    // can be configured by the VM or any Inspector
    _proto.__shouldPauseOnThrow = function __shouldPauseOnThrow() {
        return(// $FlowFixMe[cannot-resolve-name]
        typeof DebuggerInternal !== 'undefined' && // $FlowFixMe[cannot-resolve-name]
        DebuggerInternal.shouldPauseOnThrow === true);
    };
    _proto.__callReactNativeMicrotasks = function __callReactNativeMicrotasks() {
        Systrace.beginEvent('JSTimers.callReactNativeMicrotasks()');
        try {
            if (this._reactNativeMicrotasksCallback != null) {
                this._reactNativeMicrotasksCallback();
            }
        } finally{
            Systrace.endEvent();
        }
    };
    _proto.__callFunction = function __callFunction(module1, method, args) {
        this._lastFlush = Date.now();
        this._eventLoopStartTime = this._lastFlush;
        if ( false || this.__spy) {
            Systrace.beginEvent(module1 + "." + method + "(" + stringifySafe(args) + ")");
        } else {
            Systrace.beginEvent(module1 + "." + method + "(...)");
        }
        try {
            if (this.__spy) {
                this.__spy({
                    type: TO_JS,
                    module: module1,
                    method: method,
                    args: args
                });
            }
            var moduleMethods = this.getCallableModule(module1);
            if (!moduleMethods) {
                var callableModuleNames = Object.keys(this._lazyCallableModules);
                var n = callableModuleNames.length;
                var callableModuleNameList = callableModuleNames.join(', ');
                // TODO(T122225939): Remove after investigation: Why are we getting to this line in bridgeless mode?
                var isBridgelessMode = __webpack_require__.g.RN$Bridgeless === true ? 'true' : 'false';
                invariant(false, "Failed to call into JavaScript module method " + module1 + "." + method + "(). Module has not been registered as callable. Bridgeless Mode: " + isBridgelessMode + ". Registered callable JavaScript modules (n = " + n + "): " + callableModuleNameList + ".\n          A frequent cause of the error is that the application entry file path is incorrect. This can also happen when the JS bundle is corrupt or there is an early initialization error when loading React Native.");
            }
            // $FlowFixMe[invalid-computed-prop]
            if (!moduleMethods[method]) {
                invariant(false, "Failed to call into JavaScript module method " + module1 + "." + method + "(). Module exists, but the method is undefined.");
            }
            moduleMethods[method].apply(moduleMethods, args);
        } finally{
            Systrace.endEvent();
        }
    };
    _proto.__invokeCallback = function __invokeCallback(cbID, args) {
        this._lastFlush = Date.now();
        this._eventLoopStartTime = this._lastFlush;
        // The rightmost bit of cbID indicates fail (0) or success (1), the other bits are the callID shifted left.
        // eslint-disable-next-line no-bitwise
        var callID = cbID >>> 1;
        // eslint-disable-next-line no-bitwise
        var isSuccess = cbID & 1;
        var callback = isSuccess ? this._successCallbacks.get(callID) : this._failureCallbacks.get(callID);
        if (false) { var profileName, _$module, debug, method }
        try {
            if (!callback) {
                return;
            }
            this._successCallbacks["delete"](callID);
            this._failureCallbacks["delete"](callID);
            callback.apply(void 0, _to_consumable_array._(args));
        } finally{
            if (false) {}
        }
    };
    /**
   * Public APIs
   */ MessageQueue.spy = function spy(spyOrToggle) {
        if (spyOrToggle === true) {
            MessageQueue.prototype.__spy = function(info) {
                console.log("" + (info.type === TO_JS ? 'N->JS' : 'JS->N') + " : " + ("" + (info.module != null ? info.module + '.' : '') + info.method) + ("(" + JSON.stringify(info.args) + ")"));
            };
        } else if (spyOrToggle === false) {
            MessageQueue.prototype.__spy = null;
        } else {
            MessageQueue.prototype.__spy = spyOrToggle;
        }
    };
    return MessageQueue;
}();
module.exports = MessageQueue;


}),
87354: (function (__unused_webpack_module, exports, __webpack_require__) {
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *       strict
 * @format
 */ Object.defineProperty(exports, "__esModule", ({
    value: true
}));
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get beginAsyncEvent () {
        return beginAsyncEvent;
    },
    get beginEvent () {
        return beginEvent;
    },
    get counterEvent () {
        return counterEvent;
    },
    get endAsyncEvent () {
        return endAsyncEvent;
    },
    get endEvent () {
        return endEvent;
    },
    get isEnabled () {
        return isEnabled;
    },
    get setEnabled () {
        return setEnabled;
    }
});
var TRACE_TAG_REACT_APPS = 1 << 17; // eslint-disable-line no-bitwise
var _asyncCookie = 0;
function isEnabled() {
    return __webpack_require__.g.nativeTraceIsTracing ? __webpack_require__.g.nativeTraceIsTracing(TRACE_TAG_REACT_APPS) : Boolean(__webpack_require__.g.__RCTProfileIsProfiling);
}
function setEnabled(_doEnable) {}
function beginEvent(eventName, args) {
    if (isEnabled()) {
        var eventNameString = typeof eventName === 'function' ? eventName() : eventName;
        __webpack_require__.g.nativeTraceBeginSection(TRACE_TAG_REACT_APPS, eventNameString, args);
    }
}
function endEvent(args) {
    if (isEnabled()) {
        __webpack_require__.g.nativeTraceEndSection(TRACE_TAG_REACT_APPS, args);
    }
}
function beginAsyncEvent(eventName, args) {
    var cookie = _asyncCookie;
    if (isEnabled()) {
        _asyncCookie++;
        var eventNameString = typeof eventName === 'function' ? eventName() : eventName;
        __webpack_require__.g.nativeTraceBeginAsyncSection(TRACE_TAG_REACT_APPS, eventNameString, cookie, args);
    }
    return cookie;
}
function endAsyncEvent(eventName, cookie, args) {
    if (isEnabled()) {
        var eventNameString = typeof eventName === 'function' ? eventName() : eventName;
        __webpack_require__.g.nativeTraceEndAsyncSection(TRACE_TAG_REACT_APPS, eventNameString, cookie, args);
    }
}
function counterEvent(eventName, value) {
    if (isEnabled()) {
        var eventNameString = typeof eventName === 'function' ? eventName() : eventName;
        __webpack_require__.g.nativeTraceCounter && __webpack_require__.g.nativeTraceCounter(TRACE_TAG_REACT_APPS, eventNameString, value);
    }
}
if (false) { var Systrace }


}),
91858: (function (module, exports, __webpack_require__) {
"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @format
 *       strict
 */ 
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _type_of = __webpack_require__(29936);
/**
 * If your application is accepting different values for the same field over
 * time and is doing a diff on them, you can either (1) create a copy or
 * (2) ensure that those values are not mutated behind two passes.
 * This function helps you with (2) by freezing the object and throwing if
 * the user subsequently modifies the value.
 *
 * There are two caveats with this function:
 *   - If the call site is not in strict mode, it will only throw when
 *     mutating existing fields, adding a new one
 *     will unfortunately fail silently :(
 *   - If the object is already frozen or sealed, it will not continue the
 *     deep traversal and will leave leaf nodes unfrozen.
 *
 * Freezing the object and adding the throw mechanism is expensive and will
 * only be used in DEV.
 */ function deepFreezeAndThrowOnMutationInDev(object) {
    if (false) { var i1, key1, i, hasOwnProperty, key, keys }
    return object;
}
/* $FlowFixMe[missing-local-annot] The type annotation(s) required by Flow's
 * LTI update could not be added via codemod */ function throwOnImmutableMutation(key, value) {
    throw Error('You attempted to set the key `' + key + '` with the value `' + JSON.stringify(value) + '` on an object that is meant to be immutable ' + 'and has been frozen.');
}
function identity(value) {
    return value;
}
module.exports = deepFreezeAndThrowOnMutationInDev;


}),
93435: (function (__unused_webpack_module, exports, __webpack_require__) {
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @format
 *       strict
 */ Object.defineProperty(exports, "__esModule", ({
    value: true
}));
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get createStringifySafeWithLimits () {
        return createStringifySafeWithLimits;
    },
    get default () {
        return _default;
    }
});
var _interop_require_default = __webpack_require__(48810);
var _type_of = __webpack_require__(29936);
var _invariant = /*#__PURE__*/ _interop_require_default._(__webpack_require__(27761));
function createStringifySafeWithLimits(limits) {
    var _limits_maxDepth = limits.maxDepth, maxDepth = _limits_maxDepth === void 0 ? Number.POSITIVE_INFINITY : _limits_maxDepth, _limits_maxStringLimit = limits.maxStringLimit, maxStringLimit = _limits_maxStringLimit === void 0 ? Number.POSITIVE_INFINITY : _limits_maxStringLimit, _limits_maxArrayLimit = limits.maxArrayLimit, maxArrayLimit = _limits_maxArrayLimit === void 0 ? Number.POSITIVE_INFINITY : _limits_maxArrayLimit, _limits_maxObjectKeysLimit = limits.maxObjectKeysLimit, maxObjectKeysLimit = _limits_maxObjectKeysLimit === void 0 ? Number.POSITIVE_INFINITY : _limits_maxObjectKeysLimit;
    var stack = [];
    /* $FlowFixMe[missing-this-annot] The 'this' type annotation(s) required by
   * Flow's LTI update could not be added via codemod */ function replacer(key, value) {
        while(stack.length && this !== stack[0]){
            stack.shift();
        }
        if (typeof value === 'string') {
            var truncatedString = '...(truncated)...';
            if (value.length > maxStringLimit + truncatedString.length) {
                return value.substring(0, maxStringLimit) + truncatedString;
            }
            return value;
        }
        if ((typeof value === "undefined" ? "undefined" : _type_of._(value)) !== 'object' || value === null) {
            return value;
        }
        var retval = value;
        if (Array.isArray(value)) {
            if (stack.length >= maxDepth) {
                retval = "[ ... array with " + value.length + " values ... ]";
            } else if (value.length > maxArrayLimit) {
                retval = value.slice(0, maxArrayLimit).concat([
                    "... extra " + (value.length - maxArrayLimit) + " values truncated ..."
                ]);
            }
        } else {
            // Add refinement after Array.isArray call.
            (0, _invariant.default)((typeof value === "undefined" ? "undefined" : _type_of._(value)) === 'object', 'This was already found earlier');
            var keys = Object.keys(value);
            if (stack.length >= maxDepth) {
                retval = "{ ... object with " + keys.length + " keys ... }";
            } else if (keys.length > maxObjectKeysLimit) {
                // Return a sample of the keys.
                retval = {};
                for(var _i = 0, _keys_slice = keys.slice(0, maxObjectKeysLimit); _i < _keys_slice.length; _i++){
                    var k = _keys_slice[_i];
                    retval[k] = value[k];
                }
                var truncatedKey = '...(truncated keys)...';
                retval[truncatedKey] = keys.length - maxObjectKeysLimit;
            }
        }
        stack.unshift(retval);
        return retval;
    }
    return function stringifySafe(arg) {
        if (arg === undefined) {
            return 'undefined';
        } else if (arg === null) {
            return 'null';
        } else if (typeof arg === 'function') {
            try {
                return arg.toString();
            } catch (e) {
                return '[function unknown]';
            }
        } else if (arg instanceof Error) {
            return arg.name + ': ' + arg.message;
        } else {
            // Perform a try catch, just in case the object has a circular
            // reference or stringify throws for some other reason.
            try {
                var ret = JSON.stringify(arg, replacer);
                if (ret === undefined) {
                    return '["' + (typeof arg === "undefined" ? "undefined" : _type_of._(arg)) + '" failed to stringify]';
                }
                return ret;
            } catch (e) {
                if (typeof arg.toString === 'function') {
                    try {
                        // $FlowFixMe[incompatible-use] : toString shouldn't take any arguments in general.
                        return arg.toString();
                    } catch (E) {}
                }
            }
        }
        return '["' + (typeof arg === "undefined" ? "undefined" : _type_of._(arg)) + '" failed to stringify]';
    };
}
var stringifySafe = createStringifySafeWithLimits({
    maxDepth: 10,
    maxStringLimit: 100,
    maxArrayLimit: 50,
    maxObjectKeysLimit: 50
});
var _default = stringifySafe;


}),

}]);//# sourceMappingURL=vendors-node_modules_react-native_Libraries_TurboModule_TurboModuleRegistry_js.chunk.bundle.map?platform=ios/* RCSSB */eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJoYXNoIjoiZGQ2ZDg2OTM3ZTViYTVkMTNiZGZkYjBkOWFjNjgwMDZiZGUzYTQyOGU0Y2I4MGExMmFhNDc2OGIwNDhjOTY1NiIsImlhdCI6MTc0ODg0NzM0MX0.kaMhkP5I3G0sLGPJ2W7pvlmIJuncdF56MWAMLxybbE0kkRQVo0CYxIRpr7ydojd-H_3vwxvbAtj_RRBFl215VEpAwt_j_KVh7xvAR33sSrBaQI7Bm_wL2BG7iVJ8s5pQtkl0vjpQ6tXvsfRIqeoiYyUjs4GESfW9AdJuMEOFKl-hzbHYAtRXoLPZPf66kV6PhVvkWhLfaeNxhUcosQ0_e6l6E3Q6yCuUZ1Qc08PnhPIeydlXSF-AJpfUO-hNNkU9cCAxNNiu282ldps13u1kufgpAiT6stb7en7496Vc1cluWniNEydMWlbUpb7ucXyf4SdkbT4OqJxq_6IsJpVuaw                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              